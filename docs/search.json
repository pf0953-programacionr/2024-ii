[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PF-0953 Programación en R 2024-II",
    "section": "",
    "text": "Bienvenida\nEste es un curso introductorio a la programación de computadoras y al procesamiento de datos geoespaciales mediante el lenguaje de programación R. También se estudian herramientas para facilitar la reproducibilidad de los procedimientos y la comunicación de las soluciones a través de Internet y otros medios. Se imparte en la Maestría Académica en Gestión Integrada del Recurso Hídrico para Latinoamérica y el Caribe de la Universidad de Costa Rica.\nEl enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplican en diversos escenarios de procesamiento de datos las habilidades y conocimientos aprendidos. No se requiere de experiencia en programación de computadoras. Es recomendable contar con conocimentos básicos de datos geoespaciales y sistemas de información geográfica.\nTanto las lecciones teóricas como las prácticas se imparten de manera presencial, con apoyo de medios virtuales. Los contenidos del curso y los recursos relacionados se comparten en el sitio web https://pf0953-programacionr.github.io/2024-ii/ y en la plataforma Mediación Virtual de la Universidad de Costa Rica.\n\n\nObjetivos\nAl finalizar el curso, el estudiantado será capaz de:\n\nDesarrollar programas en el lenguaje de programación R orientados al procesamiento de datos geoespaciales.\nAplicar un enfoque de ciencia de datos en los procesos de importación, transformación, visualización, análisis y comunicación de datos.\nDesarrollar soluciones reproducibles a problemas computacionales mediante R.\nIntegrar visualizaciones tabulares, gráficas y geoespaciales de datos en documentos y aplicaciones interactivas desarrolladas en R.\n\n\n\nPrograma\nEl programa del curso está disponible en programa del curso.\n\n\nCiclos anteriores\nEste sitio web corresponde al curso impartido durante el segundo ciclo lectivo de 2024. Para consultar las versiones de otros años y ciclos lectivos, puede visitar:\n\n2022-II\n\n\n\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html",
    "href": "10-introduccion-manejo-datos-geoespaciales.html",
    "title": "10  Introducción al manejo de datos geoespaciales con R",
    "section": "",
    "text": "10.1 Trabajo previo",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#trabajo-previo",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#trabajo-previo",
    "title": "10  Introducción al manejo de datos geoespaciales con R",
    "section": "",
    "text": "10.1.1 Lecturas\nLovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation with R (capítulos 1, 2 y 9). CRC Press. https://geocompr.robinlovelace.net/",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#introducción",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#introducción",
    "title": "10  Introducción al manejo de datos geoespaciales con R",
    "section": "10.2 Introducción",
    "text": "10.2 Introducción\nLa comunidad de programadores de R ha desarrollado un conjunto de paquetes para el manejo de datos geoespaciales, tanto en formatos vectoriales como raster. Algunos de los principales de estos paquetes son:\n\nEl paquete sf. Ofrece un conjunto de funciones para el manejo de datos vectoriales, de acuerdo con el estándar Simple Features.\nEl paquete terra. Implementa un conjunto de funciones para el manejo de datos raster. Es una reimplementación del paquete raster.\nEl paquete tmap. Se utiliza para programar mapas estáticos e interactivos, especialmente mapas temáticos como mapas de coropletas y mapas de burbujas.\n\nAlgunos paquetes de graficación estadística, como ggplot2 y plotly, también cuentan con capacidades para visualización de datos geoespaciales.\nEn CRAN Task View: Analysis of Spatial Data, puede encontrarse un resumen detallado de los paquetes de R con funciones geoespaciales.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#datos-vectoriales",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#datos-vectoriales",
    "title": "10  Introducción al manejo de datos geoespaciales con R",
    "section": "10.3 Datos vectoriales",
    "text": "10.3 Datos vectoriales\n\n10.3.1 El modelo vectorial\nEl modelo vectorial de datos está basado en puntos localizados en un sistema de referencia de coordenadas (CRS). Los puntos individuales pueden representar objetos independientes (ej. postes eléctricos, cabinas telefónicas) o pueden también agruparse para formar geometrías más complejas como líneas (ej. ríos, caminos) o polígonos (ej. fincas, países, provincias). Por lo general, los puntos tienen solo dos dimensiones (x, y), a las que se les puede agregar una tercera dimensión z, usualmente correspondiente a la altitud sobre el nivel del mar.\n\n\n10.3.2 El estándar Simple Features\nSimple Features (o Simple Feature Access) es un estándar abierto de la Organización Internacional de Estandarización (ISO) y del Open Geospatial Consortium (OGC) que especifica un modelo común de almacenamiento y acceso para geometrías de dos dimensiones (líneas, polígonos, multilíneas, multipolígonos, etc.). El estándar es implementado por muchas bibliotecas y bases de datos geoespaciales como sf, Fiona, GDAL, PostgreSQL/PostGIS, SQLite/SpatiaLite, Oracle Spatial y Microsoft SQL Server, entre muchas otras.\nLa especificación define 18 tipos de geometrías, de las cuales siete son las más comúnmente utilizadas. Estas últimas se muestran en la Figura 10.1.\n\n\n\n\n\n\n\n\nFigura 10.1: Tipos de geometrías de Simple Features más usadas. Imagen de Robin Lovelace et al..\n\n\n\n\n\n\n\n10.3.3 El paquete sf\nEl paquete sf (de Simple Features) de R implementa los modelos de datos de las geometrías de tipo vectorial: puntos, líneas, polígonos, sus versiones múltiples y las colecciones de geometrías. Está basado en bibliotecas de sofware ampliamente utilizadas en aplicaciones geoespaciales:\n\nGeospatial Data Abstraction Library (GDAL): es una biblioteca para leer y escribir datos geoespaciales en varios formatos raster y vectoriales. Implementa un único modelo abstracto de datos raster y un único modelo abstracto de datos vectoriales, lo que permite programar aplicaciones geoespaciales sin tener que ocuparse de las particularidades de cada formato que se utilice (GeoTIFF, NetCDF, ESRI Shapefile, GeoJSON, etc.). A pesar de que GDAL está programada en C/C++, cuenta con una interfaz de programación de aplicaciones (API) para varios lenguajes de programación, incluyendo C, C++, Python y Java. Además, ofrece un conjunto de utilitarios de línea de comandos cuyas distribuciones binarias están disponibles para varios sistemas operativos, incluyendo Windows, macOS y Linux.\nGeometry Engine, Open Source (GEOS): es una implementación en C++ de la biblioteca JTS Topology Suite (desarrollada en Java) y que implementa un conjunto de operaciones y predicados geoespaciales (ej. unión, intersección, distancia, área).\nPROJ: es una biblioteca que transforma coordenadas entre diferentes CRS, incluyendo tanto proyecciones cartográficas como transformaciones geodésicas.\n\nsf provee acceso, desde un mismo paquete de R, a la funcionalidad de estas tres bibliotecas, proporcionando así una interfaz unificada para leer y escribir datos geoespaciales mediante GDAL, realizar operaciones con geometrías mediante GEOS y efectuar transformaciones entre sistemas de coordenadas mediante PROJ.\nEn sf, los conjuntos de datos geoespaciales se almacenan en objetos de una clase también llamada sf, los cuales son data frames que contiene una columna especial para las geometrías. Esta columna se denomina generalmente geom o geometry (aunque pueden tener cualquier otro nombre). El manejo de datos geoespaciales como data frames permite manipularlos con las funciones ya desarrolladas para este tipo de datos y con la misma forma de referenciar las filas (observaciones) y las columnas (variables).\n\n10.3.3.1 Instalación y carga\n\n# Instalación de sf\ninstall.packages(\"sf\")\n\n\n# Carga de sf\nlibrary(sf)\n\n\n\n10.3.3.2 Métodos\nLa lista de métodos (i.e. funciones) de la clase sf puede obtenerse a través de la función methods():\n\n# Métodos de la clase sf\nmethods(class = \"sf\")\n\n [1] [                            [[&lt;-                        \n [3] [&lt;-                          $&lt;-                         \n [5] aggregate                    as.data.frame               \n [7] cbind                        coerce                      \n [9] dbDataType                   dbWriteTable                \n[11] duplicated                   identify                    \n[13] initialize                   merge                       \n[15] plot                         points                      \n[17] print                        rbind                       \n[19] show                         slotsFromS3                 \n[21] st_agr                       st_agr&lt;-                    \n[23] st_area                      st_as_s2                    \n[25] st_as_sf                     st_as_sfc                   \n[27] st_bbox                      st_boundary                 \n[29] st_break_antimeridian        st_buffer                   \n[31] st_cast                      st_centroid                 \n[33] st_collection_extract        st_concave_hull             \n[35] st_convex_hull               st_coordinates              \n[37] st_crop                      st_crs                      \n[39] st_crs&lt;-                     st_difference               \n[41] st_drop_geometry             st_exterior_ring            \n[43] st_filter                    st_geometry                 \n[45] st_geometry&lt;-                st_inscribed_circle         \n[47] st_interpolate_aw            st_intersection             \n[49] st_intersects                st_is_full                  \n[51] st_is_valid                  st_is                       \n[53] st_join                      st_line_merge               \n[55] st_m_range                   st_make_valid               \n[57] st_minimum_rotated_rectangle st_nearest_points           \n[59] st_node                      st_normalize                \n[61] st_point_on_surface          st_polygonize               \n[63] st_precision                 st_reverse                  \n[65] st_sample                    st_segmentize               \n[67] st_set_precision             st_shift_longitude          \n[69] st_simplify                  st_snap                     \n[71] st_sym_difference            st_transform                \n[73] st_triangulate_constrained   st_triangulate              \n[75] st_union                     st_voronoi                  \n[77] st_wrap_dateline             st_write                    \n[79] st_z_range                   st_zm                       \n[81] text                         transform                   \nsee '?methods' for accessing help and source code\n\n\nSeguidamente, se describen y ejemplifican algunos de los métodos básicos de la clase sf.\n\n10.3.3.2.1 st_read() - lectura de datos\nEl método st_read() lee datos vectoriales de una fuente en formato geoespacial (ej. shapefiles, archivos GeoJSON, bases de datos geoespaciales) y los recupera en un objeto sf.\nEn el siguiente bloque de código en R, se utiliza el método st_read() para leer un archivo GPKG con los polígonos de las provincias de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).\n\n# Lectura de una capa vectorial (GPKG) de provincias de Costa Rica\nprovincias &lt;-\n  st_read(\n    \"https://github.com/pf0953-programacionr/2024-ii/raw/refs/heads/main/datos/ign/provincias.gpkg\",\n    quiet = TRUE # para evitar el despliegue de mensajes\n  )\n\nst_read() también puede crear objetos sf a partir de archivos de texto. Esta variante se utiliza principalmente cuando el archivo contiene coordenadas correspondientes a geometrías de puntos.\nEn el siguiente bloque de código, se utiliza st_read() para leer un archivo CSV con registros de presencia de félidos (familia Felidae) de Costa Rica, el cual contiene dos columnas llamadas decimalLongitude y decimalLatitude correspondientes a la longitud decimal y latitud decimal en las que fue observado cada felino. Este archivo proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF).\n\n# Lectura de un archivo CSV con registros de presencia de félidos en Costa Rica\nfelidos &lt;-\n  st_read(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2024-ii/refs/heads/main/datos/gbif/felidos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\", # columna de longitud decimal\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"   # columna de latitud decimal\n    ),\n    quiet = TRUE\n  )\n\nTanto provincias como felidos son objetos de la clase sf (y además de data.frame).\n\n# Clase del objeto provincias\nclass(provincias)\n\n[1] \"sf\"         \"data.frame\"\n\n# Clase del objeto felidos\nclass(felidos)\n\n[1] \"sf\"         \"data.frame\"\n\n\nAl escribirse el nombre de un objeto sf en la consola de R, se despliega información general sobre este.\n\n# Información general sobre el objeto provincias\nprovincias\n\nSimple feature collection with 7 features and 9 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -87.10193 ymin: 5.499137 xmax: -82.55285 ymax: 11.21964\nGeodetic CRS:  WGS 84\n                 gml_id                gml_id2 OBJECTID CÓDIGO CÓDIGO_PROVINCIA\n1 limiteprovincial_5k.1 LIMITE_PROVINCIAL.2715     2715 160103                2\n2 limiteprovincial_5k.2 LIMITE_PROVINCIAL.2716     2716 160103                3\n3 limiteprovincial_5k.3 LIMITE_PROVINCIAL.2717     2717 160103                5\n4 limiteprovincial_5k.4 LIMITE_PROVINCIAL.2718     2718 160103                4\n5 limiteprovincial_5k.5 LIMITE_PROVINCIAL.2719     2719 160103                7\n6 limiteprovincial_5k.6 LIMITE_PROVINCIAL.2720     2720 160103                6\n7 limiteprovincial_5k.7 LIMITE_PROVINCIAL.2721     2721 160103                1\n   PROVINCIA\n1   Alajuela\n2    Cartago\n3 Guanacaste\n4    Heredia\n5      Limón\n6 Puntarenas\n7   San José\n                                                                                                                                                                                                        ORIGEN_DEL_TOPÓNIMO\n1                                                                                                                  Se remonta al paraje llamado La Lajuela que por primera vez se cita en los Protocolos de Cartago de 1657\n2                                         Don Juan Vázques de Coronado escogió el sitio en el valle del Guarco para trasladar a la ciudad de Garcimuños, en 1563, bautizando al nuevo asentamiento con el nombre de Cartago\n3        En alegoria a un frondoso árbol de Guanacaste ubicado en la intersección de los caminos que se dirigían a Nicoya, Bagaces y Rivas, en lo que hoy día es el parque de Liberia. Esta referencia data del siglo XVIII\n4                                        En correspondiencia al Presidente  de la Real Audiencia de Guatemala, Capitán General don Alonso Fernández de Heredia, de la Inmaculada Concepción de Cubujuquí a Villa de Heredia\n5                                                                                         El origen del nombre de la provincia se remonta a 1852, cuando por primera vez se cita en un documento oficial el puerto de Limón\n6 En documento de 1720, se menciona la llegada del pirata Chipperton a la zona, en el cual aparece la descripcíon referente a una embarcación pequeña en la Punta de Arena, adoptando con el tiempo el nombre de Puntarenas\n7                                                                                                                                              Se remonta a la creación de la ermita dedicada al Patriarca San José en 1737\n      VERSIÓN                               GLOBALID\n1 20240703001 {322A624B-14A4-44DB-BA11-F37A656BF296}\n2 20240703001 {46E33550-F4C9-436F-ADD7-CE70A6C46EB1}\n3 20240703001 {49CD624C-A818-4AF3-9370-DC219973EC03}\n4 20240703001 {1CA4FA45-F32C-4088-9031-C48CFC460B34}\n5 20240703001 {A062C16C-B115-439D-BB17-B261F64AF776}\n6 20240703001 {8D914665-65A7-44B6-9D63-95865A946757}\n7 20240703001 {B4447D8B-B85A-4D5E-A1D6-0EA14F13E084}\n                           SHAPE\n1 MULTIPOLYGON (((-84.66639 1...\n2 MULTIPOLYGON (((-84.03403 9...\n3 MULTIPOLYGON (((-85.3575 11...\n4 MULTIPOLYGON (((-84.02428 1...\n5 MULTIPOLYGON (((-83.7025 10...\n6 MULTIPOLYGON (((-84.82622 1...\n7 MULTIPOLYGON (((-83.9281 10...\n\n\n\n\n10.3.3.2.2 st_crs() y st_transform() - manejo de sistemas de coordenadas\nEl método st_crs() retorna el CRS de un objeto sf.\n\n# Despliegue del CRS del objeto provincias\nst_crs(provincias)\n\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n# Despliegue CRS del objeto felidos\nst_crs(felidos)\n\nCoordinate Reference System: NA\n\n\nst_crs() también puede asignar un CRS a un objeto sf que no lo tiene.\n\n# Asignación de un CRS al objeto felidos\nst_crs(felidos) &lt;- 4326\n\nEl método st_transform() transforma un objeto sf a un nuevo CRS.\n\n# Transformación del CRS del objeto provincias a WGS84 (EPSG = 4326)\nprovincias &lt;-\n  provincias |&gt;\n  st_transform(4326)\n\n\n\n10.3.3.2.3 plot() - mapeo\nEl método plot() grafica objetos sf en un mapa.\n\n# Mapeo de las geometrías del objeto provincias\nplot(provincias$SHAPE)\n\n\n\n\n\n\n\n# Mapeo con argumentos adicionales de plot()\nplot(\n  provincias$SHAPE,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\n\n\n\n\n\n\n\nLos argumentos reset y add de plot() permiten generar un mapa con varias capas.\n\n# Primera capa del mapa\nplot(\n  provincias$SHAPE,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Registros de presencia de félidos en Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE,\n  reset = FALSE\n)\n\n# Segunda capa\nplot(felidos$geometry,\n     add = TRUE,     \n     pch = 16,\n     col = \"orange\")\n\n\n\n\n\n\n\n\nPara conocer los valores del argumento pch, puede consultar R plot pch symbols.\n\n\n10.3.3.2.4 st_write() - escritura de datos\nEl método st_write() guarda en el disco un objeto sf en los diferentes formatos vectoriales de GDAL.\n\n# Especificación del directorio de trabajo (debe utilizarse una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura del objeto provincias en formato GeoJSON\nprovincias |&gt;\n  st_write(\"provincias.geojson\")\n\n# Escritura del objeto felidos en formato KML\nfelidos |&gt;\n  st_write(\"felidos.kml\")\n\n\n\n10.3.3.2.5 Otros\n\n# Cantidad de filas de un objeto sf\nnrow(provincias)\n\n[1] 7\n\n# Cantidad de columnas de un objeto sf\nncol(provincias)\n\n[1] 10\n\n# Resumen de la columna de geometría\nsummary(provincias$SHAPE)\n\n MULTIPOLYGON     epsg:4326 +proj=long... \n            7             0             0 \n\n\n\n\n\n\n10.3.4 Mapeo de objetos sf::sf con otros paquetes\n\n10.3.4.1 tmap\nEl paquete tmap genera mapas estáticos e interactivos con una sintaxis similar a la que utiliza el paquete ggplot2 para generar gráficos.\n\n10.3.4.1.1 Instalación y carga\nDe acuerdo con la recomendación que se brinda en el sitio web de tmap, se instala la versión disponible ahí (versión 4) y no la disponible en CRAN (versión 3).\n\n# Instalación de tmap (desde su repositorio en GitHub)\ninstall.packages(\"remotes\")\ninstall_github(\"r-tmap/tmap\")\n\n\n# Carga de tmap\nlibrary(tmap)\n\n\n\n10.3.4.1.2 Ejemplos de uso\nEl paquete tmap incluye varios conjuntos de datos de ejemplo, como el conjunto de datos World, que contiene información geoespacial y socioeconómica de países del mundo. El siguiente bloque de código muestra un mapa básico con los contornos de los países.\n\n# Carga de datos de ejemplo\ndata(\"World\")\n\n# Modo estático\ntmap_mode(\"plot\")\n\n# Mapa del mundo\ntm_shape(World) +\n  tm_polygons()\n\n\n\n\n\n\n\n\nLa función tm_shape() especifica el objeto espacial que se va a visualizar, mientras que tm_polygons() dibuja los polígonos.\nEl siguiente bloque de código crea un mapa de coropletas que colorea el mapa de acuerdo con el valor de una variable.\n\n# Modo interactivo\ntmap_mode(\"view\")\n\n# Mapa de coropletas por densidad de población\ntm_shape(World, name = \"Países\") +\n  tm_polygons(\n    col = \"pop_est_dens\", # columna para las coropletas\n    style = \"quantile\", # método de clasificación\n    palette = \"YlOrRd\", # paleta de colores\n    id = \"name\", # campo que se muestra al pasar el ratón\n    popup.vars = c(\"Área\" = \"area\", # campos de la ventana de pop-up\n                   \"Población\" = \"pop_est\",\n                   \"Densidad de población\" = \"pop_est_dens\"),\n    title = \"Densidad de población\")\n\n\n\n\n\nA continuación, se muestran las capas de provincias de Costa Rica (polígonos) y de registros de presencia de félidos de Costa Rica (puntos).\n\n# Crear mapa de provincias y félidos\nmapa_provincias_felidos &lt;-\n  tm_view(set.view = c(lon = -84.2, lat = 9.6, zoom = 7))  + # centro y zoom inicial\n  tm_shape(provincias, name = \"Provincias\") + # capa de provincias\n  tm_borders() +\n  tm_shape(felidos, name = \"Félidos\") + # capa de félidos\n  tm_dots(\n    col = \"species\", # color de los puntos\n    palette = \"Set1\", # paleta de colores\n    title = \"Especie\", # título de la leyenda\n    size = 0.05,  # tamaño de los puntos\n    id = \"species\", \n    popup.vars = c(\"Localidad\" = \"locality\",   \n                   \"Fecha\" = \"eventDate\",\n                   \"Fuente\" = \"institutionCode\")\n  ) +\n  tm_scale_bar(position = c(\"left\", \"bottom\")) # escala\n\n# Cambiar a modo interactivo\ntmap_mode(\"view\")\n\n# Desplegar el mapa\nmapa_provincias_felidos",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#datos-raster",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#datos-raster",
    "title": "10  Introducción al manejo de datos geoespaciales con R",
    "section": "10.4 Datos raster",
    "text": "10.4 Datos raster\n\n10.4.1 El modelo raster\nEl modelo de datos raster usualmente consiste de un encabezado y de una matriz con celdas (también llamadas pixeles) de un mismo tamaño. El encabezado define el CRS, la extensión y el punto de origen de una capa raster. Por lo general, el origen se ubica en la esquina inferior izquierda o en la esquina superior izquierda de la matriz. La extensión se define mediante el número de filas, el número de columnas y el tamaño (resolución) de la celda.\nCada celda tiene una identificación (ID) y almacena un único valor, el cual puede ser numérico o categórico, como se muestra en la Figura 10.2.\n\n\n\n\n\n\n\n\nFigura 10.2: El modelo raster: (A) ID de las celdas, (B) valores de las celdas, (C) mapa raster de colores. Imagen de Robin Lovelace et al.\n\n\n\n\n\nA diferencia del modelo vectorial, el modelo raster no necesita almacenar todas las coordenadas de cada geometría (i.e. las esquinas de las celdas), debido a que la ubicación de cada celda puede calcularse a partir de la información contenida en el encabezado. Esta simplicidad, en conjunto con el álgebra de mapas, permiten que el procesamiento de datos raster sea mucho más eficiente que el procesamiento de datos vectoriales. Por otra parte, el modelo vectorial es mucho más flexible en cuanto a las posibilidades de representación de geometrías y almacenamiento de valores, por medio de múltiples elementos de datos.\nLos mapas raster generalmente almacenan fenómenos continuos como elevación, precipitación, temperatura, densidad de población y datos espectrales. También es posible representar mediante raster datos discretos, tales como tipos de suelo o clases de cobertura de la tierra, como se muestra en la Figura 10.3.\n\n\n\n\n\n\n\n\nFigura 10.3: Ejemplos de mapas raster continuos y categóricos. Imagen de Robin Lovelace et al.\n\n\n\n\n\n\n\n10.4.2 El paquete terra\nEl paquete terra implementa un conjunto de funciones para la lectura, escritura, manipulación, análisis y modelado de datos raster y vectoriales. Implementa la clase SpatRaster para manejar los objetos raster.\n\n10.4.2.1 Instalación y carga\n\n# Instalación de terra\ninstall.packages(\"terra\")\n\n\n# Carga de terra\nlibrary(terra)\n\n\n\n10.4.2.2 Métodos\nLa función help() presenta la documentación del paquete terra, incluyendo sus métodos.\n\n# Ayuda sobre el paquete terra\nhelp(\"terra-package\")\n\nSeguidamente, se describen y ejemplifican algunos de los métodos básicos para manejo de datos raster del paquete terra.\n\n10.4.2.2.1 rast() - lectura de datos\nEl método rast() lee datos raster.\nEn el siguiente bloque de código en R, se utiliza el método rast() para leer un archivo GeoTIFF correspondiente a la altitud de Costa Rica. Este archivo proviene de WorldClim, un conjunto de capas climáticas disponibles en varias resoluciones espaciales.\n\n# Lectura de una capa raster de altitud\naltitud &lt;-\n  rast(\n    \"https://github.com/pf0953-programacionr/2024-ii/raw/refs/heads/main/datos/worldclim/altitud.tif\"\n  )\n\naltitud es un objeto de la clase SpatRaster.\n\n# Clase del objeto altitud\nclass(altitud)\n\n[1] \"SpatRaster\"\nattr(,\"package\")\n[1] \"terra\"\n\n\nAl escribirse el nombre de un objeto SpatRaster en la consola de R, se despliega información general sobre este.\n\n# Información general sobre el objeto altitud\naltitud\n\nclass       : SpatRaster \ndimensions  : 686, 545, 1  (nrow, ncol, nlyr)\nresolution  : 0.008333333, 0.008333333  (x, y)\nextent      : -87.1, -82.55833, 5.5, 11.21667  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : altitud.tif \nname        : altitud \n\n\n\n\n10.4.2.2.2 crs() y project() - manejo de sistemas de coordenadas\nEl método crs() retorna el CRS de un objeto SpatRaster.\n\n# CRS del objeto altitud\ncrs(altitud)\n\n[1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"\n\n\ncrs() también puede asignar un CRS a un objeto SpatRaster.\n\n# Asignación de un CRS a una copia del objeto altitud\naltitud_crtm05 &lt;- altitud\ncrs(altitud_crtm05) &lt;- \"EPSG:5367\"\n\n# Consulta\ncrs(altitud_crtm05)\n\n[1] \"PROJCRS[\\\"CR05 / CRTM05\\\",\\n    BASEGEOGCRS[\\\"CR05\\\",\\n        DATUM[\\\"Costa Rica 2005\\\",\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",5365]],\\n    CONVERSION[\\\"Costa Rica TM 2005\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-84,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9999,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"northing (N)\\\",north,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"easting (E)\\\",east,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Cadastre, engineering survey, topographic mapping (large and medium scale).\\\"],\\n        AREA[\\\"Costa Rica - onshore and offshore east of 86°30'W.\\\"],\\n        BBOX[2.21,-86.5,11.77,-81.43]],\\n    ID[\\\"EPSG\\\",5367]]\"\n\n\nEl método project() reproyecta un objeto SpatRaster a un nuevo CRS.\n\n# Transformación del CRS del objeto altitud\naltitud_utm17N &lt;-\n  altitud |&gt;\n  project(\"EPSG:8910\")\n\n# Consulta\ncrs(altitud_utm17N)\n\n[1] \"PROJCRS[\\\"CR-SIRGAS / UTM zone 17N\\\",\\n    BASEGEOGCRS[\\\"CR-SIRGAS\\\",\\n        DATUM[\\\"CR-SIRGAS\\\",\\n            ELLIPSOID[\\\"GRS 1980\\\",6378137,298.257222101,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",8907]],\\n    CONVERSION[\\\"UTM zone 17N\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-81,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9996,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Oil and gas exploration and production.\\\"],\\n        AREA[\\\"Costa Rica - offshore - Caribbean sea.\\\"],\\n        BBOX[9.6,-83.6,11.77,-81.43]],\\n    ID[\\\"EPSG\\\",8910]]\"\n\n\n\n\n10.4.2.2.3 plot() - mapeo\nEl método plot() muestra objetos SpatRaster en un mapa.\n\n# Mapa de la capa de altitud\nplot(altitud)\n\n\n\n\n\n\n\n\nLos argumentos reset y add de plot() permiten generar un mapa con varias capas.\n\n# Primera capa del mapa (raster)\nplot(\n  altitud,\n  main = \"Registros de presencia de félidos en Costa Rica\",\n  axes = TRUE,\n  reset = FALSE\n)\n\n# Segunda capa (vectorial)\nplot(felidos$geometry,\n     add = TRUE,     \n     pch = 16,\n     col = \"orange\")\n\n\n\n\n\n\n\n\n\n\n10.4.2.2.4 writeRaster() - escritura de datos\nLa función writeRaster() guarda en el disco un objeto SpatRaster en los diferentes formatos raster de GDAL.\n\n# Especificación del directorio de trabajo (debe utilizarse una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura del objeto altitud\naltitud |&gt;\n  writeRaster(\"altitud.asc\")\n\n\n\n10.4.2.2.5 Otros\n\n# Cantidad de filas de un objeto SpatRaster\nnrow(altitud)\n\n[1] 686\n\n# Cantidad de columnas de un objeto SpatRaster\nncol(altitud)\n\n[1] 545\n\n# Resolución de un objeto SpatRaster\nres(altitud)\n\n[1] 0.008333333 0.008333333\n\n\n\n\n\n\n10.4.3 Mapeo de objetos terra::SpatRaster con otros paquetes\n\n10.4.3.1 tmap\nEl método tm_raster() de tmap despliega un objeto SpatRaster en un mapa tmap. En el siguiente bloque, se muestran en un mapa tmap las capas de altitud (raster), provincias (polígonos) y registros de presencia de félidos (puntos).\n\n# Crear mapa de provincias y félidos\nmapa_altitud_provincias_felidos &lt;-\n  tm_view(set.view = c(lon = -84.2, lat = 9.6, zoom = 7))  + # centro y zoom inicial\n  tm_shape(altitud, name = \"Altitud\") + # capa de altitud\n  tm_raster(\n    palette = c(\"green\", \"yellow\", \"brown\", \"gray\"), \n    title = \"Altitud (m)\"\n  ) +\n  tm_shape(provincias, name = \"Provincias\") + # capa de provincias\n  tm_borders() +\n  tm_shape(felidos, name = \"Félidos\") + # capa de félidos\n  tm_dots(\n    col = \"species\", # color de los puntos\n    palette = \"Set1\", # paleta de colores\n    title = \"Especie\", # título de la leyenda\n    size = 0.05,  # tamaño de los puntos\n    id = \"species\", # campo que se muestra al pasar el ratón\n    popup.vars = c(\"Localidad\" = \"locality\",   # campos de la ventana de pop-up\n                   \"Fecha\" = \"eventDate\",\n                   \"Fuente\" = \"institutionCode\")\n  ) +\n  tm_scale_bar(position = c(\"left\", \"bottom\")) # escala\n\n# Cambiar a modo interactivo\ntmap_mode(\"view\")\n\n# Desplegar el mapa\nmapa_altitud_provincias_felidos",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#ejercicios",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#ejercicios",
    "title": "10  Introducción al manejo de datos geoespaciales con R",
    "section": "10.5 Ejercicios",
    "text": "10.5 Ejercicios\nEn un documento Quarto incluya:\n\nUna tabla DT con las columnas del conjunto de datos de félidos de Costa Rica correspondientes a especie (species), fecha (eventDate), provincia (stateProvince), localidad (locality), longitud (decimalLongitude) y latitud (decimalLatitude).\n\nLas columnas deben, si es necesario, convertirse al tipo de datos adecuado (ej. Date).\nLos encabezados de las columnas en la tabla deben desplegarse en español, pero no deben alterarse los nombres de las columnas. Sugerencia: utilice el argumento colnames de la función datatable().\nLos controles de la tabla deben estar en español.\n\nUn gráfico de barras, generado con gglot2 y traducido a plotly con ggplotly(), que muestre la cantidad de registros para cada especie de félidos.\n\nLas barras deben estar ordenadas de mayor a menor.\nTodos los controles y etiquetas del gráfico deben estar en español.\n\nUn mapa tmap con las siguientes capas:\n\nProvincias de Costa Rica (polígonos).\nRegistros de presencia de félidos (puntos).\n\n\nPublique el documento como un sitio web en GitHub Pages.\nSi lo desea, puede utilizar datos de otra zona o país y de otro grupo taxonómico. Se sugieren las siguientes fuentes de datos:\n\nGlobal Biodiversity Information Facility (GBIF) (registros de presencia de especies)\nGADM (datos geoespaciales de países y división territorial administrativa)\nNatural Earth (datos geoespaciales de países, división territorial administrativa y otros)\nWorldClim (datos geoespaciales de clima)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "10-introduccion-manejo-datos-geoespaciales.html#recursos-de-interés",
    "href": "10-introduccion-manejo-datos-geoespaciales.html#recursos-de-interés",
    "title": "10  Introducción al manejo de datos geoespaciales con R",
    "section": "10.6 Recursos de interés",
    "text": "10.6 Recursos de interés\nBivand, R. (2022). CRAN Task View: Analysis of Spatial Data. https://CRAN.R-project.org/view=Spatial\nHoltz, Y. (s. f.). The R Graph Gallery – Help and inspiration for R charts. The R Graph Gallery. https://r-graph-gallery.com/\nPopovic, M. (s. f.). Milos Makes Maps. https://www.youtube.com/@milos-makes-maps\nR-Ladies Madrid. (2021). R-Ladies Madrid (español)—Analiza datos espaciales—Stephanie Orellana. https://www.youtube.com/watch?v=59tO2ARvVVU",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Introducción al manejo de datos geoespaciales con R</span>"
    ]
  },
  {
    "objectID": "parte-i-introduccion-programacion-computadoras-ciencia-datos.html",
    "href": "parte-i-introduccion-programacion-computadoras-ciencia-datos.html",
    "title": "I - Introducción a la programación de computadoras y a la ciencia de datos",
    "section": "",
    "text": "1 Introducción a la programación de computadoras\n2 Introducción a la ciencia de datos",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos"
    ]
  },
  {
    "objectID": "parte-ii-lenguaje-programacion-r.html",
    "href": "parte-ii-lenguaje-programacion-r.html",
    "title": "II - El lenguaje de programación R",
    "section": "",
    "text": "3 R - lenguaje de programación para análisis estadístico",
    "crumbs": [
      "II - El lenguaje de programación R"
    ]
  },
  {
    "objectID": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "href": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "title": "III - Herramientas para investigación reproducible y desarrollo colaborativo",
    "section": "",
    "text": "5 Reproducibilidad\n6 Markdown - lenguaje de marcado\n7 Git - sistema de control de versiones\n8 Quarto - sistema de publicación técnica y científica",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo"
    ]
  },
  {
    "objectID": "parte-iv-graficacion-estadistica-r.html",
    "href": "parte-iv-graficacion-estadistica-r.html",
    "title": "IV - Graficación estadística en R",
    "section": "",
    "text": "7 Tidyverse - colección de paquetes para ciencia de datos\n8 dplyr - gramática para manipulación de datos\n9 ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "crumbs": [
      "IV - Graficación estadística en R"
    ]
  },
  {
    "objectID": "programa_curso.html",
    "href": "programa_curso.html",
    "title": "Programa del curso",
    "section": "",
    "text": "Programa del curso",
    "crumbs": [
      "Programa del curso"
    ]
  },
  {
    "objectID": "11-modelos-nichos-ecologicos.html",
    "href": "11-modelos-nichos-ecologicos.html",
    "title": "11  Modelos de nichos ecológicos",
    "section": "",
    "text": "11.1 Introducción\nLos modelos de nichos ecológicos permiten predecir la distribución potencial de especies en función de datos de presencia y variables ambientales (ej. clima, suelo, vegetación, altitud). Puede consultar estas diapositivas sobre el tema.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelos de nichos ecológicos</span>"
    ]
  },
  {
    "objectID": "11-modelos-nichos-ecologicos.html#instalación-y-carga-de-paquetes",
    "href": "11-modelos-nichos-ecologicos.html#instalación-y-carga-de-paquetes",
    "title": "11  Modelos de nichos ecológicos",
    "section": "11.2 Instalación y carga de paquetes",
    "text": "11.2 Instalación y carga de paquetes\nSe utilizan varios paquetes para manejar datos geoespaciales y para ejecutar la modelización.\n\n# Paquete para acceder datos en GBIF\ninstall.packages(\"rgbif\")\n\n# Paquete para acceder datos geoespaciales\ninstall.packages(\"geodata\")\n\n# Paquete para mapas interactivos\ninstall.packages(\"leaflet\")\n\n# Paquete para modelado de distribución de especies\ninstall.packages(\"dismo\")\n\n\n# Colección de paquetes de Tidyverse\nlibrary(tidyverse)\n\n# Estilos para ggplot2\nlibrary(ggthemes)\n\n# Paletas de colores de RColorBrewer\nlibrary(RColorBrewer)\n\n# Paletas de colores de viridis\nlibrary(viridisLite)\n\n# Gráficos interactivos\nlibrary(plotly)\n\n# Manejo de datos vectoriales\nlibrary(sf)\n\n# Manejo de datos raster\nlibrary(terra)\n\n# Manejo de datos raster\nlibrary(raster)\n\n# Mapas interactivos\nlibrary(leaflet)\n\n# Acceso a datos en GBIF\nlibrary(rgbif)\n\n# Datos geoespaciales\nlibrary(geodata)\n\n# Modelado de distribución de especies\nlibrary(dismo)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelos de nichos ecológicos</span>"
    ]
  },
  {
    "objectID": "11-modelos-nichos-ecologicos.html#obtención-de-datos-de-presencia",
    "href": "11-modelos-nichos-ecologicos.html#obtención-de-datos-de-presencia",
    "title": "11  Modelos de nichos ecológicos",
    "section": "11.3 Obtención de datos de presencia",
    "text": "11.3 Obtención de datos de presencia\nEn el siguiente bloque se especifica el nombre de la especie que se va a modelar. Como ejemplo inicial se desarrolla un modelo de distribución de Bradypus variegatus (perezoso de tres dedos).\n\n# Nombre de la especie\nespecie &lt;- \"Bradypus variegatus\"\n\nPara obtener los datos de presencia se emplea el paquete rgbif, el cual proporciona acceso a los datos agrupados por el Sistema Mundial de Información en Biodiversidad (GBIF).\n\n# Consulta a GBIF\nrespuesta &lt;- occ_search(\n  scientificName = especie, \n  hasCoordinate = TRUE,\n  hasGeospatialIssue = FALSE,\n  limit = 10000\n)\n\n# Extraer datos de presencia\npresencia &lt;- respuesta$data\n\nOpcionalmente, se puede guardar el dataframe con los datos de presencia en un archivo CSV, para no tener que repetir la consulta al API de GBIF.\n\n# Guardar los datos de presencia en un archivo CSV\nwrite_csv(presencia, 'presencia.csv')\n\nEl siguiente bloque debe ejecutarse si se desea leer los datos desde el archivo CSV.\n\n# Leer los datos de presencia de un archivo CSV\npresencia &lt;- read_csv('presencia.csv')\n\nPara manejarlo como un conjunto de datos geoespacial, el dataframe retornado por occ_search() se convierte a un objeto sf.\n\npresencia &lt;- st_as_sf(\n  presencia,\n  coords = c(\"decimalLongitude\", \"decimalLatitude\"),\n  remove = FALSE, # conservar las columnas de las coordenadas\n  crs = 4326\n)\n\n\n11.3.1 Registros por país\n\n\nCódigo\n# Gráfico ggplot2\ngrafico_ggplot2 &lt;-\n  presencia |&gt;\n  st_drop_geometry() |&gt;\n  ggplot(aes(x = fct_infreq(countryCode))) +\n  geom_bar(\n    aes(\n      text = paste0(\n        \"Cantidad de registros de presencia: \", after_stat(count)\n      )\n    )    \n  ) +\n  ggtitle(\"Cantidad de registros de presencia por país\") +\n  xlab(\"País\") +\n  ylab(\"Cantidad de registros de presencia\") +\n  labs(caption = \"Fuente: GBIF\") +\n  theme_economist()\n\n# Gráfico plotly\nggplotly(grafico_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\n\n\n11.3.2 Registros por año\n\n\nCódigo\n# Gráfico ggplot2\ngrafico_ggplot2 &lt;-\n  presencia |&gt;\n  st_drop_geometry() |&gt;\n  group_by(year) |&gt;\n  summarize(n = n()) |&gt;\n  ggplot(aes(x = year, y = n)) +\n  geom_line() +\n  geom_point(\n    aes(\n      text = paste0(\n        \"Año: \", year, \"\\n\",\n        \"Cantidad de registros: \", n\n      )\n    )\n  ) +\n  ggtitle(\"Cantidad de registros de presencia por año\") +\n  xlab(\"Año\") +\n  ylab(\"Cantidad de registros de presencia\") +\n  labs(caption = \"Fuente: GBIF\") +\n  theme_economist()\n\n# Gráfico plotly\nggplotly(grafico_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\n\n\n11.3.3 Mapa\n\n\nCódigo\n# Mapa\nleaflet() |&gt;\n  addTiles(group = \"Mapa general\") |&gt;\n  addProviderTiles(\n    providers$Esri.WorldImagery, \n    group = \"Imágenes satelitales\"\n  ) |&gt;\n  addProviderTiles(\n    providers$CartoDB.Positron, \n    group = \"Mapa blanco\"\n  ) |&gt;  \n  addCircleMarkers(\n    # capa de registros de presencia (puntos)\n    data = presencia,\n    stroke = F,\n    radius = 3,\n    fillColor = 'red',\n    fillOpacity = 1,\n    popup = paste(\n      paste0(\"&lt;strong&gt;País: &lt;/strong&gt;\", presencia$country),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", presencia$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", presencia$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", presencia$institutionCode),\n      paste0(\"&lt;a href='\", presencia$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Registros de Bradypus variegatus\"\n  ) |&gt;\n  addLayersControl(\n    baseGroups = c(\"Mapa general\", \"Imágenes satelitales\", \"Mapa blanco\"),\n    overlayGroups = c(\"Registros de Bradypus variegatus\"))",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelos de nichos ecológicos</span>"
    ]
  },
  {
    "objectID": "11-modelos-nichos-ecologicos.html#obtención-de-datos-climáticos",
    "href": "11-modelos-nichos-ecologicos.html#obtención-de-datos-climáticos",
    "title": "11  Modelos de nichos ecológicos",
    "section": "11.4 Obtención de datos climáticos",
    "text": "11.4 Obtención de datos climáticos\nLas variables climáticas se obtienen mediante el paquete geodata, el cual brinda acceso a varios conjuntos de datos geoespaciales. En este caso, se descargan las variables bioclimáticas de WorldClim.\n\n# Consulta a WorldClim\nclima &lt;- worldclim_global(var = 'bio', res = 10, path = tempdir())\n\n# Nombres de las variables climáticas\nnames(clima)\n\n [1] \"wc2.1_10m_bio_1\"  \"wc2.1_10m_bio_2\"  \"wc2.1_10m_bio_3\"  \"wc2.1_10m_bio_4\" \n [5] \"wc2.1_10m_bio_5\"  \"wc2.1_10m_bio_6\"  \"wc2.1_10m_bio_7\"  \"wc2.1_10m_bio_8\" \n [9] \"wc2.1_10m_bio_9\"  \"wc2.1_10m_bio_10\" \"wc2.1_10m_bio_11\" \"wc2.1_10m_bio_12\"\n[13] \"wc2.1_10m_bio_13\" \"wc2.1_10m_bio_14\" \"wc2.1_10m_bio_15\" \"wc2.1_10m_bio_16\"\n[17] \"wc2.1_10m_bio_17\" \"wc2.1_10m_bio_18\" \"wc2.1_10m_bio_19\"\n\n\nSeguidamente, se “recortan” las capas raster climáticas provenientes de WorldClim para así cubrir solamente el área en la que se encuentra presente la especie.\n\n# Definir la extensión del área de estudio\narea_estudio &lt;- ext(\n  min(presencia$decimalLongitude) - 5, \n  max(presencia$decimalLongitude) + 5,\n  min(presencia$decimalLatitude) - 5, \n  max(presencia$decimalLatitude) + 5\n)\n\n# Recortar las variables bioclimáticas al área de estudio\nclima &lt;- crop(clima, area_estudio)\n\n\n11.4.1 Mapa\n\n\nCódigo\n# Paleta de colores de temperatura\ncolores_temperatura &lt;- colorNumeric(\n  # palette = \"inferno\",\n  # palette = \"magma\",\n  palette = rev(brewer.pal(11, \"RdYlBu\")),\n  values(clima$wc2.1_10m_bio_1),\n  na.color = \"transparent\"\n)\n\n# Paleta de colores de precipitación\ncolores_precipitacion &lt;- colorNumeric(\n  # palette = \"viridis\",\n  # palette = \"YlGnBu\",  \n  palette = \"Blues\",\n  values(clima$wc2.1_10m_bio_12),\n  na.color = \"transparent\"\n)\n\n# Mapa\nleaflet() |&gt;\n  addTiles(group = \"Mapa general\") |&gt;\n  addProviderTiles(\n    providers$Esri.WorldImagery, \n    group = \"Imágenes satelitales\"\n  ) |&gt;  \n  addProviderTiles(\n    providers$CartoDB.Positron, \n    group = \"Mapa blanco\"\n  ) |&gt;\n  addRasterImage( # capa raster de temperatura\n    clima$wc2.1_10m_bio_1,\n    colors = colores_temperatura, # paleta de colores\n    opacity = 0.6,\n    group = \"Temperatura\",\n  ) |&gt;\n  addRasterImage( # capa raster de precipitación\n    clima$wc2.1_10m_bio_12,\n    colors = colores_precipitacion, # paleta de colores\n    opacity = 0.6,\n    group = \"Precipitación\",\n  ) |&gt;\n  addCircleMarkers(\n    # capa de registros de presencia (puntos)\n    data = presencia,\n    stroke = F,\n    radius = 3,\n    fillColor = 'red',\n    fillOpacity = 1,\n    popup = paste(\n      paste0(\"&lt;strong&gt;País: &lt;/strong&gt;\", presencia$country),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", presencia$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", presencia$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", presencia$institutionCode),\n      paste0(\"&lt;a href='\", presencia$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Registros de Bradypus variegatus\"\n  ) |&gt;  \n  addLegend(\n    title = \"Temperatura\",\n    values = values(clima$wc2.1_10m_bio_1),\n    pal = colores_temperatura,\n    position = \"bottomleft\",\n    group = \"Temperatura\"\n  ) |&gt;\n  addLegend(\n    title = \"Precipitación\",\n    values = values(clima$wc2.1_10m_bio_12),\n    pal = colores_precipitacion,\n    position = \"bottomleft\",\n    group = \"Precipitación\"\n  ) |&gt;  \n  addLayersControl(\n    # control de capas\n    baseGroups = c(\"Mapa general\", \"Imágenes satelitales\", \"Mapa blanco\"),\n    overlayGroups = c(\"Temperatura\", \"Precipitación\", \"Registros de Bradypus variegatus\")\n  ) |&gt;\n  hideGroup(\"Precipitación\")",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelos de nichos ecológicos</span>"
    ]
  },
  {
    "objectID": "11-modelos-nichos-ecologicos.html#modelización",
    "href": "11-modelos-nichos-ecologicos.html#modelización",
    "title": "11  Modelos de nichos ecológicos",
    "section": "11.5 Modelización",
    "text": "11.5 Modelización\n\n11.5.1 Creación de conjuntos de entrenamiento y de evaluación\nPrimero, se eliminan las coordenadas duplicadas del conjunto de datos de presencia.\n\n# Crear dataframe con columnas de longitud y latitud\ncoordenadas_presencia &lt;- data.frame(\n  decimalLongitude = presencia$decimalLongitude,\n  decimalLatitude = presencia$decimalLatitude\n)\n\n# Eliminar coordenadas duplicadas\ncoordenadas_presencia &lt;- unique(coordenadas_presencia)\n\nSeguidamente se dividen los datos de presencia en dos subconjuntos:\n\nEntrenamiento: para desarrollar el modelo.\nEvaluación: para evaluar el modelo.\n\n\n# Establecer una \"semilla\" para garantizar que la selección aleatoria sea reproducible\nset.seed(123)\n\n# Cantidad de registros de presencia\nn_presencia &lt;- nrow(coordenadas_presencia)\n\n# Con sample(), se selecciona aleatoriamente una proporción (ej. 0.7) \n# de los índices de los datos de presencia para el conjunto de entrenamiento\nindices_entrenamiento &lt;- sample(\n  1:n_presencia, \n  size = round(0.7 * n_presencia)\n)\n\n# Crear el subconjunto de entrenamiento utilizando los índices seleccionados\nentrenamiento &lt;- coordenadas_presencia[indices_entrenamiento, ]\n\n# Crear el subconjunto de evaluación con los datos restantes\nevaluacion &lt;- coordenadas_presencia[-indices_entrenamiento, ]\n\nPara elaborar el modelo de distribución se utiliza el paquete dismo, el cual implementa varios algoritmos de modelado de distribución de especies. Cada algoritmo recibe como entradas un conjunto de datos de presencia de una especie y un conjunto de variables climáticas (en formato raster).\n\n\n11.5.2 Modelo Maxent\nEl algoritmo Maxent se basa en el principio de máxima entropía, que sugiere que, con información incompleta, la mejor opción es la distribución menos sesgada posible que aún sea consistente con los datos. En este caso, Maxent encuentra la distribución de la especie que maximiza la entropía (es decir, la más uniforme posible) dado un conjunto de restricciones.\nLa implementación de Maxent que se incluye en el paquete dismo fue programada en el lenguaje Java. Por lo tanto, para ejecutarla es necesario instalar:\n\nEl Java Development Kit (JDK), para ejecutar aplicaciones desarrolladas en Java.\nEl paquete rJava para acceder a aplicaciones Java desde R.\n\n\n11.5.2.1 Generación\n\n# Los datos de clima deben convertirse al formato que usa el paquete raster\n# debido a es este el que acepta el paquete dismo\nclima &lt;- raster::stack(clima)\n\n# Ejecutar el modelo\nmodelo_maxent &lt;- maxent(x = clima, p = entrenamiento)\n\n# Aplicar el modelo entrenado a las variables climáticas \n# para generar un mapa de idoneidad del hábitat\nprediccion &lt;- predict(modelo_maxent, clima)\n\n\n\n11.5.2.2 Evaluación\nEl siguiente bloqu de código genera métricas de desempeño del modelo utilizando los valores predichos en puntos de presencia y ausencia.\n\n# terra::extract() extrae los valores del raster de predicción \n# en las coordenadas de evaluación\n# eval_pres almacena los valores de idoneidad predichos \n# en los puntos de evaluación de presencia\neval_pres &lt;- terra::extract(\n  prediccion, \n  evaluacion[, c('decimalLongitude', 'decimalLatitude')]\n)\n\n# Generar puntos aleatorios dentro del área de estudio definida. \n# Estos puntos se asumen como ausencias de la especie.\nausencias &lt;- randomPoints(mask = clima, n = 1000)\n\n# eval_aus almacena los valores de idoneidad predichos\n# en los puntos de ausencia\neval_aus &lt;- terra::extract(\n  prediccion, \n  ausencias\n)\n\n# Generar estadísticas de evaluación del modelo\nresultado_evaluacion &lt;- evaluate(p = eval_pres, a = eval_aus)\n\nLas métricas de desempeño generadas en el bloque de código anterior se basan en la curva ROC y el AUC. La curva ROC (Receiver Operating Characteristic) es una herramienta gráfica que se utiliza para evaluar el rendimiento de un modelo de clasificación binaria, en este caso, para distinguir entre presencia y ausencia de una especie. El AUC (Area Under the Curve) es una métrica derivada de la curva ROC que resume su rendimiento en un solo valor.\nPara interpretar la curva ROC y el AUC es necesario comprender los siguientes conceptos:\n\nVerdaderos Positivos (True Positives, TP): son los casos en los que el modelo predice correctamente la presencia de la especie en un área donde la especie realmente está presente.\nFalsos Positivos (False Positives, FP): son los casos en los que el modelo predice la presencia de la especie en un área donde la especie realmente no está presente.\nVerdaderos Negativos (True Negatives, TN): son los casos en los que el modelo predice correctamente la ausencia de la especie en un área donde la especie realmente no está presente.\nFalsos Negativos (False Negatives, FN): son los casos en los que el modelo predice la ausencia de la especie en un área donde la especie realmente está presente.\n\nLas definiciones anteriores se resumen en la siguiente tabla:\n\n\n\n\n\n\n\nPredicción: Presencia\n\n\nPredicción: Ausencia\n\n\n\n\n\n\nRealidad: Presencia\n\n\nVerdadero Positivo (TP)\n\n\nFalso Negativo (FN)\n\n\n\n\nRealidad: Ausencia\n\n\nFalso Positivo (FP)\n\n\nVerdadero Negativo (TN)\n\n\n\n\nLa tabla anterior es una matriz de confusión, una herramienta para evaluar el rendimiento de un modelo de clasificación. Resume los resultados de las predicciones del modelo comparándolas con los valores reales conocidos. En el contexto de los modelos de nicho ecológico, nos ayuda a entender cómo el modelo clasifica correctamente o incorrectamente las presencias y ausencias de una especie.\nLa curva ROC representa la relación entre la Tasa de Verdaderos Positivos (True Positive Rate, TPR) y la Tasa de Falsos Positivos (False Positive Rate, FPR) para diferentes umbrales de decisión del modelo.\n\nTPR (Sensibilidad o recall): es la proporción de verdaderos positivos correctamente identificados por el modelo respecto al total de verdaderos positivos reales.\n\n\\[\\text{TPR} = \\frac{\\text{Verdaderos Positivos}}{\\text{Verdaderos Positivos} + \\text{Falsos Negativos}}\\]\n\nFPR: es la proporción de falsos positivos identificados por el modelo respecto al total de negativos reales.\n\n\\[\\text{FPR} = \\frac{\\text{Falsos Positivos}}{\\text{Falsos Positivos} + \\text{Verdaderos Negativos}}\\]\nUn umbral es un valor específico que se utiliza para convertir las predicciones continuas del modelo en clasificaciones binarias, es decir, en predicciones de presencia o ausencia de una especie. Los modelos como Maxent generan valores continuos que representan la idoneidad del hábitat o la probabilidad de presencia de una especie en cada punto en el espacio. Estos valores oscilan entre 0 (baja idoneidad) y 1 (alta idoneidad).\nPara muchas aplicaciones prácticas, es necesario convertir estos valores continuos en categorías binarias de presencia o ausencia. Es necesario entonces definir un umbral (i.e. “un valor de corte”) que determina a partir de qué punto consideramos que la especie está presente.\n\nSi el valor predicho es mayor o igual que el umbral, se predice presencia.\nSi el valor predicho es menor que el umbral, se predice ausencia.\n\nEs importante tener el cuenta el efecto que el umbral tiene en las predicciones. Si el umbral es alto, menos áreas serán clasificadas como presencia. Aumenta la especificidad (menos falsos positivos), pero puede disminuir la sensibilidad (más falsos negativos). Por otra parte, si el umbral es bajo, más áreas serán clasificadas como presencia. Aumenta la sensibilidad (menos falsos negativos), pero puede disminuir la especificidad (más falsos positivos).\nCada punto en la curva ROC representa un par (FPR, TPR) para un umbral específico. Al mover el umbral de decisión, cambiamos la sensibilidad y la especificidad del modelo, lo que se refleja en la curva. Una curva que se acerca más al punto superior izquierdo (TPR = 1, FPR = 0) indica un mejor rendimiento, ya que significa alta sensibilidad y baja tasa de falsos positivos. Una línea diagonal desde (0,0) hasta (1,1) representa un modelo que clasifica al azar (AUC = 0.5).\nEl AUC es el área bajo la curva ROC y proporciona una medida agregada del rendimiento del modelo en todos los umbrales posibles.\n\nAUC = 1.0: rendimiento perfecto; el modelo clasifica correctamente todas las instancias positivas y negativas.\nAUC = 0.5: rendimiento aleatorio; el modelo no tiene capacidad discriminativa.\nAUC &lt; 0.5: rendimiento peor que el azar; indica que el modelo está invertido en su capacidad predictiva.\n\nEl siguiente bloque de código muestra la curva ROC y el AUC para el modelo que se generó.\n\n\nCódigo\n# Datos para graficar la curva ROC\ndatos_roc &lt;- data.frame(\n  FPR = resultado_evaluacion@FPR,\n  TPR = resultado_evaluacion@TPR,\n  Umbral = resultado_evaluacion@t\n)\n\n# Valor AUC\nauc &lt;- resultado_evaluacion@auc\n\n# Gráfico ggplot2\ngrafico_ggplot2 &lt;-\n  ggplot(\n    datos_roc, \n    aes(\n      x = FPR, \n      y = TPR,\n      u = Umbral\n    )\n  ) +\n  geom_line(\n    color = \"blue\", \n    size = 1\n  ) +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"red\") +\n  labs(title = paste(\"Curva ROC (AUC =\", round(auc, 3), \")\"),\n       x = \"Tasa de falsos positivos (FPR)\",\n       y = \"Tasa de verdaderos positivos (TPR)\") +\n  theme_minimal()\n\n# Gráfico plotly\nggplotly(grafico_ggplot2) |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\nEl valor de AUC es 0.953, lo que indica un excelente rendimiento del modelo. La curva ROC se eleva rápidamente cerca del eje y, lo que indica que el modelo tiene una alta tasa de verdaderos positivos incluso con bajos niveles de falsos positivos. Este comportamiento es característico de un buen modelo de clasificación.\n\n\n11.5.2.3 Mapas\nSeguidamente se presenta el mapa de idoneidad del hábitat.\n\n\nCódigo\n# Paleta de colores del modelo\ncolores_modelo &lt;- colorNumeric(\n  palette = c(\"white\", \"black\"),\n  values(prediccion),\n  na.color = \"transparent\"\n)\n\n# Mapa\nleaflet() |&gt;\n  addTiles(group = \"Mapa general\") |&gt;\n  addProviderTiles(\n    providers$Esri.WorldImagery, \n    group = \"Imágenes satelitales\"\n  ) |&gt;  \n  addProviderTiles(\n    providers$CartoDB.Positron, \n    group = \"Mapa blanco\"\n  ) |&gt;\n  addRasterImage( # capa raster de temperatura\n    clima$wc2.1_10m_bio_1,\n    colors = colores_temperatura, # paleta de colores\n    opacity = 0.6,\n    group = \"Temperatura\",\n  ) |&gt;\n  addRasterImage( # capa raster de precipitación\n    clima$wc2.1_10m_bio_12,\n    colors = colores_precipitacion, # paleta de colores\n    opacity = 0.6,\n    group = \"Precipitación\",\n  ) |&gt;\n  addRasterImage( # capa raster del modelo de distribución\n    prediccion,\n    colors = colores_modelo,\n    opacity = 0.6,\n    group = \"Modelo de distribución\",\n  ) |&gt;  \n  addCircleMarkers(\n    # capa de registros de presencia (puntos)\n    data = presencia,\n    stroke = F,\n    radius = 3,\n    fillColor = 'red',\n    fillOpacity = 1,\n    popup = paste(\n      paste0(\"&lt;strong&gt;País: &lt;/strong&gt;\", presencia$country),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", presencia$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", presencia$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", presencia$institutionCode),\n      paste0(\"&lt;a href='\", presencia$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Registros de Bradypus variegatus\"\n  ) |&gt;  \n  addLegend(\n    title = \"Temperatura\",\n    values = values(clima$wc2.1_10m_bio_1),\n    pal = colores_temperatura,\n    position = \"bottomleft\",\n    group = \"Temperatura\"\n  ) |&gt;\n  addLegend(\n    title = \"Precipitación\",\n    values = values(clima$wc2.1_10m_bio_12),\n    pal = colores_precipitacion,\n    position = \"bottomleft\",\n    group = \"Precipitación\"\n  ) |&gt;\n  addLegend(\n    title = \"Modelo de distribución\",\n    values = values(prediccion),\n    pal = colores_modelo,\n    position = \"bottomright\",\n    group = \"Modelo de distribución\"\n  ) |&gt;  \n  addLayersControl(\n    # control de capas\n    baseGroups = c(\"Mapa general\", \"Imágenes satelitales\", \"Mapa blanco\"),\n    overlayGroups = c(\n      \"Temperatura\",\n      \"Precipitación\",\n      \"Modelo de distribución\",\n      \"Registros de Bradypus variegatus\"\n    )\n  ) |&gt;\n  hideGroup(\"Temperatura\") |&gt;\n  hideGroup(\"Precipitación\")\n\n\n\n\n\n\nEl siguiente mapa muestra las áreas en las que se predice presencia y ausencia de acuerdo con un umbral.\n\n\nCódigo\n# Definir el umbral\numbral &lt;- 0.5\n\n# Crear el raster binario\nprediccion_binaria &lt;- (prediccion &gt;= umbral) * 1\n\n# Crear la paleta de colores para el raster binario\ncolores_prediccion_binaria &lt;- colorFactor(\n  palette = c(\"transparent\", \"blue\"),  # \"transparent\" para las áreas no adecuadas\n  domain = c(0, 1),\n  na.color = \"transparent\"\n)\n\n# Mapa\nleaflet() |&gt;\n  addTiles(group = \"Mapa general\") |&gt;\n  addProviderTiles(\n    providers$Esri.WorldImagery, \n    group = \"Imágenes satelitales\"\n  ) |&gt;\n  addProviderTiles(\n    providers$CartoDB.Positron, \n    group = \"Mapa blanco\"\n  ) |&gt;\n  addRasterImage(\n    prediccion_binaria,\n    colors = colores_prediccion_binaria,\n    opacity = 0.6,\n    group = \"Modelo de distribución binario\",\n  ) |&gt;\n  addCircleMarkers(\n    data = presencia,\n    stroke = FALSE,\n    radius = 3,\n    fillColor = 'red',\n    fillOpacity = 1,\n    popup = paste(\n      paste0(\"&lt;strong&gt;País: &lt;/strong&gt;\", presencia$country),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", presencia$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", presencia$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", presencia$institutionCode),\n      paste0(\"&lt;a href='\", presencia$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Registros de Bradypus variegatus\"\n  ) |&gt;\n  addLegend(\n    title = \"Modelo de distribución binario\",\n    labels = c(\"Ausencia\", \"Presencia\"),\n    colors = c(\"transparent\", \"blue\"),\n    position = \"bottomright\",\n    group = \"Modelo de distribución binario\"\n  ) |&gt;\n  addLayersControl(\n    baseGroups = c(\"Mapa general\", \"Imágenes satelitales\", \"Mapa blanco\"),\n    overlayGroups = c(\n      \"Modelo de distribución binario\",\n      \"Registros de Bradypus variegatus\"\n    )\n  )",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelos de nichos ecológicos</span>"
    ]
  },
  {
    "objectID": "11-modelos-nichos-ecologicos.html#recursos-de-interés",
    "href": "11-modelos-nichos-ecologicos.html#recursos-de-interés",
    "title": "11  Modelos de nichos ecológicos",
    "section": "11.6 Recursos de interés",
    "text": "11.6 Recursos de interés\nPhillips, S. J., Anderson, R. P., & Schapire, R. E. (2006). Maximum entropy modeling of species geographic distributions. Ecological Modelling, 190(3-4), 231-259. https://doi.org/10.1016/j.ecolmodel.2005.03.026",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelos de nichos ecológicos</span>"
    ]
  },
  {
    "objectID": "11-modelos-nichos-ecologicos.html#obtención-de-variables-ambientales",
    "href": "11-modelos-nichos-ecologicos.html#obtención-de-variables-ambientales",
    "title": "11  Modelos de nichos ecológicos",
    "section": "11.4 Obtención de variables ambientales",
    "text": "11.4 Obtención de variables ambientales\nFrecuentemente se utilizan datos bioclimáticos (ej. temperatura, precipitación) como variables ambientales. Pueden obtenerse mediante el paquete geodata. En este caso, se descargan las variables bioclimáticas de WorldClim.\n\n# Consulta a WorldClim\nclima &lt;- worldclim_global(var = 'bio', res = 10, path = tempdir())\n\n# Nombres de las variables climáticas\nnames(clima)\n\n [1] \"wc2.1_10m_bio_1\"  \"wc2.1_10m_bio_2\"  \"wc2.1_10m_bio_3\"  \"wc2.1_10m_bio_4\" \n [5] \"wc2.1_10m_bio_5\"  \"wc2.1_10m_bio_6\"  \"wc2.1_10m_bio_7\"  \"wc2.1_10m_bio_8\" \n [9] \"wc2.1_10m_bio_9\"  \"wc2.1_10m_bio_10\" \"wc2.1_10m_bio_11\" \"wc2.1_10m_bio_12\"\n[13] \"wc2.1_10m_bio_13\" \"wc2.1_10m_bio_14\" \"wc2.1_10m_bio_15\" \"wc2.1_10m_bio_16\"\n[17] \"wc2.1_10m_bio_17\" \"wc2.1_10m_bio_18\" \"wc2.1_10m_bio_19\"\n\n\nSeguidamente, se “recortan” las capas raster climáticas provenientes de WorldClim para así cubrir solamente el área en la que se encuentra presente la especie.\n\n# Definir la extensión del área de estudio\narea_estudio &lt;- ext(\n  min(presencia$decimalLongitude) - 5, \n  max(presencia$decimalLongitude) + 5,\n  min(presencia$decimalLatitude) - 5, \n  max(presencia$decimalLatitude) + 5\n)\n\n# Recortar las variables bioclimáticas al área de estudio\nclima &lt;- crop(clima, area_estudio)\n\n\n11.4.1 Mapa\n\n\nCódigo\n# Paleta de colores de temperatura\ncolores_temperatura &lt;- colorNumeric(\n  # palette = \"inferno\",\n  # palette = \"magma\",\n  palette = rev(brewer.pal(11, \"RdYlBu\")),\n  values(clima$wc2.1_10m_bio_1),\n  na.color = \"transparent\"\n)\n\n# Paleta de colores de precipitación\ncolores_precipitacion &lt;- colorNumeric(\n  # palette = \"viridis\",\n  # palette = \"YlGnBu\",  \n  palette = \"Blues\",\n  values(clima$wc2.1_10m_bio_12),\n  na.color = \"transparent\"\n)\n\n# Mapa\nleaflet() |&gt;\n  addTiles(group = \"Mapa general\") |&gt;\n  addProviderTiles(\n    providers$Esri.WorldImagery, \n    group = \"Imágenes satelitales\"\n  ) |&gt;  \n  addProviderTiles(\n    providers$CartoDB.Positron, \n    group = \"Mapa blanco\"\n  ) |&gt;\n  addRasterImage( # capa raster de temperatura\n    clima$wc2.1_10m_bio_1,\n    colors = colores_temperatura, # paleta de colores\n    opacity = 0.6,\n    group = \"Temperatura\",\n  ) |&gt;\n  addRasterImage( # capa raster de precipitación\n    clima$wc2.1_10m_bio_12,\n    colors = colores_precipitacion, # paleta de colores\n    opacity = 0.6,\n    group = \"Precipitación\",\n  ) |&gt;\n  addCircleMarkers(\n    # capa de registros de presencia (puntos)\n    data = presencia,\n    stroke = F,\n    radius = 3,\n    fillColor = 'red',\n    fillOpacity = 1,\n    popup = paste(\n      paste0(\"&lt;strong&gt;País: &lt;/strong&gt;\", presencia$country),\n      paste0(\"&lt;strong&gt;Localidad: &lt;/strong&gt;\", presencia$locality),\n      paste0(\"&lt;strong&gt;Fecha: &lt;/strong&gt;\", presencia$eventDate),\n      paste0(\"&lt;strong&gt;Fuente: &lt;/strong&gt;\", presencia$institutionCode),\n      paste0(\"&lt;a href='\", presencia$occurrenceID, \"'&gt;Más información&lt;/a&gt;\"),\n      sep = '&lt;br/&gt;'\n    ),\n    group = \"Registros de Bradypus variegatus\"\n  ) |&gt;  \n  addLegend(\n    title = \"Temperatura\",\n    values = values(clima$wc2.1_10m_bio_1),\n    pal = colores_temperatura,\n    position = \"bottomleft\",\n    group = \"Temperatura\"\n  ) |&gt;\n  addLegend(\n    title = \"Precipitación\",\n    values = values(clima$wc2.1_10m_bio_12),\n    pal = colores_precipitacion,\n    position = \"bottomleft\",\n    group = \"Precipitación\"\n  ) |&gt;  \n  addLayersControl(\n    # control de capas\n    baseGroups = c(\"Mapa general\", \"Imágenes satelitales\", \"Mapa blanco\"),\n    overlayGroups = c(\"Temperatura\", \"Precipitación\", \"Registros de Bradypus variegatus\")\n  ) |&gt;\n  hideGroup(\"Precipitación\")",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Modelos de nichos ecológicos</span>"
    ]
  },
  {
    "objectID": "04-markdown.html",
    "href": "04-markdown.html",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#trabajo-previo",
    "href": "04-markdown.html#trabajo-previo",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Lecturas\nQuarto - Markdown Basics. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/authoring/markdown-basics.html\n\n\nTutoriales\nMarkdown Tutorial. (s.f.). Recuperado el 1 de marzo de 2024, de https://www.markdowntutorial.com/",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#introducción",
    "href": "04-markdown.html#introducción",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "Introducción",
    "text": "Introducción\nMarkdown es un lenguaje de marcado, creado en 2004 por John Gruber y Aaron Swartz. Las “marcas” se utilizan para especificar aspectos de la estructura (ej. títulos, encabezados), estilo (ej. negritas, itálicas) y semántica de un documento. Markdown se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcado (ej. Lenguaje de Marcado de Hipertexto o HTML), por lo que se considera un lenguaje de marcado ligero.\nLos documentos escritos en Markdown pueden exportarse a una gran variedad de formatos (ej. HTML, DOC, PDF, LaTex) para ser usados en libros, presentaciones o páginas web, entre otros fines.\nLas variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:\n\nR Markdown: para el lenguaje R.\nQuarto: es la “siguiente generación” de R Markdown, con soporte para más lenguajes de programación (Python, Julia, Observable, R) y motores de procesamiento (Jupyter, Knitr), entre otras mejoras. Más que una variación de Markdown es un sistema de publicación de documentos técnicos y científicos que utiliza Markdown.\nPython Markdown: para el lenguaje Python.\nGitHub Flavored Markdown: para la plataforma GitHub.\nPandoc’s Markdown: para el programa Pandoc de conversión entre formatos.\n\nPuede encontrarse una lista más extensa de variaciones de Markdown en Markdown Flavors.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#ejemplo-de-documento",
    "href": "04-markdown.html#ejemplo-de-documento",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.1 Ejemplo de documento",
    "text": "4.1 Ejemplo de documento\nEl siguiente es un ejemplo de documento Markdown. Se muestra primero la sintaxis del documento y luego la manera en la que se visualiza.\n\n4.1.1 Sintaxis\nLa sintaxis del documento incluye marcas para un encabezado, texto en negrita, texto en itálica, hipervínculos y una imagen.\n\n\n### Los satélites galileanos\n\nSe llaman **satélites galileanos** los cuatro satélites de\n[Júpiter](https://es.wikipedia.org/wiki/J%C3%BApiter_(planeta))\ndescubiertos en 1610 por el astrónomo italiano\n[Galileo Galilei](https://es.wikipedia.org/wiki/Galileo_Galilei) (1564 - 1642): \n*Ío*, *Europa*, *Ganimedes* y *Calisto*. \nSon los más grandes de los satélites de Júpiter, \nsiendo visibles incluso con telescopios de baja potencia.\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n**Figura 1**. Los cuatro satélites galileanos, \nen una composición que compara sus tamaños con el tamaño de Júpiter. \nEn orden descendente, son *Ío*, *Europa*, *Ganimedes* y *Calisto*.\n\n\n\n\n4.1.2 Visualización\n\n\n\nLos satélites galileanos\nSe llaman satélites galileanos los cuatro satélites de Júpiter descubiertos en 1610 por el astrónomo italiano Galileo Galilei (1564 - 1642): Ío, Europa, Ganimedes y Calisto. Son los más grandes de los satélites de Júpiter, siendo visibles incluso con telescopios de baja potencia.\n\nFigura 1. Los cuatro satélites galileanos, en una composición que compara sus tamaños con el tamaño de Júpiter. En orden descendente, son Ío, Europa, Ganimedes y Calisto.\n\nEl contenido de este ejemplo está basado en Satélite galileano - Wikipedia, la enciclopedia libre.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#sintaxis-1",
    "href": "04-markdown.html#sintaxis-1",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.2 Sintaxis",
    "text": "4.2 Sintaxis\nEn esta sección, se muestran los principales elementos de sintaxis de Markdown y sus salidas.\n\n\n4.2.1 Encabezados\nHay seis niveles de encabezados en Markdown, siendo el nivel 1 el de letras más grandes y el 6 el de letras más pequeñas. Se especifican mediante símbolos de numeral (#) antes del texto del encabezado (note el espacio entre el último signo de numeral y el inicio del texto).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n# Encabezado de nivel 1\n\n\n\nEncabezado de nivel 1\n\n\n\n\n\n## Encabezado de nivel 2\n\n\n\nEncabezado de nivel 2\n\n\n\n\n\n### Encabezado de nivel 3\n\n\n\nEncabezado de nivel 3\n\n\n\n\n\n#### Encabezado de nivel 4\n\n\n\nEncabezado de nivel 4\n\n\n\n\n\n##### Encabezado de nivel 5\n\n\n\nEncabezado de nivel 5\n\n\n\n\n\n###### Encabezado de nivel 6\n\n\n\nEncabezado de nivel 6\n\n\n\n\nPara los encabezados de nivel 1 y nivel 2, existe una sintaxis alterna, con símbolos de igual (=====) o guiones (-----) bajo el texto del encabezado.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nOtro encabezado de nivel 1 ==========================\n\n\n\n\nOtro encabezado de nivel 1\n\n\n\n\n\nOtro encabezado de nivel 2 --------------------------\n\n\n\nOtro encabezado de nivel 2\n\n\n\n\n\n\n4.2.2 Párrafos\nLos párrafos deben separarse mediante (al menos) una línea en blanco.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\n\n\n\n4.2.3 Cambios de línea\nSi se requiere un cambio de línea sin una línea en blanco entre párrafos, pueden agregarse dos espacios en blanco al final de la línea () o también un espacio y una barra invertida (\\).\n\n\n4.2.4 Texto en negrita\nHay dos sintaxis para especificar texto en negrita: con dos asteriscos (**) o con dos guiones bajos (__), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n**Texto en negrita**\n\n\nTexto en negrita\n\n\n\n\n__Otro texto en negrita__\n\n\nOtro texto en negrita\n\n\n\n\n\n4.2.5 Texto en itálica\nHay dos sintaxis para especificar texto en itálica: con un asterisco (*) o con un guión bajo (_), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n*Texto en itálica*\n\n\nTexto en itálica\n\n\n\n\n_Otro texto en itálica_\n\n\nOtro texto en itálica\n\n\n\n\n\n4.2.6 Texto tachado\nEl texto tachado se especifica con dos guiones (--) antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n--Texto tachado--\n\n\nTexto tachado\n\n\n\n\n\n4.2.7 Superíndices y subíndices\nUn superíndice se especifica con un acento circunflejo (^) antes y después del texto que se desea mostrar como superíndice. Un subíndice se especifica con un guión (-) antes y después del texto que se desea mostrar como subíndice.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nsuperíndice^2^\n\n\nsuperíndice2\n\n\n\n\nsubíndice-2-\n\n\nsubíndice2\n\n\n\n\n\n4.2.8 Líneas horizontales\nTres o más asteriscos (***) generan una línea horizontal:\n***\n\nTambién puede generarse con tres o más guiones (---):\n---\n\n\n\n4.2.9 Citas textuales\nSe especifican con un símbolo de “mayor que” (&gt;) antes de cada línea.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n&gt; *And on the pedestal these words appear:*\n&gt; *\"My name is Ozymandias, king of kings:*\n&gt; *Look on my works, ye Mighty, and despair!\"*\nPercy Bysshe Shelley, \"Ozymandias\" (1818)\n\n\n\n And on the pedestal these words appear: “My name is Ozymandias, king of kings: Look on my works, ye Mighty, and despair!” \n\nPercy Bysshe Shelley, “Ozymandias” (1818)\n\n\n\n\n\n4.2.10 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento al que conduce el enlace.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n[Proyecto Gutenberg](https://www.gutenberg.org/)\n\n\nProyecto Gutenberg\n\n\n\n\n\n4.2.11 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota. Una imagen local se encuentra en la misma computadora en la que está el documento que la referencia, mientras que una imagen remota se encuentra en otra computadora a la que se accede mediante un protocolo de redes como el Protocolo de transferencia de hipertexto (HTTP).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n![Imagen local](img/Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n![Imagen remota](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\nMarkdown no cuenta con sintaxis para especificar el tamaño de una imagen, pero esto puede lograrse con el Lenguaje de marcado de hipertexto (HTML, HyperText Markup Language), su elemento img y sus atributos height y width, los cuales especifican la altura y el ancho de una imagen (las unidades por defecto son pixeles).\nPor ejemplo, la expresión HTML:\n&lt;img src=\"img/Jupiter_and_the_Galilean_Satellites.jpg\" height=\"100\" alt=\"Imagen local\"&gt;\ngenera como salida una imagen de 100 pixeles de altura:\n\nSi se usa solo el atributo height, width se ajusta automáticamente y viceversa.\n\n\n4.2.12 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento.\n2. Segundo elemento.\n3. Tercer elemento.\n\n\n\n\nPrimer elemento.\nSegundo elemento.\nTercer elemento.\n\n\n\n\nLas listas numeradas pueden anidarse para mostrar la información de una forma jerárquica. Para crear un nivel de anidación, deben usarse sangrías con una cantidad de espacios consistente en toda la lista. La numeración se ordena automáticamente (incluso si hay errores).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento\n            1. Elemento anidado\n            2. Elemento anidado\n2. Segundo elemento\n            1. Elemento anidado\n            2. Elemento anidado\n3. Tercer elemento\n            1. Elemento anidado\n            2. Elemento anidado\n\n\n\n\nPrimer elemento\n\nElemento anidado\nElemento anidado\n\nSegundo elemento\n\nElemento anidado\nElemento anidado\n\nTercer elemento\n\nElemento anidado\nElemento anidado\n\n\n\n\n\n\n\n4.2.13 Listas no numeradas\nSe definen con guiones (-), asteriscos (*) o signos de adición (+) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento\n- Otro elemento\n- Otro elemento más\n\n\n\n\nUn elemento\n\nOtro elemento\n\nOtro elemento más\n\n\n\n\n\nLas listas no numeradas también pueden anidarse. Debe utilizarse un mínimo de dos espacios en los elementos anidados.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento\n            + Elemento anidado\n            + Elemento anidado\n- Otro elemento\n            + Elemento anidado\n            + Elemento anidado\n- Otro elemento más\n            + Elemento anidado\n            + Elemento anidado\n\n\n\n\nUn elemento\n\nElemento anidado\nElemento anidado\n\nOtro elemento\n\nElemento anidado\nElemento anidado\n\nOtro elemento más\n\nElemento anidado\nElemento anidado\n\n\n\n\n\nLas listas numeradas y las no numeradas pueden intercalarse.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento\n            - Elemento anidado\n            - Elemento anidado\n2. Segundo elemento\n            - Elemento anidado\n            - Elemento anidado\n3. Tercer elemento\n            - Elemento anidado\n            - Elemento anidado\n\n\n\n\nPrimer elemento\n\nElemento anidado\nElemento anidado\n\nSegundo elemento\n\nElemento anidado\nElemento anidado\n\nTercer elemento\n\nElemento anidado\nElemento anidado\n\n\n\n\n\n\n\n4.2.14 Notación matemática\nLas expresiones en notación matemática (ej. ecuaciones) se escriben con base en la sintaxis de LaTeX. Se delimitan (al inicio y al final) con:\n\nUn símbolo de dólar ($), para ecuaciones dentro de un renglón (inline math).\nDos símbolos de dólar ($$), para ecuaciones en su propio bloque (display math).\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEquivalencia entre masa y energía: $E = mc^{2}$\n\n\n\nEquivalencia entre masa y energía: \\(E = mc^{2}\\)\n\n\n\n\nEquivalencia entre masa y energía: $$E = mc^{2}$$\n\n\nEquivalencia entre masa y energía:\n\\[E = mc^{2}\\]\n\n\n\nPara más detalles sobre la sintaxis de las expresiones matemáticas, se recomienda consultar:\n\nWriting mathematical expressions - GitHub Docs\nLaTeX/Mathematics\n\n\n\n4.2.15 Bloques de código fuente\nLos documentos Markdown pueden contener bloques de código fuente, ya sea incrustados en una línea de texto (inline) o en líneas separadas.\n\n4.2.15.1 Bloques en línea\nPara mostrar fragmentos cortos de código en una sola línea dentro del texto, se usa una sola comilla invertida o backtick para delimitar el código.\nPor ejemplo, la sintaxis:\nEste es un fragmento de código en línea: `x = 10`\ngenera:\nEste es un fragmento de código en línea: x = 10\n\n\n4.2.15.2 Bloques multilínea\nPara fragmentos de código de múltiples líneas, se utilizan tres comillas invertidas o una sangría de cuatro espacios al inicio de cada línea.\nEl siguiente es un ejemplo de bloque de código delimitado con comillas invertidas (la forma más usada):\n\n```\nfunction sumar(a, b) {\n  return a + b;\n}\n```\n\nSe visualiza como:\nfunction sumar(a, b) {\n  return a + b;\n}\nSi el código es de un lenguaje específico, puede indicarse para resaltar (y colorear) la sintaxis. Por ejemplo, para un bloque de código en R, se escribe r después de las tres comillas invertidas.\nSintaxis de código en R:\n\n```r\n# Gráfico de dispersón del conjunto de datos cars con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n```\n\nVisualización de código en R:\n# Gráfico de dispersón del conjunto de datos cars con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\nEl uso de resaltado de sintaxis con bloques de código lo hace más fácil de leer y comprender. El resultado (colores, fuentes de texto, etc.) de sintaxis depende de la plataforma o editor de Markdown que se utilice. Plataformas como GitHub y algunos editores soportan muchos lenguajes, mientras que otros pueden no reconocer todos.\nPara más información sobre el uso de bloques de código en documentos Markdown, se recomienda consultar:\n\nCreating and highlighting code blocks\nThe languages YAML file\nMarkdown Code Block: Including Code In .md Files - Markdown Land\n\nNótese que los bloques de código en un documento Markdown normal (con extensión .md) no se ejecutan, solo se muestran. Sin embargo, hay sistemas como Quarto y Jupyter Notebooks que permiten combinar narrativa em Markdown con bloques de código ejecutables.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#ejercicios",
    "href": "04-markdown.html#ejercicios",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.3 Ejercicios",
    "text": "4.3 Ejercicios\n\nEn RStudio, cree un nuevo proyecto con la opción File - New Project - New Directory - New Project de RStudio.\nEn el nuevo proyecto, cree un nuevo documento Markdown con la opción File - New File - Markdown File de RStudio. y escriba en este un breve curriculum académico o profesional.\n\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.\nPuede usar información ficticia (no incluya datos confidenciales o sensibles).\nEspecifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y no utilice imágenes para las que no tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).\nAsegúrese de utilizar los siguientes elementos de sintaxis Markdown:\n\nEncabezados de varios niveles.\nNegritas e itálicas.\nListas.\nEnlaces a sitios web.\nImágenes (al menos una local y una remota).\n\n\nGuarde el documento con el nombre README.md (RStudio asigna la extensión automáticamente).\nCree una cuenta gratuita en la plataforma de desarrollo colaborativo de software GitHub.\nCree un repositorio vacío en su cuenta en GitHub (ej. curriculum-vitae).\nSuba al nuevo repositorio el archivo README.md.\nGenere un sitio web en el servicio de alojamiento GitHub Pages con la opción Settings - Pages - Branch - main - Save de GitHub.\nRepita los pasos 6 y 7 para cada modificación que realice en el documento Markdown.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#recursos-de-interés",
    "href": "04-markdown.html#recursos-de-interés",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.4 Recursos de interés",
    "text": "4.4 Recursos de interés\nDaring Fireball: Markdown. (s. f.). Recuperado 25 de marzo de 2023, de https://daringfireball.net/projects/markdown/\nLaTeX/Mathematics—Wikibooks, open books for an open world. (s. f.). Recuperado 25 de marzo de 2023, de https://en.wikibooks.org/wiki/LaTeX/Mathematics\nMarkdown Guide. (s. f.). Recuperado 10 de abril de 2022, de https://www.markdownguide.org/\nWriting mathematical expressions. (s. f.). GitHub Docs. Recuperado 25 de marzo de 2023, de https://ghdocs-prod.azurewebsites.net/en/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "05-git.html",
    "href": "05-git.html",
    "title": "5  Git - sistema de control de versiones",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#trabajo-previo",
    "href": "05-git.html#trabajo-previo",
    "title": "5  Git - sistema de control de versiones",
    "section": "",
    "text": "Instalación de software\nInstale en su computadora: Git\n\n\nTutoriales\nAbba, Ihechikara Vincent (2021). Git and GitHub Tutorial – Version Control for Beginners. freeCodeCamp.Org. https://www.freecodecamp.org/news/git-and-github-for-beginners/",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#introducción",
    "href": "05-git.html#introducción",
    "title": "5  Git - sistema de control de versiones",
    "section": "Introducción",
    "text": "Introducción\nGit es un sistema de control de versiones diseñado para “rastrear” cambios en el código fuente durante el proceso de desarrollo de software. Sin embargo, puede ser utilizado para llevar el control de los cambios en cualquier conjunto de archivos (ej. documentación, música).\nUn sistema de control de versiones proporciona, entre otras ventajas:\n\nLa capacidad de recuperar versiones anteriores de los archivos.\nLa capacidad de integrar modificaciones efectuadas por varias personas en el mismo conjunto de archivos.\nLa capacidad de mantener varias “ramas” (branches) de un producto (ej. “estable”, “evaluación”, “inestable”, como en el caso de Debian Linux, GRASS GIS y muchos otros proyectos de software libre).\nFacilidades para mantener redundancia y respaldos de los archivos (ej. Programa de respaldos de GitHub). Esta es una facilidad que implementan algunos servicios en la nube.\n\nGit fue diseñado por Linus Torvalds en 2005 durante del desarrollo del kernel del sistema operativo Linux. Se caracteriza por ser un sistema de control de versiones distribuido, lo que significa que el código fuente puede estar alojado en la estación de trabajo de cualquier miembro del equipo de desarrollo. No requiere un repositorio “central”, pero también puede trabajar de esa forma.\nEl protocolo de Git es utilizado en varios sitios que proveen servicios de alojamiento de software, entre los que están SourceForge, Bitbucket, GitLab y GitHub.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#funcionamiento-de-git",
    "href": "05-git.html#funcionamiento-de-git",
    "title": "5  Git - sistema de control de versiones",
    "section": "5.1 Funcionamiento de Git",
    "text": "5.1 Funcionamiento de Git\nDesde el punto de vista de un usuario de Git (ej. un programador), Git se utiliza para sincronizar la versión local (i.e. en una computadora personal) de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente a través de dos operaciones:\n\npush: para “subir” al repositorio remoto los cambios realizados en el repositorio local. Esta operación se realiza mediante el comando git push. Es probable que el sistema remoto le solicite al usuario algún tipo de autenticación (ej. nombre de usuario y clave).\npull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto. Esta operación se realiza mediante el comando git pull.\n\nLas operaciones push y pull se ilustran en la Figura 5.1.\n\n\n\n\n\n\nFigura 5.1: Operaciones push y pull. Imagen de Melinda Higgins.\n\n\n\nAntes de un push, el usuario debe seleccionar los archivos que desea subir mediante el comando git add, el cual pasa los archivos a un “área de espera” (staging area). Luego debe usarse el comando git commit para “guardar” los cambios pendientes en el área de espera. Cada commit guarda el estado del conjunto de archivos en un momento específico (snapshot).\nLa relación entre estas operaciones de Git, se ilustra en la Figura 5.2.\n\n\n\n\n\n\nFigura 5.2: Operaciones de Git. Imagen de Steven Klavins.\n\n\n\nEn la Figura 5.3, se muestra el funcionamiento de Git mediante una comparación con el procesamiento de una compra en línea.\n\n\n\n\n\n\nFigura 5.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.\n\n\n\nOtras operaciones de Git de uso frecuente son:\n\ngit config: para especificar opciones globales de la sesión de Git (ej. nombre del usuario, dirección de correo electrónico).\ngit init: para inicializar un repositorio git.\ngit clone: para clonar (i.e. copiar) un repositorio remoto en la computadora local.\ngit status: para revisar el estado de los archivos y, por ejemplo, saber cuales deben pasarse al área de espera.\ngit log: para revisar el historial de commits.\ngit show: para visualizar los cambios efectuados en los commits.\ngit reset: para regresar al estado correspondiente a un commit anterior.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#recursos-de-interés",
    "href": "05-git.html#recursos-de-interés",
    "title": "5  Git - sistema de control de versiones",
    "section": "5.2 Recursos de interés",
    "text": "5.2 Recursos de interés\nGit. (s. f.). Recuperado 28 de agosto de 2022, de https://git-scm.com/\nGitHub Archive Program. (s. f.). GitHub Archive Program. Recuperado 10 de abril de 2022, de https://archiveprogram.github.com/\nHiggins, M. (s. f.). Reproducible Templates for Analysis and Dissemination. Coursera. Recuperado 11 de abril de 2022, de https://www.coursera.org/learn/reproducible-templates-analysis\nKlavins, S. (2020). Version Control part 1. Medium. https://stevenklavins94.medium.com/version-control-part-1-c5f1b43127f6",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html",
    "href": "09-ggplot2-plotly.html",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#trabajo-previo",
    "href": "09-ggplot2-plotly.html#trabajo-previo",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "",
    "text": "Lecturas\nChang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. O’Reilly. https://r-graphics.org/\nWickham, H., & Grolemund, G. (2017). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (capítulo 3). O’Reilly Media. https://r4ds.had.co.nz/\nWickham, H., & Grolemund, G. (s. f.). R para Ciencia de Datos (1era ed.) (capítulo 3). https://es.r4ds.hadley.nz/\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (s. f.). R for Data Science (2nd ed.) (capítulo 2). https://r4ds.hadley.nz/\nWickham, H., Navarro, D., & Pedersen, T. L. (s.f.). ggplot2: Elegant graphics for data analysis. https://ggplot2-book.org/",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#introducción",
    "href": "09-ggplot2-plotly.html#introducción",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "Introducción",
    "text": "Introducción\nR proporciona una gran cantidad de funciones para la elaboración de gráficos estadísticos y otros tipos de visualizaciones. El paquete base de R, por ejemplo, contiene un conjunto básico de funciones muy versátiles, especialmente para gráficos simples de conjuntos de datos relativamente pequeños. Sin embargo, para visualizaciones más avanzadas, puede ser conveniente explorar otras bibliotecas.\nggplot2 es una de las bibliotecas más populares de graficación de R. Implementa el concepto de “gramática de gráficos”, que permite crear visualizaciones complejas a partir de capas y componentes simples. Forma parte de Tidyverse, por lo que se comunica muy bien con los demás paquetes de esta familia, enfocada en conjuntos de datos grandes y en ciencia de datos.\nplotly es una biblioteca para crear gráficos interactivos y dinámicos. Contiene capacidades para agregar controles y mecanismos que le permiten al usuario interactuar con los gráficos y realizar operaciones como filtrados, acercamientos y alejamientos, entre otras.\nEl paquete DT, por su parte, permite presentar conjuntos de datos en tablas interactivas en las que se pueden realizar operaciones como ordenamientos, consultas y filtrados.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#instalación-y-carga",
    "href": "09-ggplot2-plotly.html#instalación-y-carga",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.1 Instalación y carga",
    "text": "9.1 Instalación y carga\nLos paquetes necesarios pueden instalarse con la función install.packages(). Ya que se usaron en capítulos anteriores, en este punto se asumen instalados los paquetes de Tidyverse.\n\n# Instalación de plotly\ninstall.packages(\"plotly\")\n\n# Instalación de DT\ninstall.packages(\"DT\")\n\nUna vez instalados, los paquetes pueden cargarse con la función library():\n\n# Carga conjunta de Tidyverse \n# (incluye ggplot2, dplyr, readr y otros)\nlibrary(tidyverse)\n\n# Carga de plotly\nlibrary(plotly)\n\n# Carga de DT\nlibrary(DT)\n\n# Carga de scales (para formatear ejes y leyendas en los gráficos)\nlibrary(scales)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#conjuntos-de-datos-de-ejemplo",
    "href": "09-ggplot2-plotly.html#conjuntos-de-datos-de-ejemplo",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.2 Conjuntos de datos de ejemplo",
    "text": "9.2 Conjuntos de datos de ejemplo\n\n9.2.1 Países\nSe carga un archivo CSV con los datos de países de Natural Earth unidos con los del indicador de esperanza de vida al nacer en 2022 del Banco Mundial (columna LIFE_EXPECTANCY). También incluye la columna correspondiente al producto interno bruto per cápita (columna GDP_PC).\n\n# Carga de los datos de países\npaises &lt;-\n  read_csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2024-ii/refs/heads/main/datos/natural-earth/paises-join-esperanzavida.csv\"\n  )\n\nEn el siguiente bloque de código, se utiliza la función datatable() del paquete DT, para desplegar las observaciones de países en una tabla.\n\n# Tabla de datos de paises\npaises |&gt;\n  datatable(\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )\n\n\n\n\n\nDT es un “envoltorio” (wrapper) de la biblioteca DataTables de JavaScript, un lenguaje ampliamente utilizado en el desarrollo de páginas web interactivas.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#paquetes-de-graficación",
    "href": "09-ggplot2-plotly.html#paquetes-de-graficación",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.3 Paquetes de graficación",
    "text": "9.3 Paquetes de graficación\nSe introducen los paquetes de graficación estadística ggplot2 y plotly. Se utiliza ggplot2 para elaborar los gráficos y plotly para hacerlos interactivos.\n\n9.3.1 ggplot2\nggplot2 es un sistema para la creación declarativa de gráficos, creado por Hadley Wickham en 2005. Está basado en el libro The Grammar of Graphics, de Leland Wilkinson, un esquema general para visualización de datos que descompone un gráfico en sus principales componentes semánticos, tales como capas y geometrías.\n\n9.3.1.1 Principales componentes de un gráfico\nDe acuerdo con The Grammar of Graphics, los tres principales componentes de un gráfico son:\n\nDatos (observaciones y variables).\nConjunto de mapeos de las variables del conjunto de datos a propiedades visuales (aesthetics) del gráfico, tales como posición en el eje x, posición en el eje y, color, tamaño y forma, entre otras.\nAl menos una capa, la cual describe como graficar cada observación. Por lo general, las capas se crean con funciones de geometrías (ej. puntos, líneas, barras).\n\n\n\n9.3.1.2 Opciones básicas\nggplot2 implementa un gráfico estadístico por medio de la función ggplot(), cuya sintaxis básica puede resumirse de la siguiente forma:\nggplot(data = &lt;DATOS&gt;) + \n    &lt;FUNCION_GEOMETRIA&gt;(mapping = aes(&lt;MAPEOS&gt;))\nEl llamado a ggplot() crea un sistema de coordenadas (i.e. un “canvas”), al cual se le agregan capas. Su primer argumento es &lt;DATOS&gt;, el cual es usualmente un dataframe o un tibble.\nLa función aes() realiza los mapeos (&lt;MAPEOS&gt;) de las variables del conjunto de datos a las propiedades visuales del gráfico. Las capas se crean con funciones de geometrías (&lt;FUNCION_GEOMETRIA&gt;) como geom_point(), geom_bar() o geom_histogram(), entre muchas otras. Note el uso del operador + para agregar las capas al gráfico.\nComo ejemplo, seguidamente se crea un gráfico de dispersión que muestra la variable producto interno bruto (PIB) per cápita (GDP_PC) en el eje X, y la variable esperanza de vida al nacer (LIFE_EXPECTANCY) en el eje Y.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\nggplot(data = paises) + \n  geom_point(mapping = aes(x = GDP_PC, y = LIFE_EXPECTANCY))\n\n\n\n\n\n\n\n\nEl bloque de código anterior puede reescribirse mediante un pipe, para pasar el conjunto de datos a ggplot(). También puede llamarse a aes() como un argumento de ggplot() y no de la función de geometría. Esto último acostumbra hacerse cuando los mapeos de las variables a las propiedades estéticas son los mismos en todas las capas del gráfico.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY)) +\n  geom_point() +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLa función scale_x_continuous() permite usar comas como separadores de miles y establecer los límites del eje X. También evita la notación científica.\nEl gráfico muestra una relación positiva entre el PIB per cápita y la esperanza de vida al nacer. En otras palabras, mientras mayor es el PIB per cápita de un país, mayor es la esperanza de vida al nacer de sus habitantes.\n\n\n9.3.1.3 Variables adicionales\nSe pueden incluir variables adicionales en el gráfico mediante su mapeo a otras propiedades visuales. En el siguiente bloque de código, la variable correspondiente al continente (CONTINENT), se mapea a la propiedad color.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# coloreado por continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLa misma variable puede mapearse a la propiedad visual shape (forma).\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# con formas de puntos correspondientes al continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, shape = CONTINENT)) +\n  geom_point() +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLos últimos continentes de la leyenda no se incluyen en el gráfico debido a que ggplot() solo muestra, por defecto, seis formas diferentes cuando se asignan de manera automática. Esto puede solucionarse si se asigna explícitamente una forma a cada categoría. En el siguiente bloque de código, se asignan manualmente tanto formas como colores a cada continente, mediante las funciones scale_shape_manual() y scale_color_manual().\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# con formas y colores correspondientes al continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, shape = CONTINENT, color = CONTINENT)) +\n  geom_point() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_shape_manual(values = c(0, 1, 2, 3, 4, 5, 6, 7)) +\n  scale_color_manual(values = c(\"red\", \"blue\", \"green\", \"purple\", \"orange\", \"brown\", \"pink\", \"yellow\"))\n\n\n\n\n\n\n\n\nEl siguiente bloque de código mapea la variable de la cilindrada con la propiedad visual tamaño (size) y compara el rendimiento en autopista de los automóviles con el rendimiento en ciudad.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# con tamaño de puntos correspondiente a la población\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, size = POP_EST, color = CONTINENT)) +\n  geom_point() +\n  scale_size_continuous(labels = comma) +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLa función scale_size_continuous() permite usar comas como separadores de miles y evitar la notación científica en la leyenda del gráfico.\n\n\n9.3.1.4 Capas adicionales\nUn mismo gráfico puede contener múltiples capas, cada una con su propia función de geometría. El siguiente bloque de código agrega una capa con la función geom_smooth(), la cual muestra una curva de tendencia.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# + curva de tendencia\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY)) +\n  geom_point() +\n  geom_smooth(method = 'lm') +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nEjercicios\n1. Revise la documentación de geom_smooth() para agregar otros tipos de curvas de tendencia al gráfico.\nEn el siguiente ejemplo, se mapea la variable continente (CONTINENT) a la propiedad visual del color, tanto para la capa de puntos como para la de la curva de tendencia.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90))\n\n\n\n\n\n\n\n\n\n\n9.3.1.5 Paneles\nComo se mostró anteriormente, una forma de mostrar variables adicionales en un gráfico es mediante propiedades visuales (color, forma, tamaño, etc.). Otra forma es mediante el uso de paneles (facets), los cuales dividen un gráfico en subgráficos, de acuerdo con los valores de una variable. Este método es particularmente apropiado cuando la variable adicional es categórica.\nLa función facet_wrap() divide un gráfico en paneles de acuerdo con una sola variable. El primer argumento es una fórmula, la cual se crea con el caracter ~ (tilde) seguido por el nombre de la variable.\nEn el siguiente bloque de código, se generan paneles para cada continente con el gráfico de dispersión de PIB per cápita vs esperanza vida. Es decir, un panel (subgráfico) por cada continente.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# + paneles por continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY)) +\n  geom_point() +\n  facet_wrap(~ CONTINENT, nrow = 2) +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLa función facet_grid() genera paneles con la combinación de dos variables. El primer argumento es también una fórmula, la cual contiene dos variables separadas por ~.\nEn el siguiente bloque de código, se generan paneles para el gráfico anterior, organizados por región de la ONU y grupo de ingresos.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# + paneles por región y subregión de la ONU\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY)) +\n  geom_point() +\n  facet_grid(REGION_UN ~ INCOME_GRP) +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\n\n\n9.3.1.6 Títulos, etiquetas, estilos y colores\n\n9.3.1.6.1 Titulos, subtítulos y etiquetas\nggplot2 incluye las funciones ggtitle(), xlab(), ylab() y labs(), las cuales permiten agregar títulos, subtítulos, etiquetas en los ejes y de otros tipos a un gráfico.\nAlgunas de las opciones que ofrecen estas funciones se ilustran en el siguiente gráfico.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(subtitle = \"Datos de África y Europa\", \n       caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\")\n\n\n\n\n\n\n\n\nEl títulos y las etiquetas de los ejes se pueden agregar también mediante argumentos de labs().\n\n\n9.3.1.6.2 Estilos\nggplot2 incluye un conjunto de estilos (themes) que pueden ayudar a mejorar el aspecto visual de los gráficos.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(subtitle = \"Datos de África y Europa\", \n       caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  theme_bw() # tema de ggplot2\n\n\n\n\n\n\n\n\nEjercicios\n1. Revise la documentación de estilos de ggplot2 y pruebe diferentes opciones en el gráfico anterior.\nExisten paquetes que ofrecen estilos adicionales como, por ejemplo, ggthemes.\n\n# Instalación de ggthemes\ninstall.packages(\"ggthemes\")\n\n\n# Carga de ggthemes\nlibrary(ggthemes)\n\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(subtitle = \"Datos de África y Europa\", \n       caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  theme_economist() # estilo de ggthemes\n\n\n\n\n\n\n\n\nOtro paquete de estilos y recursos relacionados (escalas de colores, fuentes, etc.) es hrbrthemes.\n\n# Instalación de hbrthemes\ninstall.packages(\"hrbrthemes\")\n\n\n# Carga de hbrthemes\nlibrary(hrbrthemes)\n\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(subtitle = \"Datos de África y Europa\", \n       caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  theme_ipsum() # tema de hrbrthemes\n\n\n\n\n\n\n\n\n\n\n9.3.1.6.3 Colores\nggplot2 incluye múltiples funciones para escalas de colores, entre las que pueden mencionarse:\n\nscale_color_brewer(): para escalas de colores secuenciales, divergentes y cualitativas de ColorBrewer.\nscale_color_viridis_d(): para escalas viridis, diseñadas para mejorar la legibilidad de gráficos para lectores con formas comunes de daltonismo y discapacidades relacionadas con la percepción de colores.\nscale_color_manual(): para especificar directamente los colores a utilizar.\n\nEl siguiente bloque de código genera un gráfico de dispersión para los datos de diamonds. Muestra el peso en quilates (carat) de los diamantes en el eje X y su precio (price) en el eje Y. La variable correspondiente a su claridad (clarity) se muestra mediante el color de los puntos, de acuerdo con una escala de ColorBrewer.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n#  coloreado por continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  labs(color = \"Población estimada\") +\n  scale_colour_brewer(palette = \"YlOrBr\", direction = -1) +\n  theme_ipsum() # estilo de hrbrthemes\n\n\n\n\n\n\n\n\nPara más información sobre etiquetas, estilos, colores y otros temas relacionados en ggplot2, se recomienda leer ggplot2: Elegant Graphics for Data Analysis - Themes.\n\n\n\n9.3.1.7 Opciones avanzadas\nEn las secciones y ejemplos anteriores, se han estudiado las opciones básicas para crear un gráfico en ggplot2: datos, mapeos de variables a propiedades visuales y capas. También se mostró la forma de implementar paneles, como un mecanismo para visualizar variables adicionales y algunos recursos para mejorar la apariencia de los gráficos.\nggplot2 incluye otras opciones para la creación de gráficos, como transformaciones estadísticas, transformaciones de sistemas de coordenadas y posicionamiento de las geometrías, las cuales pueden esquematizarse de la siguiente forma:\nggplot(data = &lt;DATOS&gt;) + \n  &lt;FUNCION_GEOMETRIA&gt;(\n    mapping = aes(&lt;MAPEOS&gt;),\n    stat = &lt;ESTADISTICA&gt;,\n    position = &lt;POSICION&gt;\n  ) +\n  &lt;FUNCION_COORDENADAS&gt; +\n  &lt;FUNCION_FACET&gt;\nEn las secciones siguientes, se explicarán y ejemplificarán alguna de estas opciones.\n\n\n\n9.3.2 plotly\nplotly R es una biblioteca para gráficos interactivos que forma parte del grupo de bibliotecas de graficación de Plotly, el cual también incluye bibliotecas para otros lenguajes como Python, Julia, F# y MATLAB. Plotly fue originalmente escrita en JavaScript, por lo que es particularmente adecuada para gráficos interactivos en la Web.\nplotly implementa la función ggplotly(), la cual convierte graficos de ggplot2 a plotly, haciéndolos interactivos.\nEl siguiente bloque de código muestra un gráfico generado con ggplot2 y convertido a plotly con la función ggplotly().\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\ngrafico_ggplot2 &lt;-\n  paises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point(aes(\n    # datos que se muestran al colocar el ratón sobre un punto\n    text = paste0(\n      \"PIB per cápita: \", GDP_PC, \"\\n\",\n      \"Esperanza de vida: \", LIFE_EXPECTANCY\n    )\n  )) +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  labs(color = \"Población estimada\") +\n  theme_ipsum() # estilo de hrbrthemes\n\n# Gráfico plotly\nggplotly(grafico_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es') # para mostrar los controles en español",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#tipos-de-gráficos",
    "href": "09-ggplot2-plotly.html#tipos-de-gráficos",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.4 Tipos de gráficos",
    "text": "9.4 Tipos de gráficos\nEn esta sección, se ejemplifican varios tipos de gráficos, los cuales se construyen con ggplot2 y luego se convierten a plotly.\n\n9.4.1 Gráficos de dispersión\nUn gráfico de dispersión (scatterplot) despliega los valores de dos variables numéricas, como puntos en un sistema de coordenadas. El valor de una variable se despliega en el eje X y el de la otra variable en el eje Y. Variables adicionales pueden ser mostradas mediante atributos de los puntos, tales como su tamaño, color o forma.\nEn ggplot2, los gráficos de dispersión se implementan con la función de geometría geom_point().\nEl siguiente bloque de código muestra la relación entre el PIB per cápita y la esperanza de vida de países.\n\n# Gráfico de dispersión PIB per cápita vs esperanza de vida\n# + línea de tendencia\ngrafico_dispersion_ggplot2 &lt;-\n  paises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY)) +\n  geom_point(aes(\n    text = paste0(\n      \"País: \",\n      NAME,\n      \"\\n\",\n      \"PIB per cápita: \",\n      scales::comma(round(GDP_PC, 2)),\n      \"\\n\",\n      \"Esperanza de vida: \",\n      round(LIFE_EXPECTANCY, 2)\n    )\n  )) +\n  geom_smooth(method = \"lm\") +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer\") +\n  xlab(\"PIB per cápita (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuentes: Natural Earth y Banco Mundial\") +\n  theme_economist()  \n\n# Gráfico de dispersión plotly\nggplotly(grafico_dispersion_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\nComo se explicó anteriormente, se pueden agregar al gráfico variables adicionales mediante su mapeo a propiedades visuales. En el siguiente ejemplo, se agrega la variable de continente al gráfico anterior, mediante su mapeo a la propiedad correspondiente al color.\n\n# Gráfico de dispersión PIB per cápita vs esperanza de vida\n# + línea de tendencia\ngrafico_dispersion_ggplot2 &lt;-\n  paises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point(aes(\n    text = paste0(\n      \"País: \",\n      NAME,\n      \"\\n\",\n      \"PIB per cápita: \",\n      scales::comma(round(GDP_PC, 2)),\n      \"\\n\",\n      \"Esperanza de vida: \",\n      round(LIFE_EXPECTANCY, 2)\n    )\n  )) +\n  geom_smooth(method = \"lm\") +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer\") +\n  xlab(\"PIB per cápita (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuentes: Natural Earth y Banco Mundial\", color = \"Continente\") +\n  theme_economist()  \n\n# Gráfico de dispersión plotly\nggplotly(grafico_dispersion_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\n\n\n9.4.2 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (en este caso, llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable. La graficación de la distribución de las variables es, frecuentemente, una de las primeras tareas que se realiza cuando se explora un conjunto de datos.\nEn ggplot2, los histogramas se implementan con la función geom_histogram().\nEl siguiente bloque de código muestra, mediante un histograma, la distribución del producto interno bruto (PIB) per cápita para el año 2007, entre los países incluídos en gapminder.\n\n# Histograma ggplot2 de distribución del PIB per cápita\nhistograma_ggplot2 &lt;- \n  paises |&gt;\n  ggplot(aes(x = GDP_PC)) +\n  geom_histogram(\n    aes(\n      text = paste0(\n        \"PIB per cápita (valor medio del rango): $\", round(after_stat(x), 2), \"\\n\",\n        \"Frecuencia: \", after_stat(count)\n      )\n    ), \n    bins = 10\n  )  +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  coord_cartesian(ylim = c(0, 40)) +\n  ggtitle(\"Distribución del PIB per cápita\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Frecuencia\") +\n  labs(subtitle = \"Datos de 201 países\", caption = \"Fuentes: Natural Earth y Banco Mundial\") +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\n\n9.4.3 Gráficos de pastel\nUn gráfico de pastel representa porcentajes y porciones en secciones (slices) de un círculo. Son muy populares, pero también criticados debido a la dificultad del cerebro humano de comparar áreas de sectores circulares, por lo que algunos expertos recomiendan sustituirlos por otros tipos de gráficos como, por ejemplo, gráficos de barras.\nEn ggplot2, los gráficos de pastel se implementan con la función de geometría geom_bar(stat = \"identity\", width = 1) y la función coord_polar(), la cual implementa un sistema de coordenadas polares.\nEl siguiente gráfico de pastel muestre la distribución de la población según la regiones de la Organización de Naciones Unidas (ONU).\n\n# Agrupar y resumir los datos\nsuma_poblacion_por_region &lt;- paises |&gt;\n  group_by(REGION_UN) |&gt;\n  summarise(POP_TOTAL = sum(POP_EST))\n\n# Calcular porcentajes\nporcentaje_poblacion_por_region &lt;- suma_poblacion_por_region |&gt;\n  mutate(POP_PCT = round(POP_TOTAL / sum(POP_TOTAL) * 100, 1))\n\n# Gráfico de pastel\ngrafico_pastel_ggplot2 &lt;-\n  ggplot(porcentaje_poblacion_por_region, aes(x = \"\", y = POP_TOTAL, fill = REGION_UN)) +\n  geom_bar(width = 1, stat = \"identity\") +\n  coord_polar(theta = \"y\") +\n  geom_text(\n    aes(label = paste0(POP_PCT, \"%\")), \n    position = position_stack(vjust = 0.6) # para ajustar la posición del texto en cada porción\n  ) +\n  labs(title = \"Distribución de la población por región de la ONU\",\n       x = NULL,\n       y = NULL,\n       fill = \"Región de la ONU\") +\n  theme_void()\n\n# Despliegue del gráfico\ngrafico_pastel_ggplot2\n\n\n\n\n\n\n\n# Gráfico de pastel plotly (está generando un error)\n# ggplotly(grafico_pastel_ggplot2) |&gt;\n#   config(locale = 'es')\n\nEl gráfico interactivo no se presenta en este caso, debido a que la función ggplotly() produce un error al procesar el gráfico de pastel generado por ggplot2.\n\n\n9.4.4 Gráficos de barras\nUn gráfico de barras se compone de barras rectangulares con longitud proporcional a estadísticas (ej. frecuencias, promedios, mínimos, máximos) asociadas a una variable categórica o discreta. Las barras pueden ser horizontales o verticales y se recomienda que estén ordenadas según su longitud, a menos que exista un orden inherente a la variable (ej. el orden de los días de la semana). Es uno de los tipos de gráficos estadísticos más antiguos y comunes y tiene la ventaja de ser muy fácil de comprender.\nEn ggplot2, los gráficos de barras se implementan con las funciones geom_bar(), que se utiliza en gráficos que requieren transformaciones estadísticas, y geom_col(), para gráficos que no requieren estas transformaciones.\n\n9.4.4.1 Barras con transformaciones estadísticas\nLos gráficos de barras y otros tipos de gráficos (ej. histogramas, gráficos de caja, líneas de ajuste) pueden requerir de alguna transformación estadística antes de presentar la información. Esta transformación estadística puede ser un conteo, el cálculo de un promedio, un mínimo o un máximo, entre otras opciones.\nPor ejemplo, el siguiente gráfico muestra la cantidad de países por región de la ONU presentes en el conjunto de datos de países. Nótese que este conteo no está presente en ninguna de las variables del conjunto de datos.\n\n# Gráfico de barras con conteo de países por región de la ONU\ngrafico_barras_ggplot2 &lt;-\npaises |&gt;\n  ggplot(aes(x = fct_infreq(REGION_UN))) +\n  geom_bar(\n    aes(\n      text = paste0(\n        \"Cantidad de países: \", after_stat(count)\n      )\n    )    \n  ) +\n  ggtitle(\"Cantidad de países por región de la ONU\") +\n  xlab(\"Región de la ONU\") +\n  ylab(\"Cantidad de países\") +\n  labs(caption = \"Fuente: Natural Earth\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\nLa función fct_infreq() del paquete forcats se usa para ordenar las barras. Si se prefiere el orden inverso, puede utilizarse la función fct_rev() (ej. fct_rev(fct_infreq(REGION_UN))). Para más información sobre el ordenamiento en gráficos, se recomienda consultar FAQ: Reordering - ggplot2.\nEl cálculo de la cantidad de países por continente o el de la cantidad de diamantes por corte, son ejemplos de transformaciones estadísticas. La Figura 9.1 muestra como se realiza este proceso para el gráfico anterior.\n\n\n\n\n\n\n\n\nFigura 9.1: Transformación estadística para un gráfico de barras de ggplot2. Imagen de Hadley Wickham.\n\n\n\n\n\nLas barras pueden mostrar otras transformaciones estadísticas a través del uso de los argumentos stat y fun.y de geom_bar(). Por ejemplo, stat = \"summary\" y fun.y = \"mean\"generan un gráfico que muestra el promedio de esperanza de vida (LIFE_EXPECTANCY) para cada región de la ONU.\n\n# Gráfico de barras con promedio de esperanza de vida\n# para cada región de la ONU\ngrafico_barras_ggplot2 &lt;-\n  paises |&gt;\n  ggplot(aes(x = fct_infreq(REGION_UN), y = LIFE_EXPECTANCY)) +\n  geom_bar(\n    stat = \"summary\", \n    fun.y = \"mean\",\n    aes(\n      text = paste0(\n        \"Promedio de esperanza de vida: \", round(after_stat(y), 2)\n      )\n    )\n  ) +\n  ggtitle(\"Promedio de esperanza de vida por región de la ONU\") +\n  xlab(\"Región de la ONU\") +\n  ylab(\"Promedio de esperanza de vida\") +\n  labs(caption = \"Fuente: \") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\nNota:  la función fct_infreq() no está ordenando en este caso las columnas. El ordenamiento aún puede conseguirse si se realiza primero el cálculo del promedio y luego se grafica la columna correspondiente, como en el siguiente bloque de código.\n\n# Cálculo del promedio de esperanza de vida por región\npromedio_esperanza_vida_por_region &lt;-\n  paises |&gt;\n  group_by(REGION_UN) |&gt;\n  summarize(LIFE_EXPECTANCY_MEAN = mean(LIFE_EXPECTANCY, na.rm = TRUE))\n\n# Despliegue por orden descendente del promedio de esperanza de vida\npromedio_esperanza_vida_por_region |&gt;\n  arrange(desc(LIFE_EXPECTANCY_MEAN))\n\n# A tibble: 6 × 2\n  REGION_UN  LIFE_EXPECTANCY_MEAN\n  &lt;chr&gt;                     &lt;dbl&gt;\n1 Europe                     78.6\n2 Asia                       74.5\n3 Americas                   73.5\n4 Oceania                    71.0\n5 Africa                     63.1\n6 Antarctica                NaN  \n\n\nLuego se dibuja luego el gráfico con geom_col() y se ordenan las barras con la función reorder().\n\n# Gráfico de barras con promedio de esperanza de vida\n# para cada región de la ONU\ngrafico_barras_ggplot2 &lt;-\n  promedio_esperanza_vida_por_region |&gt;\n  ggplot(aes(x = reorder(REGION_UN,-LIFE_EXPECTANCY_MEAN), y = LIFE_EXPECTANCY_MEAN)) +\n  geom_col(\n    aes(\n      text = paste0(\n        \"Promedio de esperanza de vida: \", round(after_stat(y), 2)\n      )\n    )    \n  ) +\n  ggtitle(\"Promedio de esperanza de vida por región de la ONU\") +\n  xlab(\"Región de la ONU\") +\n  ylab(\"Promedio de esperanza de vida\") +\n  labs(caption = \"Fuente: Natural Earth\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')\n\n\n\n\n\nEl uso de geom_col() se ampliará en la sección siguiente.\n\n\n9.4.4.2 Barras sin transformaciones estadísticas\nEn algunos conjuntos de datos, el valor que se quiere representar en la longitud de las barras ya está presente como una variable en el conjunto de datos, por lo que no es necesario que ggplot2 realice una transformación estadística. En estos casos, se utiliza la función geom_col().\nNota:  para dibujar barras sin transformaciones estadísticas, tambien es posible utilizar la función geom_bar(). En este caso, al argumento stat se le asigna el valor \"identity\" y al argumento y de aes() la variable que contiene el valor que quiere mostrarse en las barras.\nEl siguiente gráfico de barras muestra la población de los países de los países de América. Nótese que este valor se puede tomar directamente de la variable POP_EST, después de realizar los filtros correspondientes.\n\n# Gráfico de barras con población de países \n# de América\ngrafico_barras_ggplot2 &lt;-\npaises |&gt;\n  filter(REGION_UN == \"Americas\") |&gt;\n  ggplot(aes(x = reorder(ADM0_ISO, POP_EST), y = POP_EST/1000000)) +\n  geom_col(\n    aes(\n      text = paste0(\n        \"País: \", NAME, \"\\n\",\n        \"Población (millones de habitantes): \", round(POP_EST/1000000, 2)\n      )\n    )\n  ) +\n  scale_y_discrete(expand = expansion(mult = c(0.2, 0.2))) + # agrega un 20% de espacio al inicio y al final del eje y\n  coord_flip() + # para mostrar barras horizontales\n  ggtitle(\"Población de países de América\") +\n  xlab(\"País\") +\n  ylab(\"Población (millones de habitantes)\") +\n  labs(caption = \"Fuente: Natural Earth\") +\n  theme_economist()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\n\n9.4.4.3 Barras apiladas\nAl usar el argumento fill de aes(), las barras de un gráfico pueden dividirse de acuerdo con una variable adicional, produciendo el efecto de barras apiladas (i.e. unas sobre otras).\nEn el siguiente bloque de código, se genera un gráfico de barras apiladas que, para el conjunto de datos de países, muestra las cantidades de países por región de la ONU (REGION_UN) subdivididas por nivel de economía (ECONOMY).\n\n# Gráfico de barras apiladas por región de la ONU y nivel de economía\ngrafico_barras_ggplot2 &lt;-\npaises |&gt;\n  ggplot(aes(x = REGION_UN, fill = ECONOMY)) +\n  geom_bar() +\n  ggtitle(\"Cantidad de países por región de la ONU y nivel de economía\") +\n  xlab(\"Región de la ONU\") +\n  ylab(\"Cantidad de países\") +\n  labs(fill = \"Nivel de economía\") +\n  theme_minimal()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |&gt; \n  config(locale = 'es')\n\n\n\n\n\nEl argumento position = \"fill\" de geom_bar() también genera barras apiladas, pero le asigna a todas las barras la misma longitud, facilitando así la comparación de proporciones.\n\n# Gráfico de barras apiladas por región de la ONU y nivel de economía\ngrafico_barras_ggplot2 &lt;-\npaises |&gt;\n  ggplot(aes(x = REGION_UN, fill = ECONOMY)) +\n  geom_bar(position = \"fill\") +\n  ggtitle(\"Proporción de niveles de economía en regiones de la ONU\") +\n  xlab(\"Región de la ONU\") +\n  ylab(\"Proporción\") +\n  labs(fill = \"Nivel de economía\") +\n  theme_minimal()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |&gt; \n  config(locale = 'es')\n\n\n\n\n\n\n\n9.4.4.4 Barras agrupadas\nEl argumento position = \"dodge\" de geom_bar() genera barras agrupadas (i.e. unas al lado de otras), facilitando así la comparación de valores individuales.\n\n# Gráfico de barras agrupadas por región de la ONU y nivel de economía\ngrafico_barras_ggplot2 &lt;-\npaises |&gt;\n  ggplot(aes(x = REGION_UN, fill = ECONOMY)) +\n  geom_bar(position = \"dodge\") +\n  ggtitle(\"Cantidad de países por región de la ONU y nivel de economía\") +\n  xlab(\"Región de la ONU\") +\n  ylab(\"Cantidad de países\") +\n  labs(fill = \"Nivel de economía\") +\n  theme_minimal()\n\n# Gráfico de barras plotly\nggplotly(grafico_barras_ggplot2) |&gt; \n  config(locale = 'es')",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#recursos-de-interés",
    "href": "09-ggplot2-plotly.html#recursos-de-interés",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.5 Recursos de interés",
    "text": "9.5 Recursos de interés\nDT: An R interface to the DataTables library. (s. f.). Recuperado 21 de mayo de 2022, de https://rstudio.github.io/DT/\nHealy, Y. H. and C. (s. f.). From data to Viz | Find the graphic you need. Recuperado 20 de marzo de 2022, de https://www.data-to-viz.com/\nRStudio. (2017). Data visualization with ggplot2::Cheat Sheet. https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf\nWickham, H. (2010). A Layered Grammar of Graphics. Journal of Computational and Graphical Statistics, 19(1), 3-28. https://doi.org/10.1198/jcgs.2009.07098",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  }
]