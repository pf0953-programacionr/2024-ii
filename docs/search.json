[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PF-0953 Programación en R 2024-II",
    "section": "",
    "text": "Bienvenida\nEste es un curso introductorio a la programación de computadoras y al procesamiento de datos geoespaciales mediante el lenguaje de programación R. También se estudian herramientas para facilitar la reproducibilidad de los procedimientos y la comunicación de las soluciones a través de Internet y otros medios. Se imparte en la Maestría Académica en Gestión Integrada del Recurso Hídrico para Latinoamérica y el Caribe de la Universidad de Costa Rica.\nEl enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplican en diversos escenarios de procesamiento de datos las habilidades y conocimientos aprendidos. No se requiere de experiencia en programación de computadoras. Es recomendable contar con conocimentos básicos de datos geoespaciales y sistemas de información geográfica.\nTanto las lecciones teóricas como las prácticas se imparten de manera presencial, con apoyo de medios virtuales. Los contenidos del curso y los recursos relacionados se comparten en el sitio web https://pf0953-programacionr.github.io/2024-ii/ y en la plataforma Mediación Virtual de la Universidad de Costa Rica.\n\n\nObjetivos\nAl finalizar el curso, el estudiantado será capaz de:\n\nDesarrollar programas en el lenguaje de programación R orientados al procesamiento de datos geoespaciales.\nAplicar un enfoque de ciencia de datos en los procesos de importación, transformación, visualización, análisis y comunicación de datos.\nDesarrollar soluciones reproducibles a problemas computacionales mediante R.\nIntegrar visualizaciones tabulares, gráficas y geoespaciales de datos en documentos y aplicaciones interactivas desarrolladas en R.\n\n\n\nPrograma\nEl programa del curso está disponible en programa del curso.\n\n\nCiclos anteriores\nEste sitio web corresponde al curso impartido durante el segundo ciclo lectivo de 2024. Para consultar las versiones de otros años y ciclos lectivos, puede visitar:\n\n2022-II\n\n\n\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "programa_curso.html",
    "href": "programa_curso.html",
    "title": "Programa del curso",
    "section": "",
    "text": "Programa del curso",
    "crumbs": [
      "Programa del curso"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html",
    "href": "01-introduccion-programacion-computadoras.html",
    "title": "1  Introducción a la programación de computadoras",
    "section": "",
    "text": "Introducción\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones tales como cálculos aritméticos y operaciones lógicas, entre otras. Un conjunto de instrucciones orientado a la resolución de un problema específico mediante una computadora se denomina programa. La programabilidad de las computadoras permite que su funcionamiento pueda modificarse sin alterar sus componentes físicos, lo que las hace mucho más versátiles que otros tipos de máquinas y posibilita que ayuden a resolver una gran variedad de problemas.\nLas computadoras se programan mediante lenguajes de dos niveles: lenguajes de máquina y lenguajes de programación. En este capítulo, se describe el papel de los lenguajes de programación y el modelo Entrada - Procesamiento - Salida en el que se basa la estructura de los programas. También se detallan los componentes principales de la arquitectura de computadoras más popular en la actualidad.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#trabajo-previo",
    "href": "01-introduccion-programacion-computadoras.html#trabajo-previo",
    "title": "1  Introducción a la programación de computadoras",
    "section": "",
    "text": "Lecturas\nDowney, Allen B. (2024). Chapter 1: Programming as a way of thinking en Think Python: How to Think Like a Computer Scientist (3rd ed.). O’Reilly Media. https://allendowney.github.io/ThinkPython/chap01.html\nSeverance, D. C. R. (2016). Chapter 1: Why should you learn to write programs? en Python for Everybody: Exploring Data in Python 3 (S. Blumenberg & E. Hauser, Eds.). CreateSpace Independent Publishing Platform. https://www.py4e.com/html3/",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#introducción",
    "href": "01-introduccion-programacion-computadoras.html#introducción",
    "title": "1  Introducción a la programación de computadoras",
    "section": "Introducción",
    "text": "Introducción\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones tales como cálculos aritméticos y operaciones lógicas, entre otras. Un conjunto de instrucciones orientado a la resolución de un problema específico mediante una computadora se denomina programa. La programabilidad de las computadoras permite que su funcionamiento pueda modificarse sin alterar sus componentes físicos, lo que las hace mucho más versátiles que otros tipos de máquinas y posibilita que ayuden a resolver una gran variedad de problemas.\nLas computadoras se programan mediante lenguajes de dos niveles: lenguajes de máquina y lenguajes de programación. En este capítulo, se describe el papel de los lenguajes de programación y el modelo Entrada - Procesamiento - Salida en el que se basa la estructura de los programas. También se detallan los componentes principales de la arquitectura de computadoras más popular en la actualidad.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "parte-i-introduccion-programacion-computadoras-ciencia-datos.html",
    "href": "parte-i-introduccion-programacion-computadoras-ciencia-datos.html",
    "title": "I - Introducción a la programación de computadoras y a la ciencia de datos",
    "section": "",
    "text": "1 Introducción a la programación de computadoras\n2 Introducción a la ciencia de datos",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#lenguajes-para-programar-computadoras",
    "href": "01-introduccion-programacion-computadoras.html#lenguajes-para-programar-computadoras",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.1 Lenguajes para programar computadoras",
    "text": "1.1 Lenguajes para programar computadoras\nLas computadoras pueden programarse mediante lenguajes de varios niveles. En esta sección, se describen el lenguaje de máquina, el más cercano al hardware de la computadora, y los lenguajes de programación, los cuales abstraen detalles técnicos y de hardware para lograr que la programación sea más intuitiva, más rápida y menos propensa a errores.\n\n1.1.1 Lenguajes de máquina\nLas computadoras modernas son electrónicas y utilizan circuitos integrados para procesar y almacenar información en forma de señales eléctricas. Esta representación de la información se basa en un sistema binario (de dos estados): 0 (voltaje bajo) y 1 (voltaje alto).\nEn el nivel más básico, las computadoras pueden programarse introduciendo directamente combinaciones de unos y ceros, conocidas como lenguaje de máquina en la Unidad Central de Procesamiento (CPU), el componente de hardware encargado de ejecutar las instrucciones.\nPor ejemplo, la Figura 1.1 muestra el programa Hola mundo (Hello World) en lenguaje de máquina. Este programa simplemente imprime la hilera de texto “Hola mundo” en la pantalla. Suele ser usado como introducción al estudio de la programación de computadoras.\n\n\n\n\n\n\nFigura 1.1: Lenguaje de máquina correspondiente a la implementación del programa “Hola mundo” en el lenguaje C (mostrado abajo). Imagen de Tanveer Salim.\n\n\n\n/* PROGRAMA \"Hola mundo\" EN LENGUAJE C */\n\nint main void()\n{\n  printf(\"hello, world\\n\");\n  return 0;\n}\nInternamente, el lenguaje de máquina ejecuta un conjunto de instrucciones muy básicas como, por ejemplo:\n\nSumar dos números.\nComprobar si un número es igual a cero.\nCopiar datos de una sección a otra de la memoria de la computadora.\n\nLos lenguajes de máquina son específicos para cada tipo de CPU. Así, por ejemplo, el lenguaje de máquina de un procesador Intel, uno de los más usados en computadoras personales, es diferente al lenguaje de máquina de un procesador PowerPC, utilizado tanto en computadoras personales (como antiguas Macintosh), como en consolas de videojuegos y sistemas incrustados (ej. en dispositivos electrónicos).\n\n\n1.1.2 Lenguajes de programación\nDebido a que el lenguaje de máquina es poco amigable para las personas, actualmente es más común utilizar lenguajes de programación para resolver problemas mediante computadoras. Los lenguajes de programación consisten de instrucciones compuestas por palabras y expresiones similares a las de los lenguajes humanos como, por lo general, el idioma inglés. Existe una gran variedad de lenguajes de programación, debido a los diferentes fines para los que fueron creados y a su evolución histórica, entre otras razones.\nLas instrucciones de los lenguajes de programación deben ser traducidas al lenguaje de máquina para que puedan ser ejecutados por la computadora. Esta traducción se realiza mediante programas llamados compiladores (para lenguajes compilados como C y C++) o interpretadores (para lenguajes interpretados como Python y R). Mientras que los lenguajes de máquina son específicos para cada CPU, algunos lenguajes de programación pueden ser ejecutados en diferentes plataformas, con el compilador o interpretador adecuado.\nComo ejemplo, considere problema del cálculo del índice de masa corporal (IMC). El IMC indica si una persona tiene una masa (peso) saludable en relación con su estatura. Se obtiene mediante la fórmula:\n\\[\nimc = \\frac{masa}{estatura^2}\n\\]\nEl resultado se interpreta de la siguiente manera:\n\nIMC menor que 18.5: Peso bajo.\nIMC mayor o igual que 18.5 y menor que 25: Peso normal.\nIMC mayor o igual que 25: Sobrepeso.\n\nEl siguiente programa en el lenguaje Python calcula e interpreta el IMC de una persona.\n# CÁLCULO E INTERPRETACIÓN DEL IMC DE UNA PERSONA\n\n\n# ENTRADA\n\n# Datos de masa (kg) y estatura (m) de una persona\nmasa = 65\nestatura = 1.7\n\n\n# PROCESAMIENTO\n\n# Cálculo del IMC\nimc = masa / estatura**2\n\n# Interpretación del IMC\nif (imc &lt; 18.5):\n  interpretacion_imc = \"Peso bajo\"\nelif (imc &lt; 25):\n  interpretacion_imc = \"Peso normal\"\nelse:\n  interpretacion_imc = \"Sobrepeso\"\n\n\n# SALIDA\n\n# Impresión de los resultados\nprint(\"El valor del IMC es:\", imc)\nprint(\"Corresponde a:\", interpretacion_imc)\nA manera de ejercicio, puede escribir y ejecutar el programa anterior en una consola de Python. Modifique los datos de entrada de masa y estatura y observe los cambios en los resultados.\nEn el ejemplo anterior puede observarse como el programa sigue un modelo conocido como “Entrada - Procesamiento - Salida”, el cual se describe en detalle en la sección siguiente.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#modelo-entrada---procesamiento---salida",
    "href": "01-introduccion-programacion-computadoras.html#modelo-entrada---procesamiento---salida",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.2 Modelo Entrada - Procesamiento - Salida",
    "text": "1.2 Modelo Entrada - Procesamiento - Salida\nLas computadoras trabajan con un modelo de “Entrada - Procesamiento - Salida”: reciben datos de entrada (ej. números), los procesan (ej. realizan cálculos aritméticos) y generan salidas (ej. resultados de los cálculos).\nEl modelo “Entrada - Procesamiento - Salida” es un concepto fundamental en análisis de sistemas de información y desarrollo de programas. Su esquema se presenta en la Figura 1.2.\n\n\n\n\n\n\nFigura 1.2: Modelo “Entrada - Procesamiento - Salida”\n\n\n\n\nLa Entrada se refiere a los datos que se introducen en un sistema o programa para ser procesados. Pueden ingresarse a través de diferentes medios como teclados, ratones, cámaras, sensores, archivos y servicios web, entre otros.\nEl Procesamiento es el conjunto de instrucciones que generan salidas a partir de las entradas. Estas intrucciones pueden incluir cálculos matemáticos, operaciones lógicas y operaciones de control, entre muchas posibilidades.\nPor último, la Salida es el resultado del procesamiento como, por ejemplo, resultado de cálculos aritméticos.\n\nEl modelo “Entrada - Procesamiento - Salida” se implementa en los componentes físicos mediante la arquitectura de computadoras, como se explica a continuación.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#arquitectura-de-computadoras",
    "href": "01-introduccion-programacion-computadoras.html#arquitectura-de-computadoras",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.3 Arquitectura de computadoras",
    "text": "1.3 Arquitectura de computadoras\nLa arquitectura de computadoras es un área de estudio enfocada en el diseño de los componentes principales de un sistema informático.\n\n1.3.1 Evolución histórica\nLa arquitectura de las computadoras modernas es el resultado de un proceso que ha tomado varios siglos, incluyendo la fabricación de calculadoras mecánicas en el siglo XVII, con capacidades para realizar operaciones aritméticas básicas, y el diseño en el siglo XIX de la máquina analítica de Charles Babbage, una computadora mecánica que incorporaba algunas características de las computadoras modernas.\nEn 1936, el matemático inglés Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas y que funcionó como un modelo teórico de gran importancia para desarrollos posteriores, como los dispositivos eletromecánicos Bombe y Colossus en el Reino Unido, de uso específico para criptografía durante la II Guerra Mundial. Algunos años después, en 1946, el ejército de los Estados Unidos desarrolló ENIAC (Electronic Numerical Integrator And Computer), considerada por algunos como la primera computadora de uso general y que fue inicialmente diseñada para calcular tablas de tiro de artillería.\n\n\n1.3.2 Arquitectura de von Neumann\nEn 1945, el matemático húngaro-estadounidense John von Neumann (1903-1957) propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada de los componentes físicos que ejecutan las instrucciones. Este modelo permite que las computadoras sean más fáciles de programase y reprogramarse y es conocido actualmente como arquitectura de von Neumann. La arquitectura de von Neumann se ilustra en la Figura 1.3.\n\n\n\n\n\n\nFigura 1.3: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\n\n\n\n\n1.3.2.1 Componentes de la arquitectura de von Neumann\n\n1.3.2.1.1 Memoria principal\nAlmacena las instrucciones de los programas y los datos que utilizan estos programas. Es común denominarla como RAM (Random Access Memory, Memoria de Acceso Aleatorio), lo que significa que toma el mismo tiempo acceder a cualquier posición de la memoria. Cada posición de memoria tiene una dirección a la que se hace referencia cuando se desea leer o escribir.\n\n\n1.3.2.1.2 Unidad Central de Procesamiento\nTambién se le conoce como CPU (Central Processing Unit, Unidad Central de Procesamiento). Ejecuta las instrucciones de los programas en lenguaje de máquina. Está compuesta por dos partes:\n\nUnidad de Control: determina cuál es la siguiente instrucción a ejecutar. Contiene memorias temporales de alta velocidad y poca capacidad llamadas registros, para almacenar los operandos y el resultado de las instrucciones.\nUnidad de Aritmética y Lógica o ALU (Arithmetic and Logic Unit): ejecuta las operaciones aritméticas y lógicas.\n\n\n\n1.3.2.1.3 Sistemas de entrada y salida\nPermiten que la computadora interactúe con el usuario y, en general, con el mundo exterior. Algunos ejemplos son el teclado y el ratón, como sistemas de entrada, y la pantalla y la impresora, como sistemas de salida.\n\n\n\nFigura 1.1: Lenguaje de máquina correspondiente a la implementación del programa “Hola mundo” en el lenguaje C (mostrado abajo). Imagen de Tanveer Salim.\nFigura 1.2: Modelo “Entrada - Procesamiento - Salida”\nFigura 1.3: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html",
    "href": "02-introduccion-ciencia-datos.html",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "href": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "Lecturas\nÇetinkaya-Rundel, Mine, & Hardin, Johanna (2021). Chapter 1: Hello data en Introduction to Modern Statistics (1st ed.). OpenIntro, Inc. https://openintro-ims.netlify.app/data-hello\nSingleton, Alex David; Spielman, Seth; & Brunsdon, Chris (2016). Establishing a framework for Open Geographic Information science. International Journal of Geographical Information Science, 30(8), 1507-1521. https://doi.org/10.1080/13658816.2015.1137579\nWickham, Hadley; Çetinkaya-Rundel, Mirne; & Grolemund, Garret (2023). Introduction en R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/intro",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#introducción",
    "href": "02-introduccion-ciencia-datos.html#introducción",
    "title": "2  Introducción a la ciencia de datos",
    "section": "Introducción",
    "text": "Introducción\nUna investigación estadística se basa en datos. Los datos acostumbran representarse en tablas, en las cuales cada fila es una observación y cada columna es una variable. Una observación corresponde a un elemento de datos que ha sido estudiado y cada variable a una característica de ese elemento. Las variables pueden ser numéricas o categóricas. Las numéricas se subdividen en discretas y continuas y las categóricas en nominales y ordinales.\nLa ciencia de datos es una disciplina que permite convertir datos sin procesar en comprensión y conocimiento. El ciclo de vida de un proyecto de ciencia de datos incluye los procesos importar, ordenar, transformar, visualizar, modelar y comunicar. La programación de computadoras puede emplearse en cualquier etapa del ciclo de vida de un proyecto para automatizar tareas y a resolver nuevos problemas con mayor facilidad.\nEl surgimiento de la ciencia de datos está motivado por un incremento acelerado de la cantidad de datos existentes, así como de la disponibilidad de herramientas computacionales y de infraestructura informática para procesarlos y analizarlos. Estos cambios tecnológicos han sido apoyados por un cambio cultural propiciado por movimientos como el de ciencia abierta (open science), el cual promueve el acceso libre a la investigación científica, incluidas las publicaciones, los datos, las metodologías y el código fuente.\nUn aspecto crucial de la ciencia abierta es la reproducibilidad, que garantiza que los resultados de una investigación puedan ser verificados y validados por otros investigadores. Hay varias herramientas que pueden facilitar la reproducibilidad en ciencia de datos, incluyendo lenguajes de programación, lenguajes de marcado y sistemas de control de versiones.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#datos",
    "href": "02-introduccion-ciencia-datos.html#datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.1 Datos",
    "text": "2.1 Datos\nLos científicos tratan de responder preguntas mediante métodos rigurosos y observaciones cuidadosas. Estas observaciones, recopiladas de notas de campo, encuestas y experimentos, entre otras fuentes, forman la columna vertebral de una investigación estadística y se denominan datos. La presentación y descripción efectivas de los datos constituyen el primer paso en un análisis Çetinkaya-Rundel & Hardin (2021). Esta sección introduce una estructura para organizar los datos, así como alguna terminología que se utilizará a lo largo de este curso.\n\n2.1.1 Observaciones y variables\nLa tabla 1 contiene 10 filas de un conjunto de datos. Cada fila representa una persona. En términos estadísticos, cada fila corresponde a una observación. Las columnas representan características de las personas. Cada columna corresponde a una variable.\n\n\n\nTabla 1. Datos de personas.\n\n\n\n\ncedula\n\n\nprovincia\n\n\nequipo\n\n\npeso\n\n\nestatura\n\n\nsexo\n\n\ncantidad_hermanos\n\n\nnivel_guitarra\n\n\n\n\n\n\n709880238\n\n\nLimón\n\n\nSaprissa\n\n\n51.0\n\n\n1.51\n\n\ndesconocido\n\n\n0\n\n\nnulo\n\n\n\n\n400680168\n\n\nHeredia\n\n\nHerediano\n\n\n98.5\n\n\n1.87\n\n\nhombre\n\n\n1\n\n\nalto\n\n\n\n\n509210285\n\n\nGuanacaste\n\n\nLiberia\n\n\n91.6\n\n\n1.65\n\n\nmujer\n\n\n4\n\n\nbajo\n\n\n\n\n701950272\n\n\nLimón\n\n\nLiberia\n\n\n60.6\n\n\n1.68\n\n\nmujer\n\n\n1\n\n\nalto\n\n\n\n\n309880238\n\n\nCartago\n\n\nCartaginés\n\n\n59.1\n\n\n1.73\n\n\nmujer\n\n\n3\n\n\nbajo\n\n\n\n\n908280708\n\n\nDesconocida\n\n\nSan Carlos\n\n\n59.2\n\n\n1.89\n\n\nhombre\n\n\n3\n\n\nbajo\n\n\n\n\n505580938\n\n\nGuanacaste\n\n\nCartaginés\n\n\n65.2\n\n\n1.70\n\n\nmujer\n\n\n3\n\n\nalto\n\n\n\n\n504080488\n\n\nGuanacaste\n\n\nSporting\n\n\n76.2\n\n\n1.76\n\n\nhombre\n\n\n3\n\n\nexperto\n\n\n\n\n709950244\n\n\nLimón\n\n\nAlajuelense\n\n\n71.6\n\n\n1.80\n\n\nhombre\n\n\n4\n\n\nbajo\n\n\n\n\n206080825\n\n\nAlajuela\n\n\nAlajuelense\n\n\n64.6\n\n\n1.52\n\n\nhombre\n\n\n2\n\n\nbajo\n\n\n\n\n\n\n2.1.2 Tipos de variables\nLas variables de los datos de la tabla 1 son de varios tipos, cuya jerarquía se muestra en la Figura 2.1.\n\n\n\n\n\n\nFigura 2.1: Tipos de variables estadísticas. Imagen de Çetinkaya-Rundel & Hardin (2021)\n\n\n\nSeguidamente, se describen estos tipos de datos de las variables.\n\n2.1.2.1 Numéricas\nCorresponden a números a los cuales se les pueden aplicar operaciones como suma, resta, multiplicación, división y otras similares. Las variables numéricas puden ser discretas o continuas.\n\n2.1.2.1.1 Discretas\nToman valores específicos que se pueden contar. La variable cantidad_hermanos es discreta. Existe una separación clara entre sus posibles valores. Por ejemplo, es posible tener 1, 2 o 3 hermanos, pero no 2.5.\n\n\n2.1.2.1.2 Continuas\nPueden tomar cualquier valor dentro de un intervalo o rango continuo. Estas variables se caracterizan por su capacidad para representar medidas precisas y pueden asumir un número infinito de valores, incluso dentro de un rango limitado (ej. entre 0 y 1). Las variables peso y estatura son continuas.\n\n\n\n2.1.2.2 Categóricas\nLas variables categóricas (también llamadas cualitativas), son aquellas que describen una característica o cualidad de una observación y pueden utilizarse para clasificar las observaciones en grupos o categorías. A diferencia de las variables numéricas, que expresan cantidades, las variables categóricas expresan atributos no numéricos. Las variables categóricas pueden ser nominales u ordinales.\n\n2.1.2.2.1 Nominales\nNo existe un orden inherente o jerarquía entre las categorías. Las variables provincia, equipo y sexo son nominales.\n\n\n2.1.2.2.2 Ordinales\nHay un orden o jerarquía clara entre las categorías. La variable nivel_guitarra, con sus valores nulo, bajo, alto y experto, es ordinal.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#referencias-bibliográficas",
    "href": "02-introduccion-ciencia-datos.html#referencias-bibliográficas",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.5 Referencias bibliográficas",
    "text": "2.5 Referencias bibliográficas\n\n\nÇetinkaya-Rundel, M., & Hardin, J. (2021). Introduction to\nModern Statistics (1st ed.). OpenIntro,\nInc. Retrieved from https://openintro-ims.netlify.app/\n\n\nGandrud, C. (2020). Reproducible research with R and\nRStudio (Third edition). Boca Raton, FL: CRC Press.\n\n\nHarrison, D., & Rubinfeld, D. L. (1978). Hedonic housing prices and\nthe demand for clean air. Journal of Environmental Economics and\nManagement, 5(1), 81–102. https://doi.org/10.1016/0095-0696(78)90006-2\n\n\nKrugman, P. (2013). Opinion  The\nExcel Depression. The New York Times.\nRetrieved from https://www.nytimes.com/2013/04/19/opinion/krugman-the-excel-depression.html\n\n\nPeng, R. D. (2011). Reproducible Research in\nComputational Science. Science,\n334(6060), 1226–1227. https://doi.org/10.1126/science.1213847\n\n\nPrince, S. J. D. (2023). Understanding deep learning. The MIT\nPress. Retrieved from http://udlbook.com\n\n\nSingleton, A. D., Spielman, S., & Brunsdon, C. (2016). Establishing\na framework for Open Geographic\nInformation science. International Journal of\nGeographical Information Science, 30(8), 1507–1521. https://doi.org/10.1080/13658816.2015.1137579\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\nData Science: Import,\nTidy, Transform, Visualize, and\nModel Data (2nd ed.). O’Reilly Media.\nRetrieved from https://r4ds.hadley.nz/\n\n\n\n\n\nFigura 2.1: Tipos de variables estadísticas. Imagen de Çetinkaya-Rundel & Hardin (2021)\nFigura 2.2: Ciclo de vida de un proyecto de ciencia de datos. Imagen de Wickham et al. (2023)\nFigura 2.3: Problemas de regresión y clasificación. Imagen de Prince (2023)\nFigura 2.4: Modelo de aprendizaje automático. Imagen de Prince (2023).\nFigura 2.5: Espectro de reproducibilidad. Imagen de Anita Graser basada en Peng (2011).",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#ciclo-de-vida-de-un-proyecto-de-ciencia-de-datos",
    "href": "02-introduccion-ciencia-datos.html#ciclo-de-vida-de-un-proyecto-de-ciencia-de-datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.2 Ciclo de vida de un proyecto de ciencia de datos",
    "text": "2.2 Ciclo de vida de un proyecto de ciencia de datos\nLa ciencia de datos es una disciplina que permite convertir datos “crudos” (sin procesar) en comprensión y conocimiento Wickham, Çetinkaya-Rundel, & Grolemund (2023). Se basa en la estadística y en las ciencias de la computación, entre otras disciplinas.\n\n2.2.1 Procesos\nLa Figura 2.2 ilustra el ciclo de vida de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\n\nFigura 2.2: Ciclo de vida de un proyecto de ciencia de datos. Imagen de Wickham et al. (2023)\n\n\n\n\n2.2.1.1 Importar\nImportar los datos generalmente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en estructuras apropiadas para este propósito en un lenguaje de programación.\n\n\n2.2.1.2 Ordenar\nOrdenar o estructurar (to tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable. En algunos casos, pueden requerirse estructuras de otros tipos.\n\n\n2.2.1.3 Transformar\nTransformar los datos incluye, entre otras operaciones, la generación de algún subconjunto de observaciones o variables del conjunto original, la creación de nuevas variables a partir de las ya existentes o el cálculo de estadísticas como conteos y promedios.\nUna vez que los datos están bien estructurados y con las variables que se requieren para el análisis, se puede proceder a la generación de conocimiento mediante dos mecanismos: la visualización y la modelización. Ambos tienen fortalezas y debilidades y es común iterar varias veces entre uno y otro.\n\n\n2.2.1.4 Visualizar\nVisualizar los datos en tablas, gráficos, mapas u otros formatos permite encontrar patrones inesperados o formular nuevas preguntas. Una buena visualización también puede indicar si se están formulando preguntas equivocadas o utilizando datos que no son apropiados para el problema que se desea resolver. Es importante tener en cuenta que las visualizaciones deben ser interpretadas por seres humanos. Por este motivo, visualizaciones como gráficos estadísticos y mapas deben ser seleccionadas con cuidado y elaborarse detalladamente.\n\n\n2.2.1.5 Modelar\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones. Al ser herramientas matemáticas o computacionales, los modelos muchas veces pueden mejorarse mediante el empleo de mayores capacidades de cómputo, lo que los hace menos dependientes de la intervención humana, como en el caso de las visualizaciones.\n\n\n2.2.1.6 Comunicar\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general. No importa lo bien que los modelos y visualizaciones ayuden a entender los datos si los resultados no pueden ser comunicados a otras personas.\n\n\n2.2.1.7 Programar\nLa programación de computadoras se utiliza de manera transversal en los procesos recién descritos. Puede emplearse en cualquier etapa del ciclo de vida de un proyecto de ciencia de datos. Es útil para automatizar tareas y a resolver nuevos problemas con mayor facilidad.\n\n\n\n2.2.2 Ejemplos\nLas etapas iniciales de un proyecto de ciencia de datos incluyen técnicas estadísticas convencionales como el análisis exploratorio de datos (EDA), mientras que las más avanzadas pueden involucrar técnicas de inteligencia artificial como aprendizaje automático (machine learning) y aprendizaje profundo (deep learning).\nLa Figura 2.3 ilustra varios problemas resueltos mediante regresión y clasificación, dos técnicas que se utilizan en deep learning. En cada caso, hay una entrada que puede tener diversos formatos como un conjunto de números, una hilera de texto, un archivo de sonido o una imagen. Esta entrada se transforma y se codifica como un vector de números. Este vector constituye la entrada del modelo de regresión o clasificación. El modelo convierte la entrada en un vector de salida que se “traduce” de nuevo a un formato adecuado.\n\n\n\n\n\n\nFigura 2.3: Problemas de regresión y clasificación. Imagen de Prince (2023)\n\n\n\nEl modelo de a) predice el precio de una vivienda en función de características de entrada como el área en pies cuadrados y el número de dormitorios 1. Se trata de un problema de regresión, ya el modelo retorna un número real (no asigna una categoría). El modelo de la figura b) recibe la estructura química de una molécula como entrada y predice su punto de congelación y su punto de ebullición. Este es un problema de regresión multivariada, ya que la salida incluye más de un número.\nEl modelo en c) recibe como entrada una hilera de texto que contiene las calificaciones de varios aspectos a evaluar sobre una comida en un restaurante (plato principal, ensalada, sopa, postre, etc.) y predice si el resultado general es positivo o negativo. Es un problema de clasificación binaria porque el modelo asigna como salida una de dos categorías. El vector de salida contiene las probabilidades de posible valor. Los modelos en d) y e) corresponden a problemas de clasificación multiclase. Aquí, el modelo asigna el valor de salida a una de n &gt; 2 categorías. En el primer caso, la entrada es un archivo de audio y el modelo predice el género musical al que pertenece. En el segundo caso, la entrada es una imagen y el modelo predice qué objeto contiene. En cada caso, el modelo devuelve un vector de tamaño n que contiene las probabilidades de las n categorías.\nEn la Figura 2.3, los modelos de deep learning se muestran como “cajas negras” que reciben una entrada y retornan una salida, sin entrar en detalles de como se procesa la entrada. Hay muchas posibilidades para implementar estas “cajas negras”. Considere un modelo para predecir la estatura de un niño a partir de su edad, como el de la Figura 2.4. En este caso, el modelo es una ecuación que describe como la estatura promedio varía en función de la edad. Al ingresar la edad a la ecuación, retorna la estatura.\n\n\n\n\n\n\nFigura 2.4: Modelo de aprendizaje automático. Imagen de Prince (2023).\n\n\n\nEl surgimiento de la ciencia de datos está motivado por un incremento acelerado de la cantidad de datos existentes, así como de la disponibilidad de herramientas computacionales (lenguajes de programación, motores de bases de datos) y de infraestructura informática (hospedaje de datos, hospedaje de aplicaciones) para procesarlos y analizarlos. Los cambios tecnológicos han sido apoyados por un cambio cultural propiciado por movimientos como los de código abierto (open source), datos abiertos (open data), acceso abierto (open access) y ciencia abierta (open science). La ciencia abierta, que de alguna manera engloba a los otros movimientos abiertos, promueve el acceso libre a la investigación científica, incluidas las publicaciones, los datos, las metodologías y el código fuente, de manera que sean accesibles a todos los niveles de la sociedad. Un aspecto crucial de la ciencia abierta es la reproducibilidad, que garantiza que los resultados de una investigación puedan ser verificados y validados por otros investigadores.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#footnotes",
    "href": "02-introduccion-ciencia-datos.html#footnotes",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "Como ejemplo, puede revisar el problema de la estimación de precios de viviendas en Boston en Harrison & Rubinfeld (1978) (el texto completo está en https://deepblue.lib.umich.edu/bitstream/handle/2027.42/22636/0000186.pdf) y acceder a los datos correspondientes en Kaggle.↩︎",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#reproducibilidad",
    "href": "02-introduccion-ciencia-datos.html#reproducibilidad",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.3 Reproducibilidad",
    "text": "2.3 Reproducibilidad\nLa reproducibilidad es la capacidad de un ensayo o experimento de ser reproducido por otros. Más formalmente, en investigación cuantitativa, un análisis se considera reproducible si “el código fuente y los datos utilizados por un investigador para llegar a un resultado están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado” Gandrud (2020).\nLa reproducibilidad, junto con la falsabilidad, es uno de los pilares del método científico. Sin embargo, en años recientes, se ha generado una creciente preocupación debido a que muchos estudios científicos publicados fallan las pruebas de reproducibilidad, dando lugar a una crisis de reproducibilidad o replicabilidad en varias ciencias Krugman (2013).\nEl concepto de reproducibilidad es cada vez más importante debido, entre otras razones, al aumento exponencial de datos disponibles y a la aplicación de la programación de computadoras, para procesar estos datos, por parte de especialistas de muchas disciplinas.\nAlex Singleton y otros autores han identificado los siguientes retos para la reproducibilidad en ciencia de datos geoespaciales Singleton, Spielman, & Brunsdon (2016):\n\nLos datos deben ser de dominio público y estar disponibles para los investigadores.\nEl software utilizado debe ser de código abierto (open source) y estar disponible para ser revisado.\nSiempre que sea posible, los flujos de trabajo deben ser públicos y con enlaces a los datos, software y métodos de análisis, junto con la documentación necesaria.\nEl proceso de revisión por pares (peer review process) y la publicación académica deben requerir la presentación de un modelo de flujo de trabajo e idealmente la disponibilidad de los materiales necesarios para la replicación.\nEn los casos en los que la reproducibilidad total no sea posible (ej. datos sensibles), los investigadores deben esforzarse por incluir todos los aspectos que puedan de un marco de trabajo abierto.\n\nEn general, el estándar mínimo de reproducibilidad requiere que los datos y el código fuente estén disponibles para otros investigadores Peng (2011). Sin embargo, dependiendo de las circunstancias y recursos disponibles, existe todo un espectro de posibilidades, que se ilustra en la Figura 2.5.\n\n\n\n\n\n\nFigura 2.5: Espectro de reproducibilidad. Imagen de Anita Graser basada en Peng (2011).",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#herramientas-para-ciencia-de-datos",
    "href": "02-introduccion-ciencia-datos.html#herramientas-para-ciencia-de-datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.4 Herramientas para ciencia de datos",
    "text": "2.4 Herramientas para ciencia de datos\nComo se ha mencionado, la programación de computadoras es una actividad presente durante todos los procesos de ciencia de datos. Hay muchos lenguajes que pueden utilizarse en este campo. Entre los más populares, pueden mencionarse Python, R, SQL y JavaScript.\nPor otra parte, la documentación es vital durante todo el ciclo de vida de una investigación reproducible. Se recomienda utilizar mecanismos estandarizados y abiertos como el lenguaje de marcado de hipertexto (HTML, en inglés, HyperText Markup Language) o Markdown, con los cuales pueden crearse documentos mediante editores de texto simples (i.e. no se requiere de software propietario), y exportables a varios formatos (ej. LaTeX, PDF).\nPara dar mantenimiento, tanto al código fuente como a la documentación, es necesario un sistema de control de versiones como Git, el cual permite llevar el registro de los cambios en archivos y también facilita el trabajo colaborativo al reunir las modificaciones hechas por varias personas. Git es usado en varias plataformas que comparten código fuente (ej. GitHub, GitLab) y que ofrecen servicios relacionados, como hospedaje de sitios web.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "parte-ii-lenguaje-programacion-r.html",
    "href": "parte-ii-lenguaje-programacion-r.html",
    "title": "II - El lenguaje de programación R",
    "section": "",
    "text": "3 R - lenguaje de programación para análisis estadístico",
    "crumbs": [
      "II - El lenguaje de programación R"
    ]
  },
  {
    "objectID": "03-r.html",
    "href": "03-r.html",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#trabajo-previo",
    "href": "03-r.html#trabajo-previo",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "Lecturas\nGrolemund, G., & Wickham, H. (2014). Chapter 1 - Chapter 12 en Hands-On Programming with R: Write Your Own Functions And Simulations. O’Reilly Media. https://rstudio-education.github.io/hopr/",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#introducción",
    "href": "03-r.html#introducción",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "Introducción",
    "text": "Introducción\nR es un lenguaje de programación y un entorno enfocado en graficación y en análisis estadístico. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como agricultura, biomedicina, bioinformática, finanzas, hidrología, teledetección y geografía entre muchos otros.\nAlgunas de las principales características del lenguaje de programación R son:\n\nEs interpretado: las instrucciones se traducen una por una a lenguaje de máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables de un programa solo pueden tener un tipo de datos.\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\n\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\nLa Comprehensive R Archive Network (CRAN) es una red mundial distribuida de servidores que albergan el código y la documentación oficial de R y sus paquetes. Las tasks views de CRAN categorizan la funcionalidad de R de acuerdo con temáticas determinadas.\nPara programar en R, puede utilizarse una interfaz de línea de comandos, editores de código fuente (ej. Visual Studio Code) y también entornos integrados de desarrollo (IDE, en inglés Integrated Development Environment) como Jupyter o RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "href": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.1 El ambiente de desarrollo integrado RStudio",
    "text": "3.1 El ambiente de desarrollo integrado RStudio\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de Posit Cloud. La Figura 3.1 muestra la interfaz de RStudio.\n\n\n\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.\n\n\n\nAdemás de edición de código fuente, RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas.\nEjercicios\n1. Instale en su computadora:\n\nSistema base del lenguaje R.\n\nRStudio Desktop.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conceptos-fundamentales",
    "href": "03-r.html#conceptos-fundamentales",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.2 Conceptos fundamentales",
    "text": "3.2 Conceptos fundamentales\n\n3.2.1 Manejo de datos\n\n3.2.1.1 Tipos y estructuras de datos\nR maneja los datos en una gran variedad de tipos y estructuras, los cuales incluyen tipos básicos como números, caracteres y lógicos y tipos compuestos como matrices y listas que permiten manejar varios valores conjuntamente.\nUna de las herramientas fundamentales en R para el manejo y análisis de datos es el data frame. Un data frame es una estructura rectangular de filas y columnas, en la que cada fila corresponde a una observación y cada columna a una variable. Las columnas pueden ser de diferentes tipos: números, caracteres, lógicos y muchos otros. Un data frame puede verse como lo que comúmmente se conoce como una tabla de datos (ej. las de las hojas de cálculo). Los data frames permiten realizar operaciones sobre los datos como creación de subconjuntos, ordenamientos, filtrados, cálculos estadísticos (promedio, desviación estándar, mínimo, máximo, etc.) y muchas otras.\nLos tipos y estructuras de datos de R se estudiarán con más detalle en este capítulo.\n\n\n3.2.1.2 Conjuntos de datos para ejemplos y pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"iris\"\n?iris\n\n# Visualización de iris\nView(iris)\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nPapers with Code - conjuntos de datos\nGapminder\n\n\n\n\n3.2.2 Funciones\n\n3.2.2.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.2.2.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2024-ii\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n1. Obtenga la ruta de su directorio de trabajo con la función getwd() y anótela.\n2. Cambie la ruta de su directorio de trabajo con la función setwd() a cualquier otro directorio en el que tenga derechos de escritura. Verifique el cambio usando nuevamente getwd().\n3. Con la función create.file(), cree un archivo llamado hola.R y escriba ahí el programa “Hola mundo”: cat(\"Hola mundo\")\n4. Ejecute su programa con los botones Run y Source de RStudio.\n5. Cambie nuevamente su directorio de trabajo a la ruta que anotó en el paso 1. Copie ahí su programa y ejecútelo nuevamente.\n\n\n3.2.2.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), de la instalación básica de R, para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n1. Estudie la documentación de la función plot() y agregue al gráfico anterior:\n\nUn título.\n\nUn subtítulo.\n\n\n\n3.2.2.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\n3.2.3 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. También hay paquetes que contienen datos (ej. los resultados de un censo).\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\nEn el siguiente ejemplo, se instala el paquete titanic, el cual contiene datos sobre el destino de los pasajeros durante el viaje inaugural del transatlántico RMS Titanic, resumida según el estatus económico (clase), sexo, edad y supervivencia de cada pasajero.\n\n# Instalación del paquete titanic (note las comillas)\ninstall.packages(\"titanic\")\n\nSeguidamente, el paquete titanic se carga con la función library().\n\n# Carga de titanic\nlibrary(titanic)\n\n\n\n3.2.4 Visualización de datos\n\n3.2.4.1 La función View()\nEl conjunto de datos titanic_train puede observarse, con sus observaciones y variables, con la función View(), la cual permite visualizar un conjunto de datos en una tabla.\n\n# Visualización del conjunto de datos titanic_train\nView(titanic_train)\n\nEste conjunto de datos se utiliza para entrenar modelos de aprendizaje automático (machine learning) para que realicen, por ejemplo, predicciones (ej. la supervivencia o muerte de un pasajero con base en variables como edad, clase, sexo y otras). Las predicciones del modelo se evalúan con titanic_test, el conjunto de datos de evaluación.\n\n\n3.2.4.2 Funciones básicas de graficación estadística\nLa instalación básica de R, la cual incluye el paquete base y el paquete graphics, ofrece una gran variedad de funciones para elaborar gráficos estadísticos. Esta funcionalidad se enriquece gracias al aporte de paquetes elaborados por terceros, los cuales se estudiarán posteriormente en este curso. Entre los tipos de gráficos que pueden elaborarse con la instalación básica de R están los gráficos de dispersión, los gráficos de barras, los gráficos de pastel y los histogramas.\n\n3.2.4.2.1 Gráficos de barras\nUn gráfico de barras permite representar variables de un conjunto de datos mediante barras rectangulares de longitud proporcional a los valores representados. Los gráficos de barras se utilizan principalmente para representar datos que involucran variables categóricas. Permiten comparar fácilmente cantidades o números asociados a diferentes categorías. Por ejemplo, se puede usar un gráfico de barras para mostrar la cantidad de ventas de diferentes tipos de productos, la población en diferentes ciudades, o las puntuaciones obtenidas por estudiantes en diferentes materias.\nEl siguiente gráfico de barras muestra la cantidad de pasajeros por clase en titanic_train, mediante la función barplot(), una de las funciones de graficación básica de R. Esta función recibe como argumento los valores que se desea representar en las barras, por lo que antes se utiliza la función table() para generar una tabla de contingencia con las cantidades de pasajeros que viajaban en cada clase.\n\n# Cantidades de pasajeros por clase\npasajeros_por_clase &lt;- table(titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase\n## \n##   1   2   3 \n## 216 184 491\n\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height = pasajeros_por_clase,\n  main = \"Cantidad de pasajeros por clase en el Titanic\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n\n\n\n\n\n\n\n\nLa cantidad de pasajeros en cada clase puede subdividirse en fallecidos y sobrevivientes.\n\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\npasajeros_por_clase_sobrevivencia &lt;- \n  table(titanic_train$Survived, titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase_sobrevivencia\n##    \n##       1   2   3\n##   0  80  97 372\n##   1 136  87 119\n\nEl siguiente gráfico de barras apiladas muestra la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\n\n# Gráfico de barras apiladas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas. Note el uso del argumento beside.\n\n# Gráfico de barras agrupadas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n3.2.4.2.2 Gráficos de pastel\nLos gráficos de pastel se utilizan para mostrar proporciones o porcentajes, representando la composición de un todo. Son especialmente útiles para resaltar cómo se divide un conjunto en categorías, donde cada segmento del pastel (slice o “rebanada”) representa la proporción o porcentaje de esa categoría dentro del total. Por lo tanto, son más adecuados para visualizar datos categóricos o cualitativos, no para datos numéricos continuos.\nLa cantidad de pasajeros por clase en titanic_train también puede mostrarse en un gráfico de pastel, mediante la función pie de la instalación básica de R.\n\n# Gráfico de pastel por clase de pasajero\npie(\n  x = pasajeros_por_clase, \n  main = \"Distribución de pasajeros por clase en el Titanic\",\n  labels = paste(names(pasajeros_por_clase), \":\", pasajeros_por_clase)\n)\n\n\n\n\n\n\n\n\n\n\n3.2.4.2.3 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (en este caso, llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable.\nEn la instalación básica de R, los histogramas se implementan mendiante la función hist().\n\nhist(\n  x = titanic_train$Age, \n  breaks = 8,\n  main = \"Distribución de la edad de los pasajeros del Titanic\", \n  xlab = \"Edad\", \n  ylab = \"Frecuencia\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas.\nGuarde los gráficos en un archivo PDF (puede consultar Saving plots to a file with pdf(), jpeg() and png()).\n\n\n\n\n\n3.2.5 Tipos de datos\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\nR proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz. R también permite que el programador defina sus propios objetos.\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y &lt;- (o -&gt;). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\n\n# Número\nx &lt;- 10\nx\n## [1] 10\n\n# Otro número\n20 -&gt; y\ny\n## [1] 20\n\n# Hilera de caracteres\nnombre &lt;- 'Manuel'\nnombre\n## [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias &lt;- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n## [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"    \"Viernes\"  \n## [7] \"Sábado\"\n\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\nEl tipo de un objeto puede consultarse con la función typeof(). Por ejemplo:\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(nombre)\n## [1] \"character\"\ntypeof(dias)\n## [1] \"character\"\n\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\n\n3.2.5.1 Tipos básicos\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\n\n3.2.5.1.1 Números\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\n\n# Declaración de variables numéricas\nx &lt;- 5\ny &lt;- 0.5\n\n# Suma\nx + y\n## [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(x + y)\n## [1] \"double\"\n\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\n\n# Números enteros\nx &lt;- 10L\ny &lt;- as.integer(15)\n\n# Multiplicación\nx * y\n## [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"integer\"\ntypeof(x * y)\n## [1] \"integer\"\n\n\n\n3.2.5.1.2 Caracteres\nSe utilizan para representar textos. Deben estar entre comillas simples ('') o dobles (\"\").\n\n# Hileras de caracteres\nnombre &lt;- \"María\"\napellido &lt;- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n## [1] \"María Pérez\"\n\n\n\n3.2.5.1.3 Lógicos\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\n\n# Variable lógica\na &lt;- 1 &lt; 2\na\n## [1] TRUE\n\n# Variable lógica\nb &lt;- 1 &gt; 2\nb\n## [1] FALSE\n\nLas expresiones lógicas pueden combinarse con operadores como:\n\n& (Y, en inglés AND)\n| (O, en inglés OR)\n! (NO, en inglés NOT)\n\n\n# Operador lógico AND\n(1 &lt; 2) & (3 &lt; 4)\n## [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 &lt;= 10)\n## [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n## [1] TRUE\n\n\n\n3.2.5.1.4 Vectores\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\n\n3.2.5.1.4.1 Definición\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\n\n# Definición de un vector de números\nvector_numeros &lt;- c(1, 7, 32, 45, 57)\nvector_numeros\n## [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres &lt;- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n## [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia (i.e. una lista ordenada):\n\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia &lt;- 1:10\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia &lt;- -5:5\nvector_secuencia\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia &lt;- -0.5:3.7\nvector_secuencia\n## [1] -0.5  0.5  1.5  2.5  3.5\n\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\n\n# Definición de un vector de números en secuencia de 1 a 10\nvector_secuencia &lt;- seq(1, 10)\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números en secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia &lt;- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n## [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números en secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia &lt;- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n## [1] 1.500000 4.133333 6.766667 9.400000\n\n\n\n3.2.5.1.4.2 Indexación\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\n\n# Vector de nombres de países\npaises &lt;- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n## [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"\n\n# Elemento en el índice 3\npaises[3]\n## [1] \"China\"\n\nEl operador : puede utilizarse para especificar un rango de índices:\n\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n## [1] \"Francia\"   \"China\"     \"Australia\"\n\nCon la función c(), es posible especificar un conjunto de índices particulares:\n\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n## [1] \"Argentina\" \"Australia\" \"México\"\n\nLos números negativos pueden usarse para excluir índices:\n\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n## [1] \"Argentina\" \"Francia\"   \"México\"\n\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\n\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n## [1] \"Argentina\" \"Francia\"   \"Australia\"\n\n\n\n3.2.5.1.4.3 Operaciones\nEn los vectores pueden aplicarse operaciones aritméticas:\n\na &lt;- c(1, 3, 5, 7)\nb &lt;- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n## [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n## [1]  2 12 30 56\n\nY también pueden realizarse operaciones relacionales:\n\n# Comparación con el operador &lt;\na &lt; b\n## [1] TRUE TRUE TRUE TRUE\n\n\n\n\n3.2.5.1.5 Matrices\nUna matriz es una estructura bidimensional de filas y columnas.\n\n3.2.5.1.5.1 Definición\nLas matrices se definen mediante la función matrix().\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm &lt;- matrix(1:9, nrow=3, ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm &lt;- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos &lt;- c(18, 500, 25, 1000, 30, 2000)\nfilas &lt;- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas &lt;- c(\"Edad\", \"Salario\")\n\nm &lt;- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n## Laura   30    2000\n\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\n\n\n3.2.5.1.5.2 Indexación\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\n\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n## [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n##    Edad Salario \n##      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n##   Ana Mario Laura \n##   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n##    Edad Salario \n##      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n##   Ana Mario Laura \n##   500  1000  2000\n\n\n\n3.2.5.1.5.3 Operaciones\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\n\na &lt;- matrix(1:4, nrow=2, ncol=2)\na\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n\nb &lt;- matrix(5:8, nrow=2, ncol=2)\nb\n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\n# Suma de matrices\na + b\n##      [,1] [,2]\n## [1,]    6   10\n## [2,]    8   12\n\n# Multiplicación de matrices\na * b\n##      [,1] [,2]\n## [1,]    5   21\n## [2,]   12   32\n\n# Comparación de matrices con el operador &gt;\na &gt; b\n##       [,1]  [,2]\n## [1,] FALSE FALSE\n## [2,] FALSE FALSE\n\n\n\n\n\n3.2.5.2 Tipos compuestos\n\n3.2.5.2.1 Data Frames\nUn data frame es una estructura bidimensional similar a lo que comúnmente se conoce como una tabla. Sus filas corresponden a las observaciones de un conjunto de datos y sus columnas a las variables. Internamente, se componen de varios vectores, factores y/o matrices de la misma longitud. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o una tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\n\n3.2.5.2.1.1 Definición\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\n\n# Vector de nombres de países\npaises &lt;-\n  c(\"Panamá\",\n    \"Costa Rica\",\n    \"Nicaragua\",\n    \"El Salvador\",\n    \"Honduras\",\n    \"Guatemala\",\n    \"Belice\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones &lt;- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises &lt;- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       4.1\n## 2  Costa Rica       5.0\n## 3   Nicaragua       6.2\n## 4 El Salvador       6.4\n## 5    Honduras       9.2\n## 6   Guatemala      16.9\n## 7      Belice       0.3\n\n\n\n3.2.5.2.1.2 Indexación\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\n\n# Fila 1\npoblaciones_paises[1, ]\n##     pais poblacion\n## 1 Panamá       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n##       pais poblacion\n## 1   Panamá       4.1\n## 5 Honduras       9.2\n## 7   Belice       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n## [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n## [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n## [1] 4.1 5.0 6.2 6.4\n\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\n\n# Columna de nombres de países\npoblaciones_paises$pais\n## [1] \"Panamá\"      \"Costa Rica\"  \"Nicaragua\"   \"El Salvador\" \"Honduras\"   \n## [6] \"Guatemala\"   \"Belice\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises_2 &lt;- poblaciones_paises # copia del dataframe original\npoblaciones_paises_2$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises_2\n##          pais poblacion\n## 1      Panamá       8.2\n## 2  Costa Rica      10.0\n## 3   Nicaragua      12.4\n## 4 El Salvador      12.8\n## 5    Honduras      18.4\n## 6   Guatemala      33.8\n## 7      Belice       0.6\n\nLa notación de paréntesis cuadrados ([]) y el signo de dólar ($) también permite crear subconjuntos con base en expresiones lógicas.\n\n# Ejemplos de uso de la notación $\n\n# Países con población mayor a 6 millones de habitantes\npoblaciones_paises[poblaciones_paises$poblacion &gt; 6,]\n\n         pais poblacion\n3   Nicaragua       6.2\n4 El Salvador       6.4\n5    Honduras       9.2\n6   Guatemala      16.9\n\n\n\n\n3.2.5.2.1.3 Operaciones\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\n\n# Lectura de archivo CSV ubicado en la Web\ncovid &lt;-\n  read.csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv\"\n  )\n\n# Despliegue de los datos del data frame\ncovid\n##          pais fallecidos recuperados activos positivos\n## 1      Panamá       6198      351949    3845    361992\n## 2  Costa Rica       3125      199779   32370    235274\n## 3   Guatemala       7345      194075   16725    218145\n## 4    Honduras       4981       77020  121358    203359\n## 5 El Salvador       2089       64208    1864     68161\n## 6      Belice        318       12164     114     12596\n## 7   Nicaragua        181        5212      57      5450\n\nLa función str() despliega la estructura de un data frame u otro objeto R.\n\n# Estructura del data frame\nstr(poblaciones_paises)\n\n'data.frame':   7 obs. of  2 variables:\n $ pais     : chr  \"Panamá\" \"Costa Rica\" \"Nicaragua\" \"El Salvador\" ...\n $ poblacion: num  4.1 5 6.2 6.4 9.2 16.9 0.3\n\n\nLa función summary() proporciona un resumen de los contenidos de un data frame:\n\n# Resumen de los contenidos del data frame\nsummary(poblaciones_paises)\n\n     pais             poblacion     \n Length:7           Min.   : 0.300  \n Class :character   1st Qu.: 4.550  \n Mode  :character   Median : 6.200  \n                    Mean   : 6.871  \n                    3rd Qu.: 7.800  \n                    Max.   :16.900  \n\n\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\n\n# Vista de los casos de COVID-19\nView(covid, \"Casos de COVID-19 en Centramérica\")\n\n\n\n\n3.2.5.2.2 Factores\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\n\n3.2.5.2.2.1 Definición\nUn factor se crea con la función factor().\n\n# Factor de valores de sexo\nsexo &lt;- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\n\n\n\n3.2.5.2.2.2 Operaciones\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\n\n# Etiquetas de los niveles\nlevels(sexo)\n## [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n## [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n## sexo\n##  Femenino Masculino \n##         2         2\n\n\n\n\n\n3.2.5.3 Otros\n\n3.2.5.3.1 Fechas\nLas fechas se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, una fecha en R se almacena como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\n\n3.2.5.3.1.1 Operaciones\nLa función Sys.Date() retorna la fecha actual.\n\n# Fecha actual\nfecha_actual &lt;- Sys.Date()\nfecha_actual\n## [1] \"2024-08-29\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n## [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n## [1] \"Date\"\n\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato. El formato que se usa por defecto (y el recomendado) es el que corresponde a la norma ISO 8601 (ej. 2023-12-03), pero pueden emplearse otros también.\n\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 &lt;- \"2020-01-01\"\nfecha_01 &lt;- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n\n[1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 &lt;- \"31/01/2020\"\nfecha_02 &lt;- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n\n[1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n\nTime difference of 30 days\n\n\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers.\n\n\n\n\n\n3.2.6 Definición de funciones\nAdemás de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.\nToda función tiene tres partes esenciales:\n\nUn nombre.\nUn conjunto de argumentos.\nUn conjunto de líneas de código, también llamado el cuerpo de la función.\n\nPara programar una función, debe definirse cada una de esas partes por medio de la palabra reservada function function().\nPor ejemplo, la siguiente función calcula la nota final de un curso con base en los argumentos correspondientes a los promedios de exámenes, proyectos y tareas.\n\n# Función que calcula la nota final de un curso\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos,\n                       promedio_tareas) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  return(factor_examenes + factor_proyectos + factor_tareas)\n}\n\nLa función return() es la que define el valor de retorno de la función. Si no se incluye, la función retorna la última expresión evaluada.\nAhora que está definida, la función nota_final() puede ser “llamada”, con diferentes argumentos:\n\n# Si ni se incluyen los nombres de los argumentos, \n# la función asume que se ingresan en el mismo orden en el que fueron definidos\nnota_final(100, 50, 0)\n## [1] 70\n\n# El uso de los nombres de argumentos \n# permite modificar su orden\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\n## [1] 70\n\nSi se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.\nSeguidamente, la función nota_final() se redefine asignando valores por defecto a algunos de los argumentos:\n\n# Redefinición de la función nota final,\n# con valores por defecto para los argumentos\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos = 0,\n                       promedio_tareas = 0) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  # Al no llamarse a la función return(), se retorna la última expresión:\n  factor_examenes + factor_proyectos + factor_tareas\n}\n\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\n## [1] 70\n\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\nnota_final(100, promedio_proyectos = 50)\n## [1] 70\n\nEjercicios\n1. Defina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.\n2. Defina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.\n3. Defina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros).\n\n\n3.2.7 Condicionales\nLas sentencias condicionales evalúan una expresión lógica (i.e. condición) y ejecutan, o no, un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.\nLos condicionales en R se implementa mediante la sentencia if y sus cláusulas else y else if.\n\n3.2.7.1 La sentencia if\nLa sentencia if evalúa una condición (i.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.\n\n# Sintaxis de la sentencia if\nif (condicion) {\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\n}\n\nPor ejemplo:\n\n# Edad de una persona\nedad &lt;- 25\n\n# Se utiliza la sentencia if para determinar \n# si la persona es adulta\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n}\n## [1] \"Adulto\"\n\nYa sea que se ejecute o no el bloque del if, el programa continúa con las instrucciones que siguen al bloque, si las hay.\n\n\n3.2.7.2 La cláusula else\nUna sentencia if puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa. Por ejemplo:\n\nedad &lt;- 15\n\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n} else {\n  print(\"Menor\")\n}\n\n[1] \"Menor\"\n\n\n\n\n3.2.7.3 La cláusula else if\nUna sentencia if también puede ir seguida de una o varias cláusulas else if, las cuales evalúan condiciones adicionales.\n\nedad &lt;- 70\n\nif (edad &lt; 18) {\n  print(\"Menor\")\n} else if (edad &lt; 65) {\n  print(\"Adulto\")\n} else {\n  print(\"Adulto mayor\")\n}\n\n[1] \"Adulto mayor\"\n\n\nLas cláusulas else if deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else if como la cláusula else son opcionales.\nEjercicios\n1. Defina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente a la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de masa corporal - Wikipedia.\n\n\n\n3.2.8 Ciclos\nLos ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con sentencias que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.\nLos ciclos en R se implementan mediante las sentencias for, while y repeat, en combinación con las sentencias break y next.\nR provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que no es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.\n\n3.2.8.1 La sentencia for\nLa sentencia for repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración (i.e. cada “vuelta” del ciclo), el valor del elemento que está siendo procesado se almacena en una variable.\n\n# Sintaxis de la sentencia for\nfor (variable in vector) {\n  # bloque de instrucciones\n}\n\nPor ejemplo, el siguiente bloque de código utiliza un ciclo de tipo for para recorrer un vector de nombres e imprimir un saludo para cada uno.\n\n# Vector con nombres de personas\nvector_nombres &lt;- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Recorrido del vector\nfor (nombre in vector_nombres) {\n  cat(\"Hola\", nombre, \"\\n\")\n}\n## Hola Andrés \n## Hola Beatriz \n## Hola Carlos \n## Hola Marta \n## Hola Pedro \n## Hola Sara\n\nEn el siguiente ejemplo, se utiliza otro ciclo for para recorrer un vector de números y sumar sus elementos.\n\n# Vector de números\nvector_numeros &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\n\n# Variable para la suma de los números\nsuma &lt;- 0\n\n# Recorrido del vector\nfor (x in vector_numeros) {\n  suma &lt;- suma + x\n}\n\n# Impresión de la suma\ncat(\"Suma:\", suma)\n## Suma: 140.95\n\nSeguidamente, se utiliza dos for “anidados” para sumar los elementos de cada una de las columnas de una matriz.\n\n# Matriz de números\nmatriz_numeros &lt;- matrix(1:12, nrow=3, ncol=4)\nmatriz_numeros\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\n# Ciclo externo para recorrer las columnas de la matriz\nfor (j in 1:ncol(matriz_numeros)) {\n  suma_columna &lt;- 0\n  # Ciclo interno para recorrer las elementos de cada columna\n  for (i in 1:nrow(matriz_numeros)) {\n    suma_columna &lt;- suma_columna + matriz_numeros[i, j]\n  }\n  print(suma_columna)\n}\n## [1] 6\n## [1] 15\n## [1] 24\n## [1] 33\n\nEjercicios\n1. Utilice un ciclo for para recorrer el vector vector_numeros y calcular el promedio de sus elementos.\n2. Utilice dos ciclos for anidados para recorrer la matriz vector_numeros y calcular el promedio de cada una de sus columnas.\n\n\n3.2.8.2 La sentencia while\nLa sentencia while evalúa una condición (i.e. una expresión lógica) en cada iteración de un ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.\n\n# Sintaxis de la sentencia while\nwhile (condicion) {\n  # bloque de instrucciones \n}\n\nEn el siguiente ejemplo, se utiliza un ciclo while para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta &lt;- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\nwhile (leer_respuesta() != \"42\") {   \n  print(\"¡Su respuesta es incorrecta!\")\n}\n\nEjercicios\n1. Utilice un ciclo while para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#recursos-de-interés",
    "href": "03-r.html#recursos-de-interés",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.3 Recursos de interés",
    "text": "3.3 Recursos de interés\nFind Open Datasets and Machine Learning Projects | Kaggle. (s. f.). Recuperado 24 de abril de 2022, de https://www.kaggle.com/datasets\nIndicators | Data. (s.f.). Recuperado 11 de septiembre de 2022, de https://data.worldbank.org/indicator\nNewest «r» Questions. (s. f.). Stack Overflow. Recuperado 24 de abril de 2022, de https://stackoverflow.com/questions/tagged/r\nPapers with Code—Machine Learning Datasets. (s.f.). Recuperado 11 de septiembre de 2022, de https://paperswithcode.com/datasets\nR Language Definition. (s. f.). Recuperado 24 de abril de 2022, de https://cran.r-project.org/doc/manuals/r-release/R-lang.html\nR Package Documentation. (s.f.). Recuperado 11 de septiembre de 2022, de https://rdrr.io/\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "href": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "title": "III - Herramientas para investigación reproducible y desarrollo colaborativo",
    "section": "",
    "text": "5 Reproducibilidad\n6 Markdown - lenguaje de marcado\n7 Git - sistema de control de versiones\n8 Quarto - sistema de publicación técnica y científica",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo"
    ]
  },
  {
    "objectID": "04-markdown.html",
    "href": "04-markdown.html",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#trabajo-previo",
    "href": "04-markdown.html#trabajo-previo",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Lecturas\nQuarto - Markdown Basics. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/authoring/markdown-basics.html\n\n\nTutoriales\nMarkdown Tutorial. (s.f.). Recuperado el 1 de marzo de 2024, de https://www.markdowntutorial.com/",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#introducción",
    "href": "04-markdown.html#introducción",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "Introducción",
    "text": "Introducción\nMarkdown es un lenguaje de marcado, creado en 2004 por John Gruber y Aaron Swartz. Las “marcas” se utilizan para especificar aspectos de la estructura (ej. títulos, encabezados), estilo (ej. negritas, itálicas) y semántica de un documento. Markdown se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcado (ej. Lenguaje de Marcado de Hipertexto o HTML), por lo que se considera un lenguaje de marcado ligero.\nLos documentos escritos en Markdown pueden exportarse a una gran variedad de formatos (ej. HTML, DOC, PDF, LaTex) para ser usados en libros, presentaciones o páginas web, entre otros fines.\nLas variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:\n\nR Markdown: para el lenguaje R.\nQuarto: es la “siguiente generación” de R Markdown, con soporte para más lenguajes de programación (Python, Julia, Observable, R) y motores de procesamiento (Jupyter, Knitr), entre otras mejoras. Más que una variación de Markdown es un sistema de publicación de documentos técnicos y científicos que utiliza Markdown.\nPython Markdown: para el lenguaje Python.\nGitHub Flavored Markdown: para la plataforma GitHub.\nPandoc’s Markdown: para el programa Pandoc de conversión entre formatos.\n\nPuede encontrarse una lista más extensa de variaciones de Markdown en Markdown Flavors.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#ejemplo-de-documento",
    "href": "04-markdown.html#ejemplo-de-documento",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.1 Ejemplo de documento",
    "text": "4.1 Ejemplo de documento\nEl siguiente es un ejemplo de documento Markdown. Se muestra primero la sintaxis del documento y luego la manera en la que se visualiza.\n\n4.1.1 Sintaxis\nLa sintaxis del documento incluye marcas para un encabezado, texto en negrita, texto en itálica, hipervínculos y una imagen.\n\n\n### Los satélites galileanos\n\nSe llaman **satélites galileanos** los cuatro satélites de\n[Júpiter](https://es.wikipedia.org/wiki/J%C3%BApiter_(planeta))\ndescubiertos en 1610 por el astrónomo italiano\n[Galileo Galilei](https://es.wikipedia.org/wiki/Galileo_Galilei) (1564 - 1642): \n*Ío*, *Europa*, *Ganimedes* y *Calisto*. \nSon los más grandes de los satélites de Júpiter, \nsiendo visibles incluso con telescopios de baja potencia.\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n**Figura 1**. Los cuatro satélites galileanos, \nen una composición que compara sus tamaños con el tamaño de Júpiter. \nEn orden descendente, son *Ío*, *Europa*, *Ganimedes* y *Calisto*.\n\n\n\n\n4.1.2 Visualización\n\n\n\nLos satélites galileanos\nSe llaman satélites galileanos los cuatro satélites de Júpiter descubiertos en 1610 por el astrónomo italiano Galileo Galilei (1564 - 1642): Ío, Europa, Ganimedes y Calisto. Son los más grandes de los satélites de Júpiter, siendo visibles incluso con telescopios de baja potencia.\n\nFigura 1. Los cuatro satélites galileanos, en una composición que compara sus tamaños con el tamaño de Júpiter. En orden descendente, son Ío, Europa, Ganimedes y Calisto.\n\nEl contenido de este ejemplo está basado en Satélite galileano - Wikipedia, la enciclopedia libre.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#herramientas-para-escritura-de-documentos",
    "href": "04-markdown.html#herramientas-para-escritura-de-documentos",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.5 Herramientas para escritura de documentos",
    "text": "4.5 Herramientas para escritura de documentos\nMarkdown se escribe en “texto simple o plano” (i.e. texto sin formato, compuesto únicamente por caracteres que son legibles por humanos), por lo que puede escribirse con cualquier editor de texto. Se recomienda el uso de editores orientados a programación, también llamados editores de código fuente, los cuales proporcionan facilidades para el programador, como coloración de palabras clave, sangrado y autocompletado, entre otras.\nTambién pueden utilizarse Entornos Integrados de Desarrollo o IDE, los cuales son aplicaciones informáticas que proporcionan servicios integrales para facilitarle al programador el desarrollo de software. Además de un editor de código fuente, un IDE incluye funciones para depuración (i.e. identificación de errores), interpretación y compilación de programas, entre otras.\nAlgunos de los editores de código fuente o IDE recomendados para Markdown son:\n\nVisual Studio Code: editor de código fuente muy popular y de código abierto. Puede editar código de múltiples lenguajes de programación y sintaxis asociadas\nRStudio: IDE para desarrollo en el lenguaje de programación R, el cual también puede manejar código en otros lenguajes de programación y sintaxis.\n\nNo se recomienda el uso de procesadores de texto (ej. Microsoft Word, Libre Office Writer), debido a que introducen caracteres especiales que no son reconocidos por Markdown.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#sintaxis",
    "href": "04-markdown.html#sintaxis",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.6 Sintaxis",
    "text": "4.6 Sintaxis\nEn esta sección, se muestran los principales elementos de sintaxis de Markdown y sus salidas.\n\n\n4.6.1 Encabezados\nHay seis niveles de encabezados en Markdown, siendo el nivel 1 el de letras más grandes y el 6 el de letras más pequeñas. Se especifican mediante símbolos de numeral (#) antes del texto del encabezado (note el espacio entre el último signo de numeral y el inicio del texto).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n# Encabezado de nivel 1\n\n\n\nEncabezado de nivel 1\n\n\n\n\n\n## Encabezado de nivel 2\n\n\n\nEncabezado de nivel 2\n\n\n\n\n\n### Encabezado de nivel 3\n\n\n\nEncabezado de nivel 3\n\n\n\n\n\n#### Encabezado de nivel 4\n\n\n\nEncabezado de nivel 4\n\n\n\n\n\n##### Encabezado de nivel 5\n\n\n\nEncabezado de nivel 5\n\n\n\n\n\n###### Encabezado de nivel 6\n\n\n\nEncabezado de nivel 6\n\n\n\n\nPara los encabezados de nivel 1 y nivel 2, existe una sintaxis alterna, con símbolos de igual (=====) o guiones (-----) bajo el texto del encabezado.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nOtro encabezado de nivel 1 ==========================\n\n\n\n\nOtro encabezado de nivel 1\n\n\n\n\n\nOtro encabezado de nivel 2 --------------------------\n\n\n\nOtro encabezado de nivel 2\n\n\n\n\n\n\n4.6.2 Párrafos\nLos párrafos deben separarse mediante (al menos) una línea en blanco. Un simple cambio de línea no generará un nuevo párrafo.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\n\n\n\n4.6.3 Negrita\nHay dos sintaxis para especificar texto en negrita: con dos asteriscos (**) o con dos guiones bajos (__), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n**Texto en negrita**\n\n\nTexto en negrita\n\n\n\n\n__Otro texto en negrita__\n\n\nOtro texto en negrita\n\n\n\n\n\n4.6.4 Itálica\nHay dos sintaxis para especificar texto en itálica: con un asterisco (*) o con un guión bajo (_), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n*Texto en itálica*\n\n\nTexto en itálica\n\n\n\n\n_Otro texto en itálica_\n\n\nOtro texto en itálica\n\n\n\n\n\n4.6.5 Citas textuales\nSe especifican con un símbolo de “mayor que” (&gt;) antes de cada línea.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n&gt; *And on the pedestal these words appear:* &gt; *\"My name is Ozymandias, king of kings:* &gt; *Look on my works, ye Mighty, and despair!\"* *Percy Bysshe Shelley, \"Ozymandias\" (1818)*\n\n\n\n “And on the pedestal these words appear:”My name is Ozymandias, king of kings: Look on my works, ye Mighty, and despair!“ \n\nPercy Bysshe Shelley, “Ozymandias” (1818)\n\n\n\n\n\n4.6.6 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento al que conduce el enlace.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n[Proyecto Gutenberg](https://www.gutenberg.org/)\n\n\nProyecto Gutenberg\n\n\n\n\n\n4.6.7 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n![Imagen local](img/Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n![Imagen remota](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n\n4.6.8 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento.\n2. Segundo elemento.\n3. Tercer elemento.\n\n\n\n\nPrimer elemento.\nSegundo elemento.\nTercer elemento.\n\n\n\n\n\n\n4.6.9 Listas no numeradas\nSe definen con guiones (-) o asteriscos (*) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento.\n- Otro elemento.\n- Otro elemento más.\n\n\n\n\nUn elemento.\n\nOtro elemento.\n\nOtro elemento más.\n\n\n\n\n\n\n\n4.6.10 Notación matemática\nLas expresiones en notación matemática (ej. ecuaciones) se escriben con base en la sintaxis de LaTeX. Se delimitan (al inicio y al final) con:\n\nUn símbolo de dólar ($), para ecuaciones dentro de un renglón (inline math).\nDos símbolos de dólar ($$), para ecuaciones en su propio bloque (display math).\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEquivalencia entre masa y energía: $E = mc^{2}$\n\n\n\nEquivalencia entre masa y energía: \\(E = mc^{2}\\)\n\n\n\n\nEquivalencia entre masa y energía: $$E = mc^{2}$$\n\n\nEquivalencia entre masa y energía:\n\\[E = mc^{2}\\]\n\n\n\nPara más detalles sobre la sintaxis de las expresiones matemáticas, se recomienda consultar:\n\nWriting mathematical expressions - GitHub Docs\nLaTeX/Mathematics",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#ejercicios",
    "href": "04-markdown.html#ejercicios",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.3 Ejercicios",
    "text": "4.3 Ejercicios\n\nCon RStudio, cree un documento Markdown llamado README.md y escriba en este un breve curriculum académico o profesional.\n\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.\nPuede usar información ficticia (no incluya datos confidenciales o sensibles).\nEspecifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y no utilice imágenes para las que no tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).\nAsegúrese de utilizar los siguientes elementos de sintaxis Markdown:\n\nEncabezados de varios niveles.\nNegritas e itálicas.\nListas.\nEnlaces a sitios web.\nImágenes (al menos una local y una remota).",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#recursos-de-interés",
    "href": "04-markdown.html#recursos-de-interés",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.4 Recursos de interés",
    "text": "4.4 Recursos de interés\nDaring Fireball: Markdown. (s. f.). Recuperado 25 de marzo de 2023, de https://daringfireball.net/projects/markdown/\nLaTeX/Mathematics—Wikibooks, open books for an open world. (s. f.). Recuperado 25 de marzo de 2023, de https://en.wikibooks.org/wiki/LaTeX/Mathematics\nMarkdown Guide. (s. f.). Recuperado 10 de abril de 2022, de https://www.markdownguide.org/\nWriting mathematical expressions. (s. f.). GitHub Docs. Recuperado 25 de marzo de 2023, de https://ghdocs-prod.azurewebsites.net/en/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#sintaxis-1",
    "href": "04-markdown.html#sintaxis-1",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.2 Sintaxis",
    "text": "4.2 Sintaxis\nEn esta sección, se muestran los principales elementos de sintaxis de Markdown y sus salidas.\n\n\n4.2.1 Encabezados\nHay seis niveles de encabezados en Markdown, siendo el nivel 1 el de letras más grandes y el 6 el de letras más pequeñas. Se especifican mediante símbolos de numeral (#) antes del texto del encabezado (note el espacio entre el último signo de numeral y el inicio del texto).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n# Encabezado de nivel 1\n\n\n\nEncabezado de nivel 1\n\n\n\n\n\n## Encabezado de nivel 2\n\n\n\nEncabezado de nivel 2\n\n\n\n\n\n### Encabezado de nivel 3\n\n\n\nEncabezado de nivel 3\n\n\n\n\n\n#### Encabezado de nivel 4\n\n\n\nEncabezado de nivel 4\n\n\n\n\n\n##### Encabezado de nivel 5\n\n\n\nEncabezado de nivel 5\n\n\n\n\n\n###### Encabezado de nivel 6\n\n\n\nEncabezado de nivel 6\n\n\n\n\nPara los encabezados de nivel 1 y nivel 2, existe una sintaxis alterna, con símbolos de igual (=====) o guiones (-----) bajo el texto del encabezado.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nOtro encabezado de nivel 1 ==========================\n\n\n\n\nOtro encabezado de nivel 1\n\n\n\n\n\nOtro encabezado de nivel 2 --------------------------\n\n\n\nOtro encabezado de nivel 2\n\n\n\n\n\n\n4.2.2 Párrafos\nLos párrafos deben separarse mediante (al menos) una línea en blanco.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\n\n\n\n4.2.3 Cambios de línea\nSi se requiere un cambio de línea sin una línea en blanco entre párrafos, pueden agregarse dos espacios en blanco al final de la línea () o también un espacio y una barra invertida (\\).\n\n\n4.2.4 Texto en negrita\nHay dos sintaxis para especificar texto en negrita: con dos asteriscos (**) o con dos guiones bajos (__), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n**Texto en negrita**\n\n\nTexto en negrita\n\n\n\n\n__Otro texto en negrita__\n\n\nOtro texto en negrita\n\n\n\n\n\n4.2.5 Texto en itálica\nHay dos sintaxis para especificar texto en itálica: con un asterisco (*) o con un guión bajo (_), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n*Texto en itálica*\n\n\nTexto en itálica\n\n\n\n\n_Otro texto en itálica_\n\n\nOtro texto en itálica\n\n\n\n\n\n4.2.6 Texto tachado\nEl texto tachado se especifica con dos guiones (--) antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n--Texto tachado--\n\n\nTexto tachado\n\n\n\n\n\n4.2.7 Superíndices y subíndices\nUn superíndice se especifica con un acento circunflejo (^) antes y después del texto que se desea mostrar como superíndice. Un subíndice se especifica con un guión (-) antes y después del texto que se desea mostrar como subíndice.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nsuperíndice^2^\n\n\nsuperíndice2\n\n\n\n\nsubíndice-2-\n\n\nsubíndice2\n\n\n\n\n\n4.2.8 Líneas horizontales\nTres o más asteriscos (***) generan una línea horizontal:\n***\n\nTambién puede generarse con tres o más guiones (---):\n---\n\n\n\n4.2.9 Citas textuales\nSe especifican con un símbolo de “mayor que” (&gt;) antes de cada línea.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n&gt; *And on the pedestal these words appear:*\n&gt; *\"My name is Ozymandias, king of kings:*\n&gt; *Look on my works, ye Mighty, and despair!\"*\nPercy Bysshe Shelley, \"Ozymandias\" (1818)\n\n\n\n And on the pedestal these words appear: “My name is Ozymandias, king of kings: Look on my works, ye Mighty, and despair!” \n\nPercy Bysshe Shelley, “Ozymandias” (1818)\n\n\n\n\n\n4.2.10 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento al que conduce el enlace.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n[Proyecto Gutenberg](https://www.gutenberg.org/)\n\n\nProyecto Gutenberg\n\n\n\n\n\n4.2.11 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota. Una imagen local se encuentra en la misma computadora en la que está el documento que la referencia, mientras que una imagen remota se encuentra en otra computadora a la que se accede mediante un protocolo de redes como el Protocolo de transferencia de hipertexto (HTTP).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n![Imagen local](img/Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n![Imagen remota](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\nMarkdown no cuenta con sintaxis para especificar el tamaño de una imagen, pero esto puede lograrse con el Lenguaje de marcado de hipertexto (HTML, HyperText Markup Language), su elemento img y sus atributos height y width, los cuales especifican la altura y el ancho de una imagen (las unidades por defecto son pixeles).\nPor ejemplo, la expresión HTML:\n&lt;img src=\"img/Jupiter_and_the_Galilean_Satellites.jpg\" height=\"100\" alt=\"Imagen local\"&gt;\ngenera como salida una imagen de 100 pixeles de altura:\n\nSi se usa solo el atributo height, width se ajusta automáticamente y viceversa.\n\n\n4.2.12 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento.\n2. Segundo elemento.\n3. Tercer elemento.\n\n\n\n\nPrimer elemento.\nSegundo elemento.\nTercer elemento.\n\n\n\n\nLas listas numeradas pueden anidarse para mostrar la información de una forma jerárquica. Para crear un nivel de anidación, deben usarse sangrías con una cantidad de espacios consistente en toda la lista. La numeración se ordena automáticamente (incluso si hay errores).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento\n            1. Elemento anidado\n            2. Elemento anidado\n2. Segundo elemento\n            1. Elemento anidado\n            2. Elemento anidado\n3. Tercer elemento\n            1. Elemento anidado\n            2. Elemento anidado\n\n\n\n\nPrimer elemento\n\nElemento anidado\nElemento anidado\n\nSegundo elemento\n\nElemento anidado\nElemento anidado\n\nTercer elemento\n\nElemento anidado\nElemento anidado\n\n\n\n\n\n\n\n4.2.13 Listas no numeradas\nSe definen con guiones (-), asteriscos (*) o signos de adición (+) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento\n- Otro elemento\n- Otro elemento más\n\n\n\n\nUn elemento\n\nOtro elemento\n\nOtro elemento más\n\n\n\n\n\nLas listas no numeradas también pueden anidarse. Debe utilizarse un mínimo de dos espacios en los elementos anidados.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento\n            + Elemento anidado\n            + Elemento anidado\n- Otro elemento\n            + Elemento anidado\n            + Elemento anidado\n- Otro elemento más\n            + Elemento anidado\n            + Elemento anidado\n\n\n\n\nUn elemento\n\nElemento anidado\nElemento anidado\n\nOtro elemento\n\nElemento anidado\nElemento anidado\n\nOtro elemento más\n\nElemento anidado\nElemento anidado\n\n\n\n\n\nLas listas numeradas y las no numeradas pueden intercalarse.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento\n            - Elemento anidado\n            - Elemento anidado\n2. Segundo elemento\n            - Elemento anidado\n            - Elemento anidado\n3. Tercer elemento\n            - Elemento anidado\n            - Elemento anidado\n\n\n\n\nPrimer elemento\n\nElemento anidado\nElemento anidado\n\nSegundo elemento\n\nElemento anidado\nElemento anidado\n\nTercer elemento\n\nElemento anidado\nElemento anidado\n\n\n\n\n\n\n\n4.2.14 Notación matemática\nLas expresiones en notación matemática (ej. ecuaciones) se escriben con base en la sintaxis de LaTeX. Se delimitan (al inicio y al final) con:\n\nUn símbolo de dólar ($), para ecuaciones dentro de un renglón (inline math).\nDos símbolos de dólar ($$), para ecuaciones en su propio bloque (display math).\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEquivalencia entre masa y energía: $E = mc^{2}$\n\n\n\nEquivalencia entre masa y energía: \\(E = mc^{2}\\)\n\n\n\n\nEquivalencia entre masa y energía: $$E = mc^{2}$$\n\n\nEquivalencia entre masa y energía:\n\\[E = mc^{2}\\]\n\n\n\nPara más detalles sobre la sintaxis de las expresiones matemáticas, se recomienda consultar:\n\nWriting mathematical expressions - GitHub Docs\nLaTeX/Mathematics\n\n\n\n4.2.15 Bloques de código fuente\nLos documentos Markdown pueden contener bloques de código fuente, ya sea incrustados en una línea de texto (inline) o en líneas separadas.\n\n4.2.15.1 Bloques en línea\nPara mostrar fragmentos cortos de código en una sola línea dentro del texto, se usa una sola comilla invertida o backtick para delimitar el código.\nPor ejemplo, la sintaxis:\nEste es un fragmento de código en línea: `x = 10`\ngenera:\nEste es un fragmento de código en línea: x = 10\n\n\n4.2.15.2 Bloques multilínea\nPara fragmentos de código de múltiples líneas, se utilizan tres comillas invertidas o una sangría de cuatro espacios al inicio de cada línea.\nEl siguiente es un ejemplo de bloque de código delimitado con comillas invertidas (la forma más usada):\n\n```\nfunction sumar(a, b) {\n  return a + b;\n}\n```\n\nSe visualiza como:\nfunction sumar(a, b) {\n  return a + b;\n}\nSi el código es de un lenguaje específico, puede indicarse para resaltar (y colorear) la sintaxis. Por ejemplo, para un bloque de código en R, se escribe r después de las tres comillas invertidas.\nSintaxis de código en R:\n\n```r\n# Gráfico de dispersón del conjunto de datos cars con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n```\n\nVisualización de código en R:\n# Gráfico de dispersón del conjunto de datos cars con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\nEl uso de resaltado de sintaxis con bloques de código lo hace más fácil de leer y comprender. El resultado (colores, fuentes de texto, etc.) de sintaxis depende de la plataforma o editor de Markdown que se utilice. Plataformas como GitHub y algunos editores soportan muchos lenguajes, mientras que otros pueden no reconocer todos.\nPara más información sobre el uso de bloques de código en documentos Markdown, se recomienda consultar:\n\nCreating and highlighting code blocks\nThe languages YAML file\nMarkdown Code Block: Including Code In .md Files - Markdown Land\n\nNótese que los bloques de código en un documento Markdown normal (con extensión .md) no se ejecutan, solo se muestran. Sin embargo, hay sistemas como Quarto y Jupyter Notebooks que permiten combinar narrativa em Markdown con bloques de código ejecutables.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "05-quarto.html",
    "href": "05-quarto.html",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#trabajo-previo",
    "href": "05-quarto.html#trabajo-previo",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Lecturas\nQuarto - Tutorial: Hello, Quarto. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/get-started/hello/rstudio.html",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#introducción",
    "href": "05-quarto.html#introducción",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "Introducción",
    "text": "Introducción\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Entre sus principales capacidades están:\n\nCrear contenido dinámico con los lenguajes R, Python, Julia y Observable.\nCrear documentos Markdown de texto plano o cuadernos de notas de Jupyter.\nPublicar artículos académicos, reportes, presentaciones, sitios web, blogs y libros en HTML, PDF, MS Word, ePub y otros formatos.\nCrear contenido científico, incluyendo ecuaciones, citas bibliográficas, referencias cruzadas, figuras y otros elementos.\n\nQuarto es la siguiente generación de R Markdown, un formato que permite insertar código en R, y sus salidas, en documentos escritos en Markdown. R Markdown fue introducido por Yihui Xie en 2012, junto con el paquete knitr, cuyo propósito es facilitar la investigación reproducible en R a través de la programación literaria (literate programming), un paradigma de programación propuesto por Donald Knuth en 1984.\nLos programas “literarios” (o “letrados”) están escritos como una exposición lógica en un lenguaje humano similar a la explicación de las fórmulas y ecuaciones empleadas para representar y resolver un problema en un texto de física o de matemáticas. En estos programas, se describe el análisis del problema, su solución y su implementación, intercalando código fuente entre los párrafos (y otros contenidos como imágenes, tablas, gráficos estadísticos y mapas), de forma similar a como en los textos de matemáticas se intercalan las fórmulas y las ecuaciones. La programación literaria puede mejorar enormemente un programa, ya que permite documentar ampliamente en qué consiste el problema a resolver, cómo se resuelve, cómo y por qué se adoptó cierto diseño, cómo se optimizó y cómo se implementó en un lenguaje de programación.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#anatomía-de-un-documento-quarto",
    "href": "05-quarto.html#anatomía-de-un-documento-quarto",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.1 Anatomía de un documento Quarto",
    "text": "5.1 Anatomía de un documento Quarto\nUn documento Quarto tiene tres tipos de contenido:\n\nMetadatos en YAML.\nNarrativa en Markdown.\nBloques de código fuente.\n\n\n5.1.1 Metadatos en YAML\nTodo documento Quarto inicia con un encabezado en la sintaxis YAML (YAML Ain’t Markup Language), el cual contiene metadatos del documento como el título, el autor, la fecha de creación, el formato de salida y la estructura de la tabla de contenidos, entre muchos otros.\nUn encabezado YAML comienza y termina con tres guiones (---) y contiene un conjunto de campos y valores de la forma:\n---\ncampo01: valor01\ncampo02: valor02\ncampo0n: valor0n\n---\nPor ejemplo, un encabezado YAML típico puede ser el siguiente:\n---\ntitle: Mi primer documento Quarto\nformat:\n  html:\n    toc: true\n    toc_float: true\n---\nLos campos del encabezado que dependen de otros campos se anidan con sangrías de dos espacios.\nLos elementos de metadatos que pueden especificarse en el encabezado, pueden variar de acuerdo al formato de salida, como puede verse en los siguientes enlaces:\n\nElementos de metadatos para HTML\nElementos de metadatos para PDF\nElementos metadatos para MS Word\n\nExisten elementos de metadatos para muchos otros formatos de salida (OpenOffice, ePub, presentaciones, wikis, etc.), como puede apreciarse en la Referencia de Quarto.\n\n\n5.1.2 Narrativa en Markdown\nLa narrativa proporciona estructura y contenido al documento en la forma de encabezados, párrafos, enlaces y otros elementos de la sintaxis de Markdown.\n\n\n5.1.3 Bloques de código fuente\nEn Quarto, los bloques (chunks) de código fuente se delimitan con tres backticks, tanto al inicio como al final del bloque. Los bloques de código en R se identifican con {r} y diferentes opciones identificadas con #|. Los bloques de otros lenguajes de programación se identifican con {python} y {julia}, por ejemplo.\nEl siguiente es un ejemplo de bloque de código en R y su salida:\n```{r}\n#| label: graficacion-cars\n#| include: true\n#| echo: false\n\nplot(\n  x = cars$speed,\n  y = cars$dist,\n  main = \"Velocidad vs distancia de frenado\",\n  xlab = \"Velocidad (MPH)\",\n  ylab = \"Distancia (pies)\"\n)\n```\n\n\n\n\n\n\n\n\n\nLa opción label se utiliza para etiquetar el bloque y la de include para especificar si se desea que el bloque y sus resultados se incluyan en el documento de salida.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#cómo-funciona-quarto",
    "href": "05-quarto.html#cómo-funciona-quarto",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.2 ¿Cómo funciona Quarto?",
    "text": "5.2 ¿Cómo funciona Quarto?\nQuarto se apoya en knitr y en Pandoc. knitr ejecuta el código en R (u otro lenguaje) y convierte los documentos a Markdown. Por su parte, Pandoc exporta los documentos Markdown al formato de salida deseado (ej. HTML, PDF, MS Word, MS PowerPoint). Este proceso se ilustra en la Figura 5.1.\n\n\n\n\n\n\nFigura 5.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#ejercicios",
    "href": "05-quarto.html#ejercicios",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.3 Ejercicios",
    "text": "5.3 Ejercicios\nCon Quarto, cree un sitio web en GitHub Pages que muestre los gráficos que programó en la tarea 1 de este curso.\nSeguidamente, se sugiere una serie de pasos para elaborar el sitio.\n\nCree un nuevo proyecto con la opción File - New Project - New Directory - New Project de RStudio.\nEn el nuevo proyecto, cree un nuevo documento con la opción File - New File - Quarto Document de RStudio. Llene los metadatos (título, autor, etc.). Elija HTML como formato de salida.\nGuarde el documento con el nombre index.qmd (RStudio asigna la extensión automáticamente).\nAl inicio del documento, agregue narrativa en Markdown que explique el contenido, la fuente de los datos y la dirección del repositorio en GitHub con el código fuente (este repositorio se crea en un paso posterior).\nAgregue los gráficos y los comentarios de la tarea 1 mediante bloques de código en R y narrativa en Markdown. Divida el documento en secciones mediante el uso de encabezados. Se recomienda asignar una etiqueta a cada bloque de código con la opción #| label:. Considere el uso de otras etiquetas Quarto para, por ejemplo, controlar el despliegue de las salidas y del código fuente.\nPresione el botón Render de RStudio para generar el archivo index.html. Este será el arhivo que se desplegará en GitHub Pages.\nCree un repositorio vacío en su cuenta en GitHub (ej. graficos-base-r).\nSuba al nuevo repositorio los archivos index.qmd e index.html.\nGenere el sitio en GitHub Pages con la opción Settings - Pages - Branch - main - Save de GitHub.\nRepita los pasos 6, 8 y 9 para cada modificación que realice en el documento Quarto.\n\n\n\n\nFigura 5.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  }
]