[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PF-0953 Programación en R 2024-II",
    "section": "",
    "text": "Bienvenida\nEste es un curso introductorio a la programación de computadoras y al procesamiento de datos geoespaciales mediante el lenguaje de programación R. También se estudian herramientas para facilitar la reproducibilidad de los procedimientos y la comunicación de las soluciones a través de Internet y otros medios. Se imparte en la Maestría Académica en Gestión Integrada del Recurso Hídrico para Latinoamérica y el Caribe de la Universidad de Costa Rica.\nEl enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplican en diversos escenarios de procesamiento de datos las habilidades y conocimientos aprendidos. No se requiere de experiencia en programación de computadoras. Es recomendable contar con conocimentos básicos de datos geoespaciales y sistemas de información geográfica.\nTanto las lecciones teóricas como las prácticas se imparten de manera presencial, con apoyo de medios virtuales. Los contenidos del curso y los recursos relacionados se comparten en el sitio web https://pf0953-programacionr.github.io/2024-ii/ y en la plataforma Mediación Virtual de la Universidad de Costa Rica.\n\n\nObjetivos\nAl finalizar el curso, el estudiantado será capaz de:\n\nDesarrollar programas en el lenguaje de programación R orientados al procesamiento de datos geoespaciales.\nAplicar un enfoque de ciencia de datos en los procesos de importación, transformación, visualización, análisis y comunicación de datos.\nDesarrollar soluciones reproducibles a problemas computacionales mediante R.\nIntegrar visualizaciones tabulares, gráficas y geoespaciales de datos en documentos y aplicaciones interactivas desarrolladas en R.\n\n\n\nPrograma\nEl programa del curso está disponible en programa del curso.\n\n\nCiclos anteriores\nEste sitio web corresponde al curso impartido durante el segundo ciclo lectivo de 2024. Para consultar las versiones de otros años y ciclos lectivos, puede visitar:\n\n2022-II\n\n\n\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "programa_curso.html",
    "href": "programa_curso.html",
    "title": "Programa del curso",
    "section": "",
    "text": "Programa del curso",
    "crumbs": [
      "Programa del curso"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html",
    "href": "01-introduccion-programacion-computadoras.html",
    "title": "1  Introducción a la programación de computadoras",
    "section": "",
    "text": "Introducción\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones tales como cálculos aritméticos y operaciones lógicas, entre otras. Un conjunto de instrucciones orientado a la resolución de un problema específico mediante una computadora se denomina programa. La programabilidad de las computadoras permite que su funcionamiento pueda modificarse sin alterar sus componentes físicos, lo que las hace mucho más versátiles que otros tipos de máquinas y posibilita que ayuden a resolver una gran variedad de problemas.\nLas computadoras se programan mediante lenguajes de dos niveles: lenguajes de máquina y lenguajes de programación. En este capítulo, se describe el papel de los lenguajes de programación y el modelo Entrada - Procesamiento - Salida en el que se basa la estructura de los programas. También se detallan los componentes principales de la arquitectura de computadoras más popular en la actualidad.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#trabajo-previo",
    "href": "01-introduccion-programacion-computadoras.html#trabajo-previo",
    "title": "1  Introducción a la programación de computadoras",
    "section": "",
    "text": "Lecturas\nDowney, Allen B. (2024). Chapter 1: Programming as a way of thinking en Think Python: How to Think Like a Computer Scientist (3rd ed.). O’Reilly Media. https://allendowney.github.io/ThinkPython/chap01.html\nSeverance, D. C. R. (2016). Chapter 1: Why should you learn to write programs? en Python for Everybody: Exploring Data in Python 3 (S. Blumenberg & E. Hauser, Eds.). CreateSpace Independent Publishing Platform. https://www.py4e.com/html3/",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#introducción",
    "href": "01-introduccion-programacion-computadoras.html#introducción",
    "title": "1  Introducción a la programación de computadoras",
    "section": "Introducción",
    "text": "Introducción\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones tales como cálculos aritméticos y operaciones lógicas, entre otras. Un conjunto de instrucciones orientado a la resolución de un problema específico mediante una computadora se denomina programa. La programabilidad de las computadoras permite que su funcionamiento pueda modificarse sin alterar sus componentes físicos, lo que las hace mucho más versátiles que otros tipos de máquinas y posibilita que ayuden a resolver una gran variedad de problemas.\nLas computadoras se programan mediante lenguajes de dos niveles: lenguajes de máquina y lenguajes de programación. En este capítulo, se describe el papel de los lenguajes de programación y el modelo Entrada - Procesamiento - Salida en el que se basa la estructura de los programas. También se detallan los componentes principales de la arquitectura de computadoras más popular en la actualidad.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "parte-i-introduccion-programacion-computadoras-ciencia-datos.html",
    "href": "parte-i-introduccion-programacion-computadoras-ciencia-datos.html",
    "title": "I - Introducción a la programación de computadoras y a la ciencia de datos",
    "section": "",
    "text": "1 Introducción a la programación de computadoras\n2 Introducción a la ciencia de datos",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#lenguajes-para-programar-computadoras",
    "href": "01-introduccion-programacion-computadoras.html#lenguajes-para-programar-computadoras",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.1 Lenguajes para programar computadoras",
    "text": "1.1 Lenguajes para programar computadoras\nLas computadoras pueden programarse mediante lenguajes de varios niveles. En esta sección, se describen el lenguaje de máquina, el más cercano al hardware de la computadora, y los lenguajes de programación, los cuales abstraen detalles técnicos y de hardware para lograr que la programación sea más intuitiva, más rápida y menos propensa a errores.\n\n1.1.1 Lenguajes de máquina\nLas computadoras modernas son electrónicas y utilizan circuitos integrados para procesar y almacenar información en forma de señales eléctricas. Esta representación de la información se basa en un sistema binario (de dos estados): 0 (voltaje bajo) y 1 (voltaje alto).\nEn el nivel más básico, las computadoras pueden programarse introduciendo directamente combinaciones de unos y ceros, conocidas como lenguaje de máquina en la Unidad Central de Procesamiento (CPU), el componente de hardware encargado de ejecutar las instrucciones.\nPor ejemplo, la Figura 1.1 muestra el programa Hola mundo (Hello World) en lenguaje de máquina. Este programa simplemente imprime la hilera de texto “Hola mundo” en la pantalla. Suele ser usado como introducción al estudio de la programación de computadoras.\n\n\n\n\n\n\nFigura 1.1: Lenguaje de máquina correspondiente a la implementación del programa “Hola mundo” en el lenguaje C (mostrado abajo). Imagen de Tanveer Salim.\n\n\n\n/* PROGRAMA \"Hola mundo\" EN LENGUAJE C */\n\nint main void()\n{\n  printf(\"hello, world\\n\");\n  return 0;\n}\nInternamente, el lenguaje de máquina ejecuta un conjunto de instrucciones muy básicas como, por ejemplo:\n\nSumar dos números.\nComprobar si un número es igual a cero.\nCopiar datos de una sección a otra de la memoria de la computadora.\n\nLos lenguajes de máquina son específicos para cada tipo de CPU. Así, por ejemplo, el lenguaje de máquina de un procesador Intel, uno de los más usados en computadoras personales, es diferente al lenguaje de máquina de un procesador PowerPC, utilizado tanto en computadoras personales (como antiguas Macintosh), como en consolas de videojuegos y sistemas incrustados (ej. en dispositivos electrónicos).\n\n\n1.1.2 Lenguajes de programación\nDebido a que el lenguaje de máquina es poco amigable para las personas, actualmente es más común utilizar lenguajes de programación para resolver problemas mediante computadoras. Los lenguajes de programación consisten de instrucciones compuestas por palabras y expresiones similares a las de los lenguajes humanos como, por lo general, el idioma inglés. Existe una gran variedad de lenguajes de programación, debido a los diferentes fines para los que fueron creados y a su evolución histórica, entre otras razones.\nLas instrucciones de los lenguajes de programación deben ser traducidas al lenguaje de máquina para que puedan ser ejecutados por la computadora. Esta traducción se realiza mediante programas llamados compiladores (para lenguajes compilados como C y C++) o interpretadores (para lenguajes interpretados como Python y R). Mientras que los lenguajes de máquina son específicos para cada CPU, algunos lenguajes de programación pueden ser ejecutados en diferentes plataformas, con el compilador o interpretador adecuado.\nComo ejemplo, considere problema del cálculo del índice de masa corporal (IMC). El IMC indica si una persona tiene una masa (peso) saludable en relación con su estatura. Se obtiene mediante la fórmula:\n\\[\nimc = \\frac{masa}{estatura^2}\n\\]\nEl resultado se interpreta de la siguiente manera:\n\nIMC menor que 18.5: Peso bajo.\nIMC mayor o igual que 18.5 y menor que 25: Peso normal.\nIMC mayor o igual que 25: Sobrepeso.\n\nEl siguiente programa en el lenguaje Python calcula e interpreta el IMC de una persona.\n# CÁLCULO E INTERPRETACIÓN DEL IMC DE UNA PERSONA\n\n\n# ENTRADA\n\n# Datos de masa (kg) y estatura (m) de una persona\nmasa = 65\nestatura = 1.7\n\n\n# PROCESAMIENTO\n\n# Cálculo del IMC\nimc = masa / estatura**2\n\n# Interpretación del IMC\nif (imc &lt; 18.5):\n  interpretacion_imc = \"Peso bajo\"\nelif (imc &lt; 25):\n  interpretacion_imc = \"Peso normal\"\nelse:\n  interpretacion_imc = \"Sobrepeso\"\n\n\n# SALIDA\n\n# Impresión de los resultados\nprint(\"El valor del IMC es:\", imc)\nprint(\"Corresponde a:\", interpretacion_imc)\nA manera de ejercicio, puede escribir y ejecutar el programa anterior en una consola de Python. Modifique los datos de entrada de masa y estatura y observe los cambios en los resultados.\nEn el ejemplo anterior puede observarse como el programa sigue un modelo conocido como “Entrada - Procesamiento - Salida”, el cual se describe en detalle en la sección siguiente.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#modelo-entrada---procesamiento---salida",
    "href": "01-introduccion-programacion-computadoras.html#modelo-entrada---procesamiento---salida",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.2 Modelo Entrada - Procesamiento - Salida",
    "text": "1.2 Modelo Entrada - Procesamiento - Salida\nLas computadoras trabajan con un modelo de “Entrada - Procesamiento - Salida”: reciben datos de entrada (ej. números), los procesan (ej. realizan cálculos aritméticos) y generan salidas (ej. resultados de los cálculos).\nEl modelo “Entrada - Procesamiento - Salida” es un concepto fundamental en análisis de sistemas de información y desarrollo de programas. Su esquema se presenta en la Figura 1.2.\n\n\n\n\n\n\nFigura 1.2: Modelo “Entrada - Procesamiento - Salida”\n\n\n\n\nLa Entrada se refiere a los datos que se introducen en un sistema o programa para ser procesados. Pueden ingresarse a través de diferentes medios como teclados, ratones, cámaras, sensores, archivos y servicios web, entre otros.\nEl Procesamiento es el conjunto de instrucciones que generan salidas a partir de las entradas. Estas intrucciones pueden incluir cálculos matemáticos, operaciones lógicas y operaciones de control, entre muchas posibilidades.\nPor último, la Salida es el resultado del procesamiento como, por ejemplo, resultado de cálculos aritméticos.\n\nEl modelo “Entrada - Procesamiento - Salida” se implementa en los componentes físicos mediante la arquitectura de computadoras, como se explica a continuación.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#arquitectura-de-computadoras",
    "href": "01-introduccion-programacion-computadoras.html#arquitectura-de-computadoras",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.3 Arquitectura de computadoras",
    "text": "1.3 Arquitectura de computadoras\nLa arquitectura de computadoras es un área de estudio enfocada en el diseño de los componentes principales de un sistema informático.\n\n1.3.1 Evolución histórica\nLa arquitectura de las computadoras modernas es el resultado de un proceso que ha tomado varios siglos, incluyendo la fabricación de calculadoras mecánicas en el siglo XVII, con capacidades para realizar operaciones aritméticas básicas, y el diseño en el siglo XIX de la máquina analítica de Charles Babbage, una computadora mecánica que incorporaba algunas características de las computadoras modernas.\nEn 1936, el matemático inglés Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas y que funcionó como un modelo teórico de gran importancia para desarrollos posteriores, como los dispositivos eletromecánicos Bombe y Colossus en el Reino Unido, de uso específico para criptografía durante la II Guerra Mundial. Algunos años después, en 1946, el ejército de los Estados Unidos desarrolló ENIAC (Electronic Numerical Integrator And Computer), considerada por algunos como la primera computadora de uso general y que fue inicialmente diseñada para calcular tablas de tiro de artillería.\n\n\n1.3.2 Arquitectura de von Neumann\nEn 1945, el matemático húngaro-estadounidense John von Neumann (1903-1957) propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada de los componentes físicos que ejecutan las instrucciones. Este modelo permite que las computadoras sean más fáciles de programase y reprogramarse y es conocido actualmente como arquitectura de von Neumann. La arquitectura de von Neumann se ilustra en la Figura 1.3.\n\n\n\n\n\n\nFigura 1.3: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\n\n\n\n\n1.3.2.1 Componentes de la arquitectura de von Neumann\n\n1.3.2.1.1 Memoria principal\nAlmacena las instrucciones de los programas y los datos que utilizan estos programas. Es común denominarla como RAM (Random Access Memory, Memoria de Acceso Aleatorio), lo que significa que toma el mismo tiempo acceder a cualquier posición de la memoria. Cada posición de memoria tiene una dirección a la que se hace referencia cuando se desea leer o escribir.\n\n\n1.3.2.1.2 Unidad Central de Procesamiento\nTambién se le conoce como CPU (Central Processing Unit, Unidad Central de Procesamiento). Ejecuta las instrucciones de los programas en lenguaje de máquina. Está compuesta por dos partes:\n\nUnidad de Control: determina cuál es la siguiente instrucción a ejecutar. Contiene memorias temporales de alta velocidad y poca capacidad llamadas registros, para almacenar los operandos y el resultado de las instrucciones.\nUnidad de Aritmética y Lógica o ALU (Arithmetic and Logic Unit): ejecuta las operaciones aritméticas y lógicas.\n\n\n\n1.3.2.1.3 Sistemas de entrada y salida\nPermiten que la computadora interactúe con el usuario y, en general, con el mundo exterior. Algunos ejemplos son el teclado y el ratón, como sistemas de entrada, y la pantalla y la impresora, como sistemas de salida.\n\n\n\nFigura 1.1: Lenguaje de máquina correspondiente a la implementación del programa “Hola mundo” en el lenguaje C (mostrado abajo). Imagen de Tanveer Salim.\nFigura 1.2: Modelo “Entrada - Procesamiento - Salida”\nFigura 1.3: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html",
    "href": "02-introduccion-ciencia-datos.html",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "href": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "Lecturas\nÇetinkaya-Rundel, Mine, & Hardin, Johanna (2021). Chapter 1: Hello data en Introduction to Modern Statistics (1st ed.). OpenIntro, Inc. https://openintro-ims.netlify.app/data-hello\nSingleton, Alex David; Spielman, Seth; & Brunsdon, Chris (2016). Establishing a framework for Open Geographic Information science. International Journal of Geographical Information Science, 30(8), 1507-1521. https://doi.org/10.1080/13658816.2015.1137579\nWickham, Hadley; Çetinkaya-Rundel, Mirne; & Grolemund, Garret (2023). Introduction en R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/intro",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#introducción",
    "href": "02-introduccion-ciencia-datos.html#introducción",
    "title": "2  Introducción a la ciencia de datos",
    "section": "Introducción",
    "text": "Introducción\nUna investigación estadística se basa en datos. Los datos acostumbran representarse en tablas, en las cuales cada fila es una observación y cada columna es una variable. Una observación corresponde a un elemento de datos que ha sido estudiado y cada variable a una característica de ese elemento. Las variables pueden ser numéricas o categóricas. Las numéricas se subdividen en discretas y continuas y las categóricas en nominales y ordinales.\nLa ciencia de datos es una disciplina que permite convertir datos sin procesar en comprensión y conocimiento. El ciclo de vida de un proyecto de ciencia de datos incluye los procesos importar, ordenar, transformar, visualizar, modelar y comunicar. La programación de computadoras puede emplearse en cualquier etapa del ciclo de vida de un proyecto para automatizar tareas y a resolver nuevos problemas con mayor facilidad.\nEl surgimiento de la ciencia de datos está motivado por un incremento acelerado de la cantidad de datos existentes, así como de la disponibilidad de herramientas computacionales y de infraestructura informática para procesarlos y analizarlos. Estos cambios tecnológicos han sido apoyados por un cambio cultural propiciado por movimientos como el de ciencia abierta (open science), el cual promueve el acceso libre a la investigación científica, incluidas las publicaciones, los datos, las metodologías y el código fuente.\nUn aspecto crucial de la ciencia abierta es la reproducibilidad, que garantiza que los resultados de una investigación puedan ser verificados y validados por otros investigadores. Hay varias herramientas que pueden facilitar la reproducibilidad en ciencia de datos, incluyendo lenguajes de programación, lenguajes de marcado y sistemas de control de versiones.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#datos",
    "href": "02-introduccion-ciencia-datos.html#datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.1 Datos",
    "text": "2.1 Datos\nLos científicos tratan de responder preguntas mediante métodos rigurosos y observaciones cuidadosas. Estas observaciones, recopiladas de notas de campo, encuestas y experimentos, entre otras fuentes, forman la columna vertebral de una investigación estadística y se denominan datos. La presentación y descripción efectivas de los datos constituyen el primer paso en un análisis Çetinkaya-Rundel & Hardin (2021). Esta sección introduce una estructura para organizar los datos, así como alguna terminología que se utilizará a lo largo de este curso.\n\n2.1.1 Observaciones y variables\nLa tabla 1 contiene 10 filas de un conjunto de datos. Cada fila representa una persona. En términos estadísticos, cada fila corresponde a una observación. Las columnas representan características de las personas. Cada columna corresponde a una variable.\n\n\n\nTabla 1. Datos de personas.\n\n\n\n\ncedula\n\n\nprovincia\n\n\nequipo\n\n\npeso\n\n\nestatura\n\n\nsexo\n\n\ncantidad_hermanos\n\n\nnivel_guitarra\n\n\n\n\n\n\n709880238\n\n\nLimón\n\n\nSaprissa\n\n\n51.0\n\n\n1.51\n\n\ndesconocido\n\n\n0\n\n\nnulo\n\n\n\n\n400680168\n\n\nHeredia\n\n\nHerediano\n\n\n98.5\n\n\n1.87\n\n\nhombre\n\n\n1\n\n\nalto\n\n\n\n\n509210285\n\n\nGuanacaste\n\n\nLiberia\n\n\n91.6\n\n\n1.65\n\n\nmujer\n\n\n4\n\n\nbajo\n\n\n\n\n701950272\n\n\nLimón\n\n\nLiberia\n\n\n60.6\n\n\n1.68\n\n\nmujer\n\n\n1\n\n\nalto\n\n\n\n\n309880238\n\n\nCartago\n\n\nCartaginés\n\n\n59.1\n\n\n1.73\n\n\nmujer\n\n\n3\n\n\nbajo\n\n\n\n\n908280708\n\n\nDesconocida\n\n\nSan Carlos\n\n\n59.2\n\n\n1.89\n\n\nhombre\n\n\n3\n\n\nbajo\n\n\n\n\n505580938\n\n\nGuanacaste\n\n\nCartaginés\n\n\n65.2\n\n\n1.70\n\n\nmujer\n\n\n3\n\n\nalto\n\n\n\n\n504080488\n\n\nGuanacaste\n\n\nSporting\n\n\n76.2\n\n\n1.76\n\n\nhombre\n\n\n3\n\n\nexperto\n\n\n\n\n709950244\n\n\nLimón\n\n\nAlajuelense\n\n\n71.6\n\n\n1.80\n\n\nhombre\n\n\n4\n\n\nbajo\n\n\n\n\n206080825\n\n\nAlajuela\n\n\nAlajuelense\n\n\n64.6\n\n\n1.52\n\n\nhombre\n\n\n2\n\n\nbajo\n\n\n\n\n\n\n2.1.2 Tipos de variables\nLas variables de los datos de la tabla 1 son de varios tipos, cuya jerarquía se muestra en la Figura 2.1.\n\n\n\n\n\n\nFigura 2.1: Tipos de variables estadísticas. Imagen de Çetinkaya-Rundel & Hardin (2021)\n\n\n\nSeguidamente, se describen estos tipos de datos de las variables.\n\n2.1.2.1 Numéricas\nCorresponden a números a los cuales se les pueden aplicar operaciones como suma, resta, multiplicación, división y otras similares. Las variables numéricas puden ser discretas o continuas.\n\n2.1.2.1.1 Discretas\nToman valores específicos que se pueden contar. La variable cantidad_hermanos es discreta. Existe una separación clara entre sus posibles valores. Por ejemplo, es posible tener 1, 2 o 3 hermanos, pero no 2.5.\n\n\n2.1.2.1.2 Continuas\nPueden tomar cualquier valor dentro de un intervalo o rango continuo. Estas variables se caracterizan por su capacidad para representar medidas precisas y pueden asumir un número infinito de valores, incluso dentro de un rango limitado (ej. entre 0 y 1). Las variables peso y estatura son continuas.\n\n\n\n2.1.2.2 Categóricas\nLas variables categóricas (también llamadas cualitativas), son aquellas que describen una característica o cualidad de una observación y pueden utilizarse para clasificar las observaciones en grupos o categorías. A diferencia de las variables numéricas, que expresan cantidades, las variables categóricas expresan atributos no numéricos. Las variables categóricas pueden ser nominales u ordinales.\n\n2.1.2.2.1 Nominales\nNo existe un orden inherente o jerarquía entre las categorías. Las variables provincia, equipo y sexo son nominales.\n\n\n2.1.2.2.2 Ordinales\nHay un orden o jerarquía clara entre las categorías. La variable nivel_guitarra, con sus valores nulo, bajo, alto y experto, es ordinal.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#referencias-bibliográficas",
    "href": "02-introduccion-ciencia-datos.html#referencias-bibliográficas",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.5 Referencias bibliográficas",
    "text": "2.5 Referencias bibliográficas\n\n\nÇetinkaya-Rundel, M., & Hardin, J. (2021). Introduction to\nModern Statistics (1st ed.). OpenIntro,\nInc. Retrieved from https://openintro-ims.netlify.app/\n\n\nGandrud, C. (2020). Reproducible research with R and\nRStudio (Third edition). Boca Raton, FL: CRC Press.\n\n\nHarrison, D., & Rubinfeld, D. L. (1978). Hedonic housing prices and\nthe demand for clean air. Journal of Environmental Economics and\nManagement, 5(1), 81–102. https://doi.org/10.1016/0095-0696(78)90006-2\n\n\nKrugman, P. (2013). Opinion  The\nExcel Depression. The New York Times.\nRetrieved from https://www.nytimes.com/2013/04/19/opinion/krugman-the-excel-depression.html\n\n\nPeng, R. D. (2011). Reproducible Research in\nComputational Science. Science,\n334(6060), 1226–1227. https://doi.org/10.1126/science.1213847\n\n\nPrince, S. J. D. (2023). Understanding deep learning. The MIT\nPress. Retrieved from http://udlbook.com\n\n\nSingleton, A. D., Spielman, S., & Brunsdon, C. (2016). Establishing\na framework for Open Geographic\nInformation science. International Journal of\nGeographical Information Science, 30(8), 1507–1521. https://doi.org/10.1080/13658816.2015.1137579\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\nData Science: Import,\nTidy, Transform, Visualize, and\nModel Data (2nd ed.). O’Reilly Media.\nRetrieved from https://r4ds.hadley.nz/\n\n\n\n\n\nFigura 2.1: Tipos de variables estadísticas. Imagen de Çetinkaya-Rundel & Hardin (2021)\nFigura 2.2: Ciclo de vida de un proyecto de ciencia de datos. Imagen de Wickham et al. (2023)\nFigura 2.3: Problemas de regresión y clasificación. Imagen de Prince (2023)\nFigura 2.4: Modelo de aprendizaje automático. Imagen de Prince (2023).\nFigura 2.5: Espectro de reproducibilidad. Imagen de Anita Graser basada en Peng (2011).",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#ciclo-de-vida-de-un-proyecto-de-ciencia-de-datos",
    "href": "02-introduccion-ciencia-datos.html#ciclo-de-vida-de-un-proyecto-de-ciencia-de-datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.2 Ciclo de vida de un proyecto de ciencia de datos",
    "text": "2.2 Ciclo de vida de un proyecto de ciencia de datos\nLa ciencia de datos es una disciplina que permite convertir datos “crudos” (sin procesar) en comprensión y conocimiento Wickham, Çetinkaya-Rundel, & Grolemund (2023). Se basa en la estadística y en las ciencias de la computación, entre otras disciplinas.\n\n2.2.1 Procesos\nLa Figura 2.2 ilustra el ciclo de vida de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\n\nFigura 2.2: Ciclo de vida de un proyecto de ciencia de datos. Imagen de Wickham et al. (2023)\n\n\n\n\n2.2.1.1 Importar\nImportar los datos generalmente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en estructuras apropiadas para este propósito en un lenguaje de programación.\n\n\n2.2.1.2 Ordenar\nOrdenar o estructurar (to tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable. En algunos casos, pueden requerirse estructuras de otros tipos.\n\n\n2.2.1.3 Transformar\nTransformar los datos incluye, entre otras operaciones, la generación de algún subconjunto de observaciones o variables del conjunto original, la creación de nuevas variables a partir de las ya existentes o el cálculo de estadísticas como conteos y promedios.\nUna vez que los datos están bien estructurados y con las variables que se requieren para el análisis, se puede proceder a la generación de conocimiento mediante dos mecanismos: la visualización y la modelización. Ambos tienen fortalezas y debilidades y es común iterar varias veces entre uno y otro.\n\n\n2.2.1.4 Visualizar\nVisualizar los datos en tablas, gráficos, mapas u otros formatos permite encontrar patrones inesperados o formular nuevas preguntas. Una buena visualización también puede indicar si se están formulando preguntas equivocadas o utilizando datos que no son apropiados para el problema que se desea resolver. Es importante tener en cuenta que las visualizaciones deben ser interpretadas por seres humanos. Por este motivo, visualizaciones como gráficos estadísticos y mapas deben ser seleccionadas con cuidado y elaborarse detalladamente.\n\n\n2.2.1.5 Modelar\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones. Al ser herramientas matemáticas o computacionales, los modelos muchas veces pueden mejorarse mediante el empleo de mayores capacidades de cómputo, lo que los hace menos dependientes de la intervención humana, como en el caso de las visualizaciones.\n\n\n2.2.1.6 Comunicar\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general. No importa lo bien que los modelos y visualizaciones ayuden a entender los datos si los resultados no pueden ser comunicados a otras personas.\n\n\n2.2.1.7 Programar\nLa programación de computadoras se utiliza de manera transversal en los procesos recién descritos. Puede emplearse en cualquier etapa del ciclo de vida de un proyecto de ciencia de datos. Es útil para automatizar tareas y a resolver nuevos problemas con mayor facilidad.\n\n\n\n2.2.2 Ejemplos\nLas etapas iniciales de un proyecto de ciencia de datos incluyen técnicas estadísticas convencionales como el análisis exploratorio de datos (EDA), mientras que las más avanzadas pueden involucrar técnicas de inteligencia artificial como aprendizaje automático (machine learning) y aprendizaje profundo (deep learning).\nLa Figura 2.3 ilustra varios problemas resueltos mediante regresión y clasificación, dos técnicas que se utilizan en deep learning. En cada caso, hay una entrada que puede tener diversos formatos como un conjunto de números, una hilera de texto, un archivo de sonido o una imagen. Esta entrada se transforma y se codifica como un vector de números. Este vector constituye la entrada del modelo de regresión o clasificación. El modelo convierte la entrada en un vector de salida que se “traduce” de nuevo a un formato adecuado.\n\n\n\n\n\n\nFigura 2.3: Problemas de regresión y clasificación. Imagen de Prince (2023)\n\n\n\nEl modelo de a) predice el precio de una vivienda en función de características de entrada como el área en pies cuadrados y el número de dormitorios 1. Se trata de un problema de regresión, ya el modelo retorna un número real (no asigna una categoría). El modelo de la figura b) recibe la estructura química de una molécula como entrada y predice su punto de congelación y su punto de ebullición. Este es un problema de regresión multivariada, ya que la salida incluye más de un número.\nEl modelo en c) recibe como entrada una hilera de texto que contiene las calificaciones de varios aspectos a evaluar sobre una comida en un restaurante (plato principal, ensalada, sopa, postre, etc.) y predice si el resultado general es positivo o negativo. Es un problema de clasificación binaria porque el modelo asigna como salida una de dos categorías. El vector de salida contiene las probabilidades de posible valor. Los modelos en d) y e) corresponden a problemas de clasificación multiclase. Aquí, el modelo asigna el valor de salida a una de n &gt; 2 categorías. En el primer caso, la entrada es un archivo de audio y el modelo predice el género musical al que pertenece. En el segundo caso, la entrada es una imagen y el modelo predice qué objeto contiene. En cada caso, el modelo devuelve un vector de tamaño n que contiene las probabilidades de las n categorías.\nEn la Figura 2.3, los modelos de deep learning se muestran como “cajas negras” que reciben una entrada y retornan una salida, sin entrar en detalles de como se procesa la entrada. Hay muchas posibilidades para implementar estas “cajas negras”. Considere un modelo para predecir la estatura de un niño a partir de su edad, como el de la Figura 2.4. En este caso, el modelo es una ecuación que describe como la estatura promedio varía en función de la edad. Al ingresar la edad a la ecuación, retorna la estatura.\n\n\n\n\n\n\nFigura 2.4: Modelo de aprendizaje automático. Imagen de Prince (2023).\n\n\n\nEl surgimiento de la ciencia de datos está motivado por un incremento acelerado de la cantidad de datos existentes, así como de la disponibilidad de herramientas computacionales (lenguajes de programación, motores de bases de datos) y de infraestructura informática (hospedaje de datos, hospedaje de aplicaciones) para procesarlos y analizarlos. Los cambios tecnológicos han sido apoyados por un cambio cultural propiciado por movimientos como los de código abierto (open source), datos abiertos (open data), acceso abierto (open access) y ciencia abierta (open science). La ciencia abierta, que de alguna manera engloba a los otros movimientos abiertos, promueve el acceso libre a la investigación científica, incluidas las publicaciones, los datos, las metodologías y el código fuente, de manera que sean accesibles a todos los niveles de la sociedad. Un aspecto crucial de la ciencia abierta es la reproducibilidad, que garantiza que los resultados de una investigación puedan ser verificados y validados por otros investigadores.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#footnotes",
    "href": "02-introduccion-ciencia-datos.html#footnotes",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "Como ejemplo, puede revisar el problema de la estimación de precios de viviendas en Boston en Harrison & Rubinfeld (1978) (el texto completo está en https://deepblue.lib.umich.edu/bitstream/handle/2027.42/22636/0000186.pdf) y acceder a los datos correspondientes en Kaggle.↩︎",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#reproducibilidad",
    "href": "02-introduccion-ciencia-datos.html#reproducibilidad",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.3 Reproducibilidad",
    "text": "2.3 Reproducibilidad\nLa reproducibilidad es la capacidad de un ensayo o experimento de ser reproducido por otros. Más formalmente, en investigación cuantitativa, un análisis se considera reproducible si “el código fuente y los datos utilizados por un investigador para llegar a un resultado están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado” Gandrud (2020).\nLa reproducibilidad, junto con la falsabilidad, es uno de los pilares del método científico. Sin embargo, en años recientes, se ha generado una creciente preocupación debido a que muchos estudios científicos publicados fallan las pruebas de reproducibilidad, dando lugar a una crisis de reproducibilidad o replicabilidad en varias ciencias Krugman (2013).\nEl concepto de reproducibilidad es cada vez más importante debido, entre otras razones, al aumento exponencial de datos disponibles y a la aplicación de la programación de computadoras, para procesar estos datos, por parte de especialistas de muchas disciplinas.\nAlex Singleton y otros autores han identificado los siguientes retos para la reproducibilidad en ciencia de datos geoespaciales Singleton, Spielman, & Brunsdon (2016):\n\nLos datos deben ser de dominio público y estar disponibles para los investigadores.\nEl software utilizado debe ser de código abierto (open source) y estar disponible para ser revisado.\nSiempre que sea posible, los flujos de trabajo deben ser públicos y con enlaces a los datos, software y métodos de análisis, junto con la documentación necesaria.\nEl proceso de revisión por pares (peer review process) y la publicación académica deben requerir la presentación de un modelo de flujo de trabajo e idealmente la disponibilidad de los materiales necesarios para la replicación.\nEn los casos en los que la reproducibilidad total no sea posible (ej. datos sensibles), los investigadores deben esforzarse por incluir todos los aspectos que puedan de un marco de trabajo abierto.\n\nEn general, el estándar mínimo de reproducibilidad requiere que los datos y el código fuente estén disponibles para otros investigadores Peng (2011). Sin embargo, dependiendo de las circunstancias y recursos disponibles, existe todo un espectro de posibilidades, que se ilustra en la Figura 2.5.\n\n\n\n\n\n\nFigura 2.5: Espectro de reproducibilidad. Imagen de Anita Graser basada en Peng (2011).",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#herramientas-para-ciencia-de-datos",
    "href": "02-introduccion-ciencia-datos.html#herramientas-para-ciencia-de-datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.4 Herramientas para ciencia de datos",
    "text": "2.4 Herramientas para ciencia de datos\nComo se ha mencionado, la programación de computadoras es una actividad presente durante todos los procesos de ciencia de datos. Hay muchos lenguajes que pueden utilizarse en este campo. Entre los más populares, pueden mencionarse Python, R, SQL y JavaScript.\nPor otra parte, la documentación es vital durante todo el ciclo de vida de una investigación reproducible. Se recomienda utilizar mecanismos estandarizados y abiertos como el lenguaje de marcado de hipertexto (HTML, en inglés, HyperText Markup Language) o Markdown, con los cuales pueden crearse documentos mediante editores de texto simples (i.e. no se requiere de software propietario), y exportables a varios formatos (ej. LaTeX, PDF).\nPara dar mantenimiento, tanto al código fuente como a la documentación, es necesario un sistema de control de versiones como Git, el cual permite llevar el registro de los cambios en archivos y también facilita el trabajo colaborativo al reunir las modificaciones hechas por varias personas. Git es usado en varias plataformas que comparten código fuente (ej. GitHub, GitLab) y que ofrecen servicios relacionados, como hospedaje de sitios web.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "parte-ii-lenguaje-programacion-r.html",
    "href": "parte-ii-lenguaje-programacion-r.html",
    "title": "II - El lenguaje de programación R",
    "section": "",
    "text": "3 R - lenguaje de programación para análisis estadístico",
    "crumbs": [
      "II - El lenguaje de programación R"
    ]
  },
  {
    "objectID": "03-r.html",
    "href": "03-r.html",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#trabajo-previo",
    "href": "03-r.html#trabajo-previo",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "Lecturas\nGrolemund, G., & Wickham, H. (2014). Chapter 1 - Chapter 12 en Hands-On Programming with R: Write Your Own Functions And Simulations. O’Reilly Media. https://rstudio-education.github.io/hopr/",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#introducción",
    "href": "03-r.html#introducción",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "Introducción",
    "text": "Introducción\nR es un lenguaje de programación y un entorno enfocado en graficación y en análisis estadístico. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como agricultura, biomedicina, bioinformática, finanzas, hidrología, teledetección y geografía entre muchos otros.\nAlgunas de las principales características del lenguaje de programación R son:\n\nEs interpretado: las instrucciones se traducen una por una a lenguaje de máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables de un programa solo pueden tener un tipo de datos.\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\n\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\nLa Comprehensive R Archive Network (CRAN) es una red mundial distribuida de servidores que albergan el código y la documentación oficial de R y sus paquetes. Las tasks views de CRAN categorizan la funcionalidad de R de acuerdo con temáticas determinadas.\nPara programar en R, puede utilizarse una interfaz de línea de comandos, editores de código fuente (ej. Visual Studio Code) y también entornos integrados de desarrollo (IDE, en inglés Integrated Development Environment) como Jupyter o RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "href": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.1 El ambiente de desarrollo integrado RStudio",
    "text": "3.1 El ambiente de desarrollo integrado RStudio\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de Posit Cloud. La Figura 3.1 muestra la interfaz de RStudio.\n\n\n\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.\n\n\n\nAdemás de edición de código fuente, RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas.\nEjercicios\n1. Instale en su computadora:\n\nSistema base del lenguaje R.\n\nRStudio Desktop.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conceptos-fundamentales",
    "href": "03-r.html#conceptos-fundamentales",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.2 Conceptos fundamentales",
    "text": "3.2 Conceptos fundamentales\n\n3.2.1 Manejo de datos\n\n3.2.1.1 Tipos y estructuras de datos\nR maneja los datos en una gran variedad de tipos y estructuras, los cuales incluyen tipos básicos como números, caracteres y lógicos y tipos compuestos como matrices y listas que permiten manejar varios valores conjuntamente.\nUna de las herramientas fundamentales en R para el manejo y análisis de datos es el data frame. Un data frame es una estructura rectangular de filas y columnas, en la que cada fila corresponde a una observación y cada columna a una variable. Las columnas pueden ser de diferentes tipos: números, caracteres, lógicos y muchos otros. Un data frame puede verse como lo que comúmmente se conoce como una tabla de datos (ej. las de las hojas de cálculo). Los data frames permiten realizar operaciones sobre los datos como creación de subconjuntos, ordenamientos, filtrados, cálculos estadísticos (promedio, desviación estándar, mínimo, máximo, etc.) y muchas otras.\nLos tipos y estructuras de datos de R se estudiarán con más detalle en este capítulo.\n\n\n3.2.1.2 Conjuntos de datos para ejemplos y pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"iris\"\n?iris\n\n# Visualización de iris\nView(iris)\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nPapers with Code - conjuntos de datos\nGapminder\n\n\n\n\n3.2.2 Funciones\n\n3.2.2.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.2.2.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2024-ii\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n1. Obtenga la ruta de su directorio de trabajo con la función getwd() y anótela.\n2. Cambie la ruta de su directorio de trabajo con la función setwd() a cualquier otro directorio en el que tenga derechos de escritura. Verifique el cambio usando nuevamente getwd().\n3. Con la función create.file(), cree un archivo llamado hola.R y escriba ahí el programa “Hola mundo”: cat(\"Hola mundo\")\n4. Ejecute su programa con los botones Run y Source de RStudio.\n5. Cambie nuevamente su directorio de trabajo a la ruta que anotó en el paso 1. Copie ahí su programa y ejecútelo nuevamente.\n\n\n3.2.2.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), de la instalación básica de R, para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n1. Estudie la documentación de la función plot() y agregue al gráfico anterior:\n\nUn título.\n\nUn subtítulo.\n\n\n\n3.2.2.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\n3.2.3 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. También hay paquetes que contienen datos (ej. los resultados de un censo).\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\nEn el siguiente ejemplo, se instala el paquete titanic, el cual contiene datos sobre el destino de los pasajeros durante el viaje inaugural del transatlántico RMS Titanic, resumida según el estatus económico (clase), sexo, edad y supervivencia de cada pasajero.\n\n# Instalación del paquete titanic (note las comillas)\ninstall.packages(\"titanic\")\n\nSeguidamente, el paquete titanic se carga con la función library().\n\n# Carga de titanic\nlibrary(titanic)\n\n\n\n3.2.4 Visualización de datos\n\n3.2.4.1 La función View()\nEl conjunto de datos titanic_train puede observarse, con sus observaciones y variables, con la función View(), la cual permite visualizar un conjunto de datos en una tabla.\n\n# Visualización del conjunto de datos titanic_train\nView(titanic_train)\n\nEste conjunto de datos se utiliza para entrenar modelos de aprendizaje automático (machine learning) para que realicen, por ejemplo, predicciones (ej. la supervivencia o muerte de un pasajero con base en variables como edad, clase, sexo y otras). Las predicciones del modelo se evalúan con titanic_test, el conjunto de datos de evaluación.\n\n\n3.2.4.2 Funciones básicas de graficación estadística\nLa instalación básica de R, la cual incluye el paquete base y el paquete graphics, ofrece una gran variedad de funciones para elaborar gráficos estadísticos. Esta funcionalidad se enriquece gracias al aporte de paquetes elaborados por terceros, los cuales se estudiarán posteriormente en este curso. Entre los tipos de gráficos que pueden elaborarse con la instalación básica de R están los gráficos de dispersión, los gráficos de barras, los gráficos de pastel y los histogramas.\n\n3.2.4.2.1 Gráficos de barras\nUn gráfico de barras permite representar variables de un conjunto de datos mediante barras rectangulares de longitud proporcional a los valores representados. Los gráficos de barras se utilizan principalmente para representar datos que involucran variables categóricas. Permiten comparar fácilmente cantidades o números asociados a diferentes categorías. Por ejemplo, se puede usar un gráfico de barras para mostrar la cantidad de ventas de diferentes tipos de productos, la población en diferentes ciudades, o las puntuaciones obtenidas por estudiantes en diferentes materias.\nEl siguiente gráfico de barras muestra la cantidad de pasajeros por clase en titanic_train, mediante la función barplot(), una de las funciones de graficación básica de R. Esta función recibe como argumento los valores que se desea representar en las barras, por lo que antes se utiliza la función table() para generar una tabla de contingencia con las cantidades de pasajeros que viajaban en cada clase.\n\n# Cantidades de pasajeros por clase\npasajeros_por_clase &lt;- table(titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase\n## \n##   1   2   3 \n## 216 184 491\n\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height = pasajeros_por_clase,\n  main = \"Cantidad de pasajeros por clase en el Titanic\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n\n\n\n\n\n\n\n\nLa cantidad de pasajeros en cada clase puede subdividirse en fallecidos y sobrevivientes.\n\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\npasajeros_por_clase_sobrevivencia &lt;- \n  table(titanic_train$Survived, titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase_sobrevivencia\n##    \n##       1   2   3\n##   0  80  97 372\n##   1 136  87 119\n\nEl siguiente gráfico de barras apiladas muestra la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\n\n# Gráfico de barras apiladas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas. Note el uso del argumento beside.\n\n# Gráfico de barras agrupadas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n3.2.4.2.2 Gráficos de pastel\nLos gráficos de pastel se utilizan para mostrar proporciones o porcentajes, representando la composición de un todo. Son especialmente útiles para resaltar cómo se divide un conjunto en categorías, donde cada segmento del pastel (slice o “rebanada”) representa la proporción o porcentaje de esa categoría dentro del total. Por lo tanto, son más adecuados para visualizar datos categóricos o cualitativos, no para datos numéricos continuos.\nLa cantidad de pasajeros por clase en titanic_train también puede mostrarse en un gráfico de pastel, mediante la función pie de la instalación básica de R.\n\n# Gráfico de pastel por clase de pasajero\npie(\n  x = pasajeros_por_clase, \n  main = \"Distribución de pasajeros por clase en el Titanic\",\n  labels = paste(names(pasajeros_por_clase), \":\", pasajeros_por_clase)\n)\n\n\n\n\n\n\n\n\n\n\n3.2.4.2.3 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (en este caso, llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable.\nEn la instalación básica de R, los histogramas se implementan mendiante la función hist().\n\nhist(\n  x = titanic_train$Age, \n  breaks = 8,\n  main = \"Distribución de la edad de los pasajeros del Titanic\", \n  xlab = \"Edad\", \n  ylab = \"Frecuencia\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas.\nGuarde los gráficos en un archivo PDF (puede consultar Saving plots to a file with pdf(), jpeg() and png()).\n\n\n\n\n\n3.2.5 Tipos de datos\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\nR proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz. R también permite que el programador defina sus propios objetos.\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y &lt;- (o -&gt;). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\n\n# Número\nx &lt;- 10\nx\n## [1] 10\n\n# Otro número\n20 -&gt; y\ny\n## [1] 20\n\n# Hilera de caracteres\nnombre &lt;- 'Manuel'\nnombre\n## [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias &lt;- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n## [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"    \"Viernes\"  \n## [7] \"Sábado\"\n\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\nEl tipo de un objeto puede consultarse con la función typeof(). Por ejemplo:\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(nombre)\n## [1] \"character\"\ntypeof(dias)\n## [1] \"character\"\n\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\n\n3.2.5.1 Tipos básicos\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\n\n3.2.5.1.1 Números\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\n\n# Declaración de variables numéricas\nx &lt;- 5\ny &lt;- 0.5\n\n# Suma\nx + y\n## [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(x + y)\n## [1] \"double\"\n\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\n\n# Números enteros\nx &lt;- 10L\ny &lt;- as.integer(15)\n\n# Multiplicación\nx * y\n## [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"integer\"\ntypeof(x * y)\n## [1] \"integer\"\n\n\n\n3.2.5.1.2 Caracteres\nSe utilizan para representar textos. Deben estar entre comillas simples ('') o dobles (\"\").\n\n# Hileras de caracteres\nnombre &lt;- \"María\"\napellido &lt;- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n## [1] \"María Pérez\"\n\n\n\n3.2.5.1.3 Lógicos\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\n\n# Variable lógica\na &lt;- 1 &lt; 2\na\n## [1] TRUE\n\n# Variable lógica\nb &lt;- 1 &gt; 2\nb\n## [1] FALSE\n\nLas expresiones lógicas pueden combinarse con operadores como:\n\n& (Y, en inglés AND)\n| (O, en inglés OR)\n! (NO, en inglés NOT)\n\n\n# Operador lógico AND\n(1 &lt; 2) & (3 &lt; 4)\n## [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 &lt;= 10)\n## [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n## [1] TRUE\n\n\n\n3.2.5.1.4 Vectores\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\n\n3.2.5.1.4.1 Definición\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\n\n# Definición de un vector de números\nvector_numeros &lt;- c(1, 7, 32, 45, 57)\nvector_numeros\n## [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres &lt;- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n## [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia (i.e. una lista ordenada):\n\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia &lt;- 1:10\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia &lt;- -5:5\nvector_secuencia\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia &lt;- -0.5:3.7\nvector_secuencia\n## [1] -0.5  0.5  1.5  2.5  3.5\n\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\n\n# Definición de un vector de números en secuencia de 1 a 10\nvector_secuencia &lt;- seq(1, 10)\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números en secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia &lt;- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n## [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números en secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia &lt;- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n## [1] 1.500000 4.133333 6.766667 9.400000\n\n\n\n3.2.5.1.4.2 Indexación\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\n\n# Vector de nombres de países\npaises &lt;- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n## [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"\n\n# Elemento en el índice 3\npaises[3]\n## [1] \"China\"\n\nEl operador : puede utilizarse para especificar un rango de índices:\n\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n## [1] \"Francia\"   \"China\"     \"Australia\"\n\nCon la función c(), es posible especificar un conjunto de índices particulares:\n\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n## [1] \"Argentina\" \"Australia\" \"México\"\n\nLos números negativos pueden usarse para excluir índices:\n\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n## [1] \"Argentina\" \"Francia\"   \"México\"\n\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\n\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n## [1] \"Argentina\" \"Francia\"   \"Australia\"\n\n\n\n3.2.5.1.4.3 Operaciones\nEn los vectores pueden aplicarse operaciones aritméticas:\n\na &lt;- c(1, 3, 5, 7)\nb &lt;- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n## [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n## [1]  2 12 30 56\n\nY también pueden realizarse operaciones relacionales:\n\n# Comparación con el operador &lt;\na &lt; b\n## [1] TRUE TRUE TRUE TRUE\n\n\n\n\n3.2.5.1.5 Matrices\nUna matriz es una estructura bidimensional de filas y columnas.\n\n3.2.5.1.5.1 Definición\nLas matrices se definen mediante la función matrix().\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm &lt;- matrix(1:9, nrow=3, ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm &lt;- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos &lt;- c(18, 500, 25, 1000, 30, 2000)\nfilas &lt;- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas &lt;- c(\"Edad\", \"Salario\")\n\nm &lt;- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n## Laura   30    2000\n\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\n\n\n3.2.5.1.5.2 Indexación\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\n\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n## [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n##    Edad Salario \n##      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n##   Ana Mario Laura \n##   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n##    Edad Salario \n##      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n##   Ana Mario Laura \n##   500  1000  2000\n\n\n\n3.2.5.1.5.3 Operaciones\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\n\na &lt;- matrix(1:4, nrow=2, ncol=2)\na\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n\nb &lt;- matrix(5:8, nrow=2, ncol=2)\nb\n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\n# Suma de matrices\na + b\n##      [,1] [,2]\n## [1,]    6   10\n## [2,]    8   12\n\n# Multiplicación de matrices\na * b\n##      [,1] [,2]\n## [1,]    5   21\n## [2,]   12   32\n\n# Comparación de matrices con el operador &gt;\na &gt; b\n##       [,1]  [,2]\n## [1,] FALSE FALSE\n## [2,] FALSE FALSE\n\n\n\n\n\n3.2.5.2 Tipos compuestos\n\n3.2.5.2.1 Data Frames\nUn data frame es una estructura bidimensional similar a lo que comúnmente se conoce como una tabla. Sus filas corresponden a las observaciones de un conjunto de datos y sus columnas a las variables. Internamente, se componen de varios vectores, factores y/o matrices de la misma longitud. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o una tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\n\n3.2.5.2.1.1 Definición\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\n\n# Vector de nombres de países\npaises &lt;-\n  c(\"Panamá\",\n    \"Costa Rica\",\n    \"Nicaragua\",\n    \"El Salvador\",\n    \"Honduras\",\n    \"Guatemala\",\n    \"Belice\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones &lt;- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises &lt;- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       4.1\n## 2  Costa Rica       5.0\n## 3   Nicaragua       6.2\n## 4 El Salvador       6.4\n## 5    Honduras       9.2\n## 6   Guatemala      16.9\n## 7      Belice       0.3\n\n\n\n3.2.5.2.1.2 Indexación\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\n\n# Fila 1\npoblaciones_paises[1, ]\n##     pais poblacion\n## 1 Panamá       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n##       pais poblacion\n## 1   Panamá       4.1\n## 5 Honduras       9.2\n## 7   Belice       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n## [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n## [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n## [1] 4.1 5.0 6.2 6.4\n\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\n\n# Columna de nombres de países\npoblaciones_paises$pais\n## [1] \"Panamá\"      \"Costa Rica\"  \"Nicaragua\"   \"El Salvador\" \"Honduras\"   \n## [6] \"Guatemala\"   \"Belice\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises_2 &lt;- poblaciones_paises # copia del dataframe original\npoblaciones_paises_2$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises_2\n##          pais poblacion\n## 1      Panamá       8.2\n## 2  Costa Rica      10.0\n## 3   Nicaragua      12.4\n## 4 El Salvador      12.8\n## 5    Honduras      18.4\n## 6   Guatemala      33.8\n## 7      Belice       0.6\n\nLa notación de paréntesis cuadrados ([]) y el signo de dólar ($) también permite crear subconjuntos con base en expresiones lógicas.\n\n# Ejemplos de uso de la notación $\n\n# Países con población mayor a 6 millones de habitantes\npoblaciones_paises[poblaciones_paises$poblacion &gt; 6,]\n\n         pais poblacion\n3   Nicaragua       6.2\n4 El Salvador       6.4\n5    Honduras       9.2\n6   Guatemala      16.9\n\n\n\n\n3.2.5.2.1.3 Operaciones\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\n\n# Lectura de archivo CSV ubicado en la Web\ncovid &lt;-\n  read.csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv\"\n  )\n\n# Despliegue de los datos del data frame\ncovid\n##          pais fallecidos recuperados activos positivos\n## 1      Panamá       6198      351949    3845    361992\n## 2  Costa Rica       3125      199779   32370    235274\n## 3   Guatemala       7345      194075   16725    218145\n## 4    Honduras       4981       77020  121358    203359\n## 5 El Salvador       2089       64208    1864     68161\n## 6      Belice        318       12164     114     12596\n## 7   Nicaragua        181        5212      57      5450\n\nLa función str() despliega la estructura de un data frame u otro objeto R.\n\n# Estructura del data frame\nstr(poblaciones_paises)\n\n'data.frame':   7 obs. of  2 variables:\n $ pais     : chr  \"Panamá\" \"Costa Rica\" \"Nicaragua\" \"El Salvador\" ...\n $ poblacion: num  4.1 5 6.2 6.4 9.2 16.9 0.3\n\n\nLa función summary() proporciona un resumen de los contenidos de un data frame:\n\n# Resumen de los contenidos del data frame\nsummary(poblaciones_paises)\n\n     pais             poblacion     \n Length:7           Min.   : 0.300  \n Class :character   1st Qu.: 4.550  \n Mode  :character   Median : 6.200  \n                    Mean   : 6.871  \n                    3rd Qu.: 7.800  \n                    Max.   :16.900  \n\n\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\n\n# Vista de los casos de COVID-19\nView(covid, \"Casos de COVID-19 en Centramérica\")\n\n\n\n\n3.2.5.2.2 Factores\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\n\n3.2.5.2.2.1 Definición\nUn factor se crea con la función factor().\n\n# Factor de valores de sexo\nsexo &lt;- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\n\n\n\n3.2.5.2.2.2 Operaciones\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\n\n# Etiquetas de los niveles\nlevels(sexo)\n## [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n## [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n## sexo\n##  Femenino Masculino \n##         2         2\n\n\n\n\n\n3.2.5.3 Otros\n\n3.2.5.3.1 Fechas\nLas fechas se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, una fecha en R se almacena como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\n\n3.2.5.3.1.1 Operaciones\nLa función Sys.Date() retorna la fecha actual.\n\n# Fecha actual\nfecha_actual &lt;- Sys.Date()\nfecha_actual\n## [1] \"2024-08-29\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n## [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n## [1] \"Date\"\n\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato. El formato que se usa por defecto (y el recomendado) es el que corresponde a la norma ISO 8601 (ej. 2023-12-03), pero pueden emplearse otros también.\n\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 &lt;- \"2020-01-01\"\nfecha_01 &lt;- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n\n[1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 &lt;- \"31/01/2020\"\nfecha_02 &lt;- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n\n[1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n\nTime difference of 30 days\n\n\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers.\n\n\n\n\n\n3.2.6 Definición de funciones\nAdemás de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.\nToda función tiene tres partes esenciales:\n\nUn nombre.\nUn conjunto de argumentos.\nUn conjunto de líneas de código, también llamado el cuerpo de la función.\n\nPara programar una función, debe definirse cada una de esas partes por medio de la palabra reservada function function().\nPor ejemplo, la siguiente función calcula la nota final de un curso con base en los argumentos correspondientes a los promedios de exámenes, proyectos y tareas.\n\n# Función que calcula la nota final de un curso\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos,\n                       promedio_tareas) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  return(factor_examenes + factor_proyectos + factor_tareas)\n}\n\nLa función return() es la que define el valor de retorno de la función. Si no se incluye, la función retorna la última expresión evaluada.\nAhora que está definida, la función nota_final() puede ser “llamada”, con diferentes argumentos:\n\n# Si ni se incluyen los nombres de los argumentos, \n# la función asume que se ingresan en el mismo orden en el que fueron definidos\nnota_final(100, 50, 0)\n## [1] 70\n\n# El uso de los nombres de argumentos \n# permite modificar su orden\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\n## [1] 70\n\nSi se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.\nSeguidamente, la función nota_final() se redefine asignando valores por defecto a algunos de los argumentos:\n\n# Redefinición de la función nota final,\n# con valores por defecto para los argumentos\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos = 0,\n                       promedio_tareas = 0) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  # Al no llamarse a la función return(), se retorna la última expresión:\n  factor_examenes + factor_proyectos + factor_tareas\n}\n\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\n## [1] 70\n\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\nnota_final(100, promedio_proyectos = 50)\n## [1] 70\n\nEjercicios\n1. Defina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.\n2. Defina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.\n3. Defina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros).\n\n\n3.2.7 Condicionales\nLas sentencias condicionales evalúan una expresión lógica (i.e. condición) y ejecutan, o no, un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.\nLos condicionales en R se implementa mediante la sentencia if y sus cláusulas else y else if.\n\n3.2.7.1 La sentencia if\nLa sentencia if evalúa una condición (i.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.\n\n# Sintaxis de la sentencia if\nif (condicion) {\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\n}\n\nPor ejemplo:\n\n# Edad de una persona\nedad &lt;- 25\n\n# Se utiliza la sentencia if para determinar \n# si la persona es adulta\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n}\n## [1] \"Adulto\"\n\nYa sea que se ejecute o no el bloque del if, el programa continúa con las instrucciones que siguen al bloque, si las hay.\n\n\n3.2.7.2 La cláusula else\nUna sentencia if puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa. Por ejemplo:\n\nedad &lt;- 15\n\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n} else {\n  print(\"Menor\")\n}\n\n[1] \"Menor\"\n\n\n\n\n3.2.7.3 La cláusula else if\nUna sentencia if también puede ir seguida de una o varias cláusulas else if, las cuales evalúan condiciones adicionales.\n\nedad &lt;- 70\n\nif (edad &lt; 18) {\n  print(\"Menor\")\n} else if (edad &lt; 65) {\n  print(\"Adulto\")\n} else {\n  print(\"Adulto mayor\")\n}\n\n[1] \"Adulto mayor\"\n\n\nLas cláusulas else if deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else if como la cláusula else son opcionales.\nEjercicios\n1. Defina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente a la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de masa corporal - Wikipedia.\n\n\n\n3.2.8 Ciclos\nLos ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con sentencias que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.\nLos ciclos en R se implementan mediante las sentencias for, while y repeat, en combinación con las sentencias break y next.\nR provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que no es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.\n\n3.2.8.1 La sentencia for\nLa sentencia for repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración (i.e. cada “vuelta” del ciclo), el valor del elemento que está siendo procesado se almacena en una variable.\n\n# Sintaxis de la sentencia for\nfor (variable in vector) {\n  # bloque de instrucciones\n}\n\nPor ejemplo, el siguiente bloque de código utiliza un ciclo de tipo for para recorrer un vector de nombres e imprimir un saludo para cada uno.\n\n# Vector con nombres de personas\nvector_nombres &lt;- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Recorrido del vector\nfor (nombre in vector_nombres) {\n  cat(\"Hola\", nombre, \"\\n\")\n}\n## Hola Andrés \n## Hola Beatriz \n## Hola Carlos \n## Hola Marta \n## Hola Pedro \n## Hola Sara\n\nEn el siguiente ejemplo, se utiliza otro ciclo for para recorrer un vector de números y sumar sus elementos.\n\n# Vector de números\nvector_numeros &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\n\n# Variable para la suma de los números\nsuma &lt;- 0\n\n# Recorrido del vector\nfor (x in vector_numeros) {\n  suma &lt;- suma + x\n}\n\n# Impresión de la suma\ncat(\"Suma:\", suma)\n## Suma: 140.95\n\nSeguidamente, se utiliza dos for “anidados” para sumar los elementos de cada una de las columnas de una matriz.\n\n# Matriz de números\nmatriz_numeros &lt;- matrix(1:12, nrow=3, ncol=4)\nmatriz_numeros\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\n# Ciclo externo para recorrer las columnas de la matriz\nfor (j in 1:ncol(matriz_numeros)) {\n  suma_columna &lt;- 0\n  # Ciclo interno para recorrer las elementos de cada columna\n  for (i in 1:nrow(matriz_numeros)) {\n    suma_columna &lt;- suma_columna + matriz_numeros[i, j]\n  }\n  print(suma_columna)\n}\n## [1] 6\n## [1] 15\n## [1] 24\n## [1] 33\n\nEjercicios\n1. Utilice un ciclo for para recorrer el vector vector_numeros y calcular el promedio de sus elementos.\n2. Utilice dos ciclos for anidados para recorrer la matriz vector_numeros y calcular el promedio de cada una de sus columnas.\n\n\n3.2.8.2 La sentencia while\nLa sentencia while evalúa una condición (i.e. una expresión lógica) en cada iteración de un ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.\n\n# Sintaxis de la sentencia while\nwhile (condicion) {\n  # bloque de instrucciones \n}\n\nEn el siguiente ejemplo, se utiliza un ciclo while para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta &lt;- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\nwhile (leer_respuesta() != \"42\") {   \n  print(\"¡Su respuesta es incorrecta!\")\n}\n\nEjercicios\n1. Utilice un ciclo while para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#recursos-de-interés",
    "href": "03-r.html#recursos-de-interés",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.3 Recursos de interés",
    "text": "3.3 Recursos de interés\nFind Open Datasets and Machine Learning Projects | Kaggle. (s. f.). Recuperado 24 de abril de 2022, de https://www.kaggle.com/datasets\nIndicators | Data. (s.f.). Recuperado 11 de septiembre de 2022, de https://data.worldbank.org/indicator\nNewest «r» Questions. (s. f.). Stack Overflow. Recuperado 24 de abril de 2022, de https://stackoverflow.com/questions/tagged/r\nPapers with Code—Machine Learning Datasets. (s.f.). Recuperado 11 de septiembre de 2022, de https://paperswithcode.com/datasets\nR Language Definition. (s. f.). Recuperado 24 de abril de 2022, de https://cran.r-project.org/doc/manuals/r-release/R-lang.html\nR Package Documentation. (s.f.). Recuperado 11 de septiembre de 2022, de https://rdrr.io/\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "href": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "title": "III - Herramientas para investigación reproducible y desarrollo colaborativo",
    "section": "",
    "text": "5 Reproducibilidad\n6 Markdown - lenguaje de marcado\n7 Git - sistema de control de versiones\n8 Quarto - sistema de publicación técnica y científica",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo"
    ]
  },
  {
    "objectID": "04-markdown.html",
    "href": "04-markdown.html",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#trabajo-previo",
    "href": "04-markdown.html#trabajo-previo",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Lecturas\nQuarto - Markdown Basics. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/authoring/markdown-basics.html\n\n\nTutoriales\nMarkdown Tutorial. (s.f.). Recuperado el 1 de marzo de 2024, de https://www.markdowntutorial.com/",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#introducción",
    "href": "04-markdown.html#introducción",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "Introducción",
    "text": "Introducción\nMarkdown es un lenguaje de marcado, creado en 2004 por John Gruber y Aaron Swartz. Las “marcas” se utilizan para especificar aspectos de la estructura (ej. títulos, encabezados), estilo (ej. negritas, itálicas) y semántica de un documento. Markdown se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcado (ej. Lenguaje de Marcado de Hipertexto o HTML), por lo que se considera un lenguaje de marcado ligero.\nLos documentos escritos en Markdown pueden exportarse a una gran variedad de formatos (ej. HTML, DOC, PDF, LaTex) para ser usados en libros, presentaciones o páginas web, entre otros fines.\nLas variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:\n\nR Markdown: para el lenguaje R.\nQuarto: es la “siguiente generación” de R Markdown, con soporte para más lenguajes de programación (Python, Julia, Observable, R) y motores de procesamiento (Jupyter, Knitr), entre otras mejoras. Más que una variación de Markdown es un sistema de publicación de documentos técnicos y científicos que utiliza Markdown.\nPython Markdown: para el lenguaje Python.\nGitHub Flavored Markdown: para la plataforma GitHub.\nPandoc’s Markdown: para el programa Pandoc de conversión entre formatos.\n\nPuede encontrarse una lista más extensa de variaciones de Markdown en Markdown Flavors.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#ejemplo-de-documento",
    "href": "04-markdown.html#ejemplo-de-documento",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.1 Ejemplo de documento",
    "text": "4.1 Ejemplo de documento\nEl siguiente es un ejemplo de documento Markdown. Se muestra primero la sintaxis del documento y luego la manera en la que se visualiza.\n\n4.1.1 Sintaxis\nLa sintaxis del documento incluye marcas para un encabezado, texto en negrita, texto en itálica, hipervínculos y una imagen.\n\n\n### Los satélites galileanos\n\nSe llaman **satélites galileanos** los cuatro satélites de\n[Júpiter](https://es.wikipedia.org/wiki/J%C3%BApiter_(planeta))\ndescubiertos en 1610 por el astrónomo italiano\n[Galileo Galilei](https://es.wikipedia.org/wiki/Galileo_Galilei) (1564 - 1642): \n*Ío*, *Europa*, *Ganimedes* y *Calisto*. \nSon los más grandes de los satélites de Júpiter, \nsiendo visibles incluso con telescopios de baja potencia.\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n**Figura 1**. Los cuatro satélites galileanos, \nen una composición que compara sus tamaños con el tamaño de Júpiter. \nEn orden descendente, son *Ío*, *Europa*, *Ganimedes* y *Calisto*.\n\n\n\n\n4.1.2 Visualización\n\n\n\nLos satélites galileanos\nSe llaman satélites galileanos los cuatro satélites de Júpiter descubiertos en 1610 por el astrónomo italiano Galileo Galilei (1564 - 1642): Ío, Europa, Ganimedes y Calisto. Son los más grandes de los satélites de Júpiter, siendo visibles incluso con telescopios de baja potencia.\n\nFigura 1. Los cuatro satélites galileanos, en una composición que compara sus tamaños con el tamaño de Júpiter. En orden descendente, son Ío, Europa, Ganimedes y Calisto.\n\nEl contenido de este ejemplo está basado en Satélite galileano - Wikipedia, la enciclopedia libre.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#herramientas-para-escritura-de-documentos",
    "href": "04-markdown.html#herramientas-para-escritura-de-documentos",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.5 Herramientas para escritura de documentos",
    "text": "4.5 Herramientas para escritura de documentos\nMarkdown se escribe en “texto simple o plano” (i.e. texto sin formato, compuesto únicamente por caracteres que son legibles por humanos), por lo que puede escribirse con cualquier editor de texto. Se recomienda el uso de editores orientados a programación, también llamados editores de código fuente, los cuales proporcionan facilidades para el programador, como coloración de palabras clave, sangrado y autocompletado, entre otras.\nTambién pueden utilizarse Entornos Integrados de Desarrollo o IDE, los cuales son aplicaciones informáticas que proporcionan servicios integrales para facilitarle al programador el desarrollo de software. Además de un editor de código fuente, un IDE incluye funciones para depuración (i.e. identificación de errores), interpretación y compilación de programas, entre otras.\nAlgunos de los editores de código fuente o IDE recomendados para Markdown son:\n\nVisual Studio Code: editor de código fuente muy popular y de código abierto. Puede editar código de múltiples lenguajes de programación y sintaxis asociadas\nRStudio: IDE para desarrollo en el lenguaje de programación R, el cual también puede manejar código en otros lenguajes de programación y sintaxis.\n\nNo se recomienda el uso de procesadores de texto (ej. Microsoft Word, Libre Office Writer), debido a que introducen caracteres especiales que no son reconocidos por Markdown.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#sintaxis",
    "href": "04-markdown.html#sintaxis",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.6 Sintaxis",
    "text": "4.6 Sintaxis\nEn esta sección, se muestran los principales elementos de sintaxis de Markdown y sus salidas.\n\n\n4.6.1 Encabezados\nHay seis niveles de encabezados en Markdown, siendo el nivel 1 el de letras más grandes y el 6 el de letras más pequeñas. Se especifican mediante símbolos de numeral (#) antes del texto del encabezado (note el espacio entre el último signo de numeral y el inicio del texto).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n# Encabezado de nivel 1\n\n\n\nEncabezado de nivel 1\n\n\n\n\n\n## Encabezado de nivel 2\n\n\n\nEncabezado de nivel 2\n\n\n\n\n\n### Encabezado de nivel 3\n\n\n\nEncabezado de nivel 3\n\n\n\n\n\n#### Encabezado de nivel 4\n\n\n\nEncabezado de nivel 4\n\n\n\n\n\n##### Encabezado de nivel 5\n\n\n\nEncabezado de nivel 5\n\n\n\n\n\n###### Encabezado de nivel 6\n\n\n\nEncabezado de nivel 6\n\n\n\n\nPara los encabezados de nivel 1 y nivel 2, existe una sintaxis alterna, con símbolos de igual (=====) o guiones (-----) bajo el texto del encabezado.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nOtro encabezado de nivel 1 ==========================\n\n\n\n\nOtro encabezado de nivel 1\n\n\n\n\n\nOtro encabezado de nivel 2 --------------------------\n\n\n\nOtro encabezado de nivel 2\n\n\n\n\n\n\n4.6.2 Párrafos\nLos párrafos deben separarse mediante (al menos) una línea en blanco. Un simple cambio de línea no generará un nuevo párrafo.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\n\n\n\n4.6.3 Negrita\nHay dos sintaxis para especificar texto en negrita: con dos asteriscos (**) o con dos guiones bajos (__), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n**Texto en negrita**\n\n\nTexto en negrita\n\n\n\n\n__Otro texto en negrita__\n\n\nOtro texto en negrita\n\n\n\n\n\n4.6.4 Itálica\nHay dos sintaxis para especificar texto en itálica: con un asterisco (*) o con un guión bajo (_), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n*Texto en itálica*\n\n\nTexto en itálica\n\n\n\n\n_Otro texto en itálica_\n\n\nOtro texto en itálica\n\n\n\n\n\n4.6.5 Citas textuales\nSe especifican con un símbolo de “mayor que” (&gt;) antes de cada línea.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n&gt; *And on the pedestal these words appear:* &gt; *\"My name is Ozymandias, king of kings:* &gt; *Look on my works, ye Mighty, and despair!\"* *Percy Bysshe Shelley, \"Ozymandias\" (1818)*\n\n\n\n “And on the pedestal these words appear:”My name is Ozymandias, king of kings: Look on my works, ye Mighty, and despair!“ \n\nPercy Bysshe Shelley, “Ozymandias” (1818)\n\n\n\n\n\n4.6.6 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento al que conduce el enlace.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n[Proyecto Gutenberg](https://www.gutenberg.org/)\n\n\nProyecto Gutenberg\n\n\n\n\n\n4.6.7 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n![Imagen local](img/Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n![Imagen remota](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n\n4.6.8 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento.\n2. Segundo elemento.\n3. Tercer elemento.\n\n\n\n\nPrimer elemento.\nSegundo elemento.\nTercer elemento.\n\n\n\n\n\n\n4.6.9 Listas no numeradas\nSe definen con guiones (-) o asteriscos (*) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento.\n- Otro elemento.\n- Otro elemento más.\n\n\n\n\nUn elemento.\n\nOtro elemento.\n\nOtro elemento más.\n\n\n\n\n\n\n\n4.6.10 Notación matemática\nLas expresiones en notación matemática (ej. ecuaciones) se escriben con base en la sintaxis de LaTeX. Se delimitan (al inicio y al final) con:\n\nUn símbolo de dólar ($), para ecuaciones dentro de un renglón (inline math).\nDos símbolos de dólar ($$), para ecuaciones en su propio bloque (display math).\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEquivalencia entre masa y energía: $E = mc^{2}$\n\n\n\nEquivalencia entre masa y energía: \\(E = mc^{2}\\)\n\n\n\n\nEquivalencia entre masa y energía: $$E = mc^{2}$$\n\n\nEquivalencia entre masa y energía:\n\\[E = mc^{2}\\]\n\n\n\nPara más detalles sobre la sintaxis de las expresiones matemáticas, se recomienda consultar:\n\nWriting mathematical expressions - GitHub Docs\nLaTeX/Mathematics",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#ejercicios",
    "href": "04-markdown.html#ejercicios",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.3 Ejercicios",
    "text": "4.3 Ejercicios\n\nEn RStudio, cree un nuevo proyecto con la opción File - New Project - New Directory - New Project de RStudio.\nEn el nuevo proyecto, cree un nuevo documento Markdown con la opción File - New File - Markdown File de RStudio. y escriba en este un breve curriculum académico o profesional.\n\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.\nPuede usar información ficticia (no incluya datos confidenciales o sensibles).\nEspecifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y no utilice imágenes para las que no tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).\nAsegúrese de utilizar los siguientes elementos de sintaxis Markdown:\n\nEncabezados de varios niveles.\nNegritas e itálicas.\nListas.\nEnlaces a sitios web.\nImágenes (al menos una local y una remota).\n\n\nGuarde el documento con el nombre README.md (RStudio asigna la extensión automáticamente).\nCree una cuenta gratuita en la plataforma de desarrollo colaborativo de software GitHub.\nCree un repositorio vacío en su cuenta en GitHub (ej. curriculum-vitae).\nSuba al nuevo repositorio el archivo README.md.\nGenere un sitio web en el servicio de alojamiento GitHub Pages con la opción Settings - Pages - Branch - main - Save de GitHub.\nRepita los pasos 6 y 7 para cada modificación que realice en el documento Markdown.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#recursos-de-interés",
    "href": "04-markdown.html#recursos-de-interés",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.4 Recursos de interés",
    "text": "4.4 Recursos de interés\nDaring Fireball: Markdown. (s. f.). Recuperado 25 de marzo de 2023, de https://daringfireball.net/projects/markdown/\nLaTeX/Mathematics—Wikibooks, open books for an open world. (s. f.). Recuperado 25 de marzo de 2023, de https://en.wikibooks.org/wiki/LaTeX/Mathematics\nMarkdown Guide. (s. f.). Recuperado 10 de abril de 2022, de https://www.markdownguide.org/\nWriting mathematical expressions. (s. f.). GitHub Docs. Recuperado 25 de marzo de 2023, de https://ghdocs-prod.azurewebsites.net/en/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#sintaxis-1",
    "href": "04-markdown.html#sintaxis-1",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.2 Sintaxis",
    "text": "4.2 Sintaxis\nEn esta sección, se muestran los principales elementos de sintaxis de Markdown y sus salidas.\n\n\n4.2.1 Encabezados\nHay seis niveles de encabezados en Markdown, siendo el nivel 1 el de letras más grandes y el 6 el de letras más pequeñas. Se especifican mediante símbolos de numeral (#) antes del texto del encabezado (note el espacio entre el último signo de numeral y el inicio del texto).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n# Encabezado de nivel 1\n\n\n\nEncabezado de nivel 1\n\n\n\n\n\n## Encabezado de nivel 2\n\n\n\nEncabezado de nivel 2\n\n\n\n\n\n### Encabezado de nivel 3\n\n\n\nEncabezado de nivel 3\n\n\n\n\n\n#### Encabezado de nivel 4\n\n\n\nEncabezado de nivel 4\n\n\n\n\n\n##### Encabezado de nivel 5\n\n\n\nEncabezado de nivel 5\n\n\n\n\n\n###### Encabezado de nivel 6\n\n\n\nEncabezado de nivel 6\n\n\n\n\nPara los encabezados de nivel 1 y nivel 2, existe una sintaxis alterna, con símbolos de igual (=====) o guiones (-----) bajo el texto del encabezado.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nOtro encabezado de nivel 1 ==========================\n\n\n\n\nOtro encabezado de nivel 1\n\n\n\n\n\nOtro encabezado de nivel 2 --------------------------\n\n\n\nOtro encabezado de nivel 2\n\n\n\n\n\n\n4.2.2 Párrafos\nLos párrafos deben separarse mediante (al menos) una línea en blanco.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\n\n\n\n4.2.3 Cambios de línea\nSi se requiere un cambio de línea sin una línea en blanco entre párrafos, pueden agregarse dos espacios en blanco al final de la línea () o también un espacio y una barra invertida (\\).\n\n\n4.2.4 Texto en negrita\nHay dos sintaxis para especificar texto en negrita: con dos asteriscos (**) o con dos guiones bajos (__), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n**Texto en negrita**\n\n\nTexto en negrita\n\n\n\n\n__Otro texto en negrita__\n\n\nOtro texto en negrita\n\n\n\n\n\n4.2.5 Texto en itálica\nHay dos sintaxis para especificar texto en itálica: con un asterisco (*) o con un guión bajo (_), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n*Texto en itálica*\n\n\nTexto en itálica\n\n\n\n\n_Otro texto en itálica_\n\n\nOtro texto en itálica\n\n\n\n\n\n4.2.6 Texto tachado\nEl texto tachado se especifica con dos guiones (--) antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n--Texto tachado--\n\n\nTexto tachado\n\n\n\n\n\n4.2.7 Superíndices y subíndices\nUn superíndice se especifica con un acento circunflejo (^) antes y después del texto que se desea mostrar como superíndice. Un subíndice se especifica con un guión (-) antes y después del texto que se desea mostrar como subíndice.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nsuperíndice^2^\n\n\nsuperíndice2\n\n\n\n\nsubíndice-2-\n\n\nsubíndice2\n\n\n\n\n\n4.2.8 Líneas horizontales\nTres o más asteriscos (***) generan una línea horizontal:\n***\n\nTambién puede generarse con tres o más guiones (---):\n---\n\n\n\n4.2.9 Citas textuales\nSe especifican con un símbolo de “mayor que” (&gt;) antes de cada línea.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n&gt; *And on the pedestal these words appear:*\n&gt; *\"My name is Ozymandias, king of kings:*\n&gt; *Look on my works, ye Mighty, and despair!\"*\nPercy Bysshe Shelley, \"Ozymandias\" (1818)\n\n\n\n And on the pedestal these words appear: “My name is Ozymandias, king of kings: Look on my works, ye Mighty, and despair!” \n\nPercy Bysshe Shelley, “Ozymandias” (1818)\n\n\n\n\n\n4.2.10 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento al que conduce el enlace.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n[Proyecto Gutenberg](https://www.gutenberg.org/)\n\n\nProyecto Gutenberg\n\n\n\n\n\n4.2.11 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota. Una imagen local se encuentra en la misma computadora en la que está el documento que la referencia, mientras que una imagen remota se encuentra en otra computadora a la que se accede mediante un protocolo de redes como el Protocolo de transferencia de hipertexto (HTTP).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n![Imagen local](img/Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n![Imagen remota](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\nMarkdown no cuenta con sintaxis para especificar el tamaño de una imagen, pero esto puede lograrse con el Lenguaje de marcado de hipertexto (HTML, HyperText Markup Language), su elemento img y sus atributos height y width, los cuales especifican la altura y el ancho de una imagen (las unidades por defecto son pixeles).\nPor ejemplo, la expresión HTML:\n&lt;img src=\"img/Jupiter_and_the_Galilean_Satellites.jpg\" height=\"100\" alt=\"Imagen local\"&gt;\ngenera como salida una imagen de 100 pixeles de altura:\n\nSi se usa solo el atributo height, width se ajusta automáticamente y viceversa.\n\n\n4.2.12 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento.\n2. Segundo elemento.\n3. Tercer elemento.\n\n\n\n\nPrimer elemento.\nSegundo elemento.\nTercer elemento.\n\n\n\n\nLas listas numeradas pueden anidarse para mostrar la información de una forma jerárquica. Para crear un nivel de anidación, deben usarse sangrías con una cantidad de espacios consistente en toda la lista. La numeración se ordena automáticamente (incluso si hay errores).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento\n            1. Elemento anidado\n            2. Elemento anidado\n2. Segundo elemento\n            1. Elemento anidado\n            2. Elemento anidado\n3. Tercer elemento\n            1. Elemento anidado\n            2. Elemento anidado\n\n\n\n\nPrimer elemento\n\nElemento anidado\nElemento anidado\n\nSegundo elemento\n\nElemento anidado\nElemento anidado\n\nTercer elemento\n\nElemento anidado\nElemento anidado\n\n\n\n\n\n\n\n4.2.13 Listas no numeradas\nSe definen con guiones (-), asteriscos (*) o signos de adición (+) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento\n- Otro elemento\n- Otro elemento más\n\n\n\n\nUn elemento\n\nOtro elemento\n\nOtro elemento más\n\n\n\n\n\nLas listas no numeradas también pueden anidarse. Debe utilizarse un mínimo de dos espacios en los elementos anidados.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento\n            + Elemento anidado\n            + Elemento anidado\n- Otro elemento\n            + Elemento anidado\n            + Elemento anidado\n- Otro elemento más\n            + Elemento anidado\n            + Elemento anidado\n\n\n\n\nUn elemento\n\nElemento anidado\nElemento anidado\n\nOtro elemento\n\nElemento anidado\nElemento anidado\n\nOtro elemento más\n\nElemento anidado\nElemento anidado\n\n\n\n\n\nLas listas numeradas y las no numeradas pueden intercalarse.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento\n            - Elemento anidado\n            - Elemento anidado\n2. Segundo elemento\n            - Elemento anidado\n            - Elemento anidado\n3. Tercer elemento\n            - Elemento anidado\n            - Elemento anidado\n\n\n\n\nPrimer elemento\n\nElemento anidado\nElemento anidado\n\nSegundo elemento\n\nElemento anidado\nElemento anidado\n\nTercer elemento\n\nElemento anidado\nElemento anidado\n\n\n\n\n\n\n\n4.2.14 Notación matemática\nLas expresiones en notación matemática (ej. ecuaciones) se escriben con base en la sintaxis de LaTeX. Se delimitan (al inicio y al final) con:\n\nUn símbolo de dólar ($), para ecuaciones dentro de un renglón (inline math).\nDos símbolos de dólar ($$), para ecuaciones en su propio bloque (display math).\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEquivalencia entre masa y energía: $E = mc^{2}$\n\n\n\nEquivalencia entre masa y energía: \\(E = mc^{2}\\)\n\n\n\n\nEquivalencia entre masa y energía: $$E = mc^{2}$$\n\n\nEquivalencia entre masa y energía:\n\\[E = mc^{2}\\]\n\n\n\nPara más detalles sobre la sintaxis de las expresiones matemáticas, se recomienda consultar:\n\nWriting mathematical expressions - GitHub Docs\nLaTeX/Mathematics\n\n\n\n4.2.15 Bloques de código fuente\nLos documentos Markdown pueden contener bloques de código fuente, ya sea incrustados en una línea de texto (inline) o en líneas separadas.\n\n4.2.15.1 Bloques en línea\nPara mostrar fragmentos cortos de código en una sola línea dentro del texto, se usa una sola comilla invertida o backtick para delimitar el código.\nPor ejemplo, la sintaxis:\nEste es un fragmento de código en línea: `x = 10`\ngenera:\nEste es un fragmento de código en línea: x = 10\n\n\n4.2.15.2 Bloques multilínea\nPara fragmentos de código de múltiples líneas, se utilizan tres comillas invertidas o una sangría de cuatro espacios al inicio de cada línea.\nEl siguiente es un ejemplo de bloque de código delimitado con comillas invertidas (la forma más usada):\n\n```\nfunction sumar(a, b) {\n  return a + b;\n}\n```\n\nSe visualiza como:\nfunction sumar(a, b) {\n  return a + b;\n}\nSi el código es de un lenguaje específico, puede indicarse para resaltar (y colorear) la sintaxis. Por ejemplo, para un bloque de código en R, se escribe r después de las tres comillas invertidas.\nSintaxis de código en R:\n\n```r\n# Gráfico de dispersón del conjunto de datos cars con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n```\n\nVisualización de código en R:\n# Gráfico de dispersón del conjunto de datos cars con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\nEl uso de resaltado de sintaxis con bloques de código lo hace más fácil de leer y comprender. El resultado (colores, fuentes de texto, etc.) de sintaxis depende de la plataforma o editor de Markdown que se utilice. Plataformas como GitHub y algunos editores soportan muchos lenguajes, mientras que otros pueden no reconocer todos.\nPara más información sobre el uso de bloques de código en documentos Markdown, se recomienda consultar:\n\nCreating and highlighting code blocks\nThe languages YAML file\nMarkdown Code Block: Including Code In .md Files - Markdown Land\n\nNótese que los bloques de código en un documento Markdown normal (con extensión .md) no se ejecutan, solo se muestran. Sin embargo, hay sistemas como Quarto y Jupyter Notebooks que permiten combinar narrativa em Markdown con bloques de código ejecutables.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "05-quarto.html",
    "href": "05-quarto.html",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#trabajo-previo",
    "href": "05-quarto.html#trabajo-previo",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Lecturas\nQuarto - Tutorial: Hello, Quarto. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/get-started/hello/rstudio.html",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#introducción",
    "href": "05-quarto.html#introducción",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "Introducción",
    "text": "Introducción\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Entre sus principales capacidades están:\n\nCrear contenido dinámico con los lenguajes R, Python, Julia y Observable.\nCrear documentos Markdown de texto plano o cuadernos de notas de Jupyter.\nPublicar artículos académicos, reportes, presentaciones, sitios web, blogs y libros en HTML, PDF, MS Word, ePub y otros formatos.\nCrear contenido científico, incluyendo ecuaciones, citas bibliográficas, referencias cruzadas, figuras y otros elementos.\n\nQuarto es la siguiente generación de R Markdown, un formato que permite insertar código en R, y sus salidas, en documentos escritos en Markdown. R Markdown fue introducido por Yihui Xie en 2012, junto con el paquete knitr, cuyo propósito es facilitar la investigación reproducible en R a través de la programación literaria (literate programming), un paradigma de programación propuesto por Donald Knuth en 1984.\nLos programas “literarios” (o “letrados”) están escritos como una exposición lógica en un lenguaje humano similar a la explicación de las fórmulas y ecuaciones empleadas para representar y resolver un problema en un texto de física o de matemáticas. En estos programas, se describe el análisis del problema, su solución y su implementación, intercalando código fuente entre los párrafos (y otros contenidos como imágenes, tablas, gráficos estadísticos y mapas), de forma similar a como en los textos de matemáticas se intercalan las fórmulas y las ecuaciones. La programación literaria puede mejorar enormemente un programa, ya que permite documentar ampliamente en qué consiste el problema a resolver, cómo se resuelve, cómo y por qué se adoptó cierto diseño, cómo se optimizó y cómo se implementó en un lenguaje de programación.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#anatomía-de-un-documento-quarto",
    "href": "05-quarto.html#anatomía-de-un-documento-quarto",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.1 Anatomía de un documento Quarto",
    "text": "5.1 Anatomía de un documento Quarto\nUn documento Quarto tiene tres tipos de contenido:\n\nMetadatos en YAML.\nNarrativa en Markdown.\nBloques de código fuente.\n\n\n5.1.1 Metadatos en YAML\nTodo documento Quarto inicia con un encabezado en la sintaxis YAML (YAML Ain’t Markup Language), el cual contiene metadatos del documento como el título, el autor, la fecha de creación, el formato de salida y la estructura de la tabla de contenidos, entre muchos otros.\nUn encabezado YAML comienza y termina con tres guiones (---) y contiene un conjunto de campos y valores de la forma:\n---\ncampo01: valor01\ncampo02: valor02\ncampo0n: valor0n\n---\nPor ejemplo, un encabezado YAML típico puede ser el siguiente:\n---\ntitle: Mi primer documento Quarto\nformat:\n  html:\n    toc: true\n    toc_float: true\n---\nLos campos del encabezado que dependen de otros campos se anidan con sangrías de dos espacios.\nLos elementos de metadatos que pueden especificarse en el encabezado, pueden variar de acuerdo al formato de salida, como puede verse en los siguientes enlaces:\n\nElementos de metadatos para HTML\nElementos de metadatos para PDF\nElementos metadatos para MS Word\n\nExisten elementos de metadatos para muchos otros formatos de salida (OpenOffice, ePub, presentaciones, wikis, etc.), como puede apreciarse en la Referencia de Quarto.\n\n\n5.1.2 Narrativa en Markdown\nLa narrativa proporciona estructura y contenido al documento en la forma de encabezados, párrafos, enlaces y otros elementos de la sintaxis de Markdown.\n\n\n5.1.3 Bloques de código fuente\nEn Quarto, los bloques (chunks) de código fuente se delimitan con tres backticks, tanto al inicio como al final del bloque. Los bloques de código en R se identifican con {r} y diferentes opciones identificadas con #|. Los bloques de otros lenguajes de programación se identifican con {python} y {julia}, por ejemplo.\nEl siguiente es un ejemplo de bloque de código en R y su salida:\n```{r}\n#| label: graficacion-cars\n#| include: true\n#| echo: false\n\nplot(\n  x = cars$speed,\n  y = cars$dist,\n  main = \"Velocidad vs distancia de frenado\",\n  xlab = \"Velocidad (MPH)\",\n  ylab = \"Distancia (pies)\"\n)\n```\n\n\n\n\n\n\n\n\n\nLa opción label se utiliza para etiquetar el bloque y la de include para especificar si se desea que el bloque y sus resultados se incluyan en el documento de salida.\nLa documentación de las diferentes opciones disponibles para los bloques de código que utilizan el motor (engine) Knitr (el más utilizado con R) se encuentra en Code Cells: Knitr - Quarto.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#cómo-funciona-quarto",
    "href": "05-quarto.html#cómo-funciona-quarto",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.2 ¿Cómo funciona Quarto?",
    "text": "5.2 ¿Cómo funciona Quarto?\nQuarto se apoya en knitr y en Pandoc. knitr ejecuta el código en R (u otro lenguaje) y convierte los documentos a Markdown. Por su parte, Pandoc exporta los documentos Markdown al formato de salida deseado (ej. HTML, PDF, MS Word, MS PowerPoint). Este proceso se ilustra en la Figura 5.1.\n\n\n\n\n\n\nFigura 5.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#ejercicios",
    "href": "05-quarto.html#ejercicios",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.3 Ejercicios",
    "text": "5.3 Ejercicios\nCon Quarto, cree un sitio web en GitHub Pages que muestre los gráficos que programó en la tarea 1 de este curso.\nSeguidamente, se sugiere una serie de pasos para elaborar el sitio.\n\nCree un nuevo proyecto con la opción File - New Project - New Directory - New Project de RStudio.\nEn el nuevo proyecto, cree un nuevo documento con la opción File - New File - Quarto Document de RStudio. Llene los metadatos (título, autor, etc.). Elija HTML como formato de salida.\nGuarde el documento con el nombre index.qmd (RStudio asigna la extensión automáticamente).\nAl inicio del documento, agregue narrativa en Markdown que explique el contenido, la fuente de los datos y la dirección del repositorio en GitHub con el código fuente (este repositorio se crea en un paso posterior).\nAgregue los gráficos y los comentarios de la tarea 1 mediante bloques de código en R y narrativa en Markdown. Divida el documento en secciones mediante el uso de encabezados. Se recomienda asignar una etiqueta a cada bloque de código con la opción #| label:. Considere el uso de otras etiquetas Quarto para, por ejemplo, controlar el despliegue de las salidas y del código fuente.\nPresione el botón Render de RStudio para generar el archivo index.html. Este será el arhivo que se desplegará en GitHub Pages.\nCree un repositorio vacío en su cuenta en GitHub (ej. graficos-base-r).\nSuba al nuevo repositorio los archivos index.qmd e index.html.\nGenere el sitio en GitHub Pages con la opción Settings - Pages - Branch - main - Save de GitHub.\nRepita los pasos 6, 8 y 9 para cada modificación que realice en el documento Quarto.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#recursos-de-interés",
    "href": "05-quarto.html#recursos-de-interés",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.4 Recursos de interés",
    "text": "5.4 Recursos de interés\nCode Cells: Knitr - Quarto (opciones para bloques de código). (s. f.). Recuperado el 26 de setiembre de 2024, de Code Cells: Knitr - Quarto\n\n\n\nFigura 5.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-git.html",
    "href": "05-git.html",
    "title": "5  Git - sistema de control de versiones",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#trabajo-previo",
    "href": "05-git.html#trabajo-previo",
    "title": "5  Git - sistema de control de versiones",
    "section": "",
    "text": "Instalación de software\nInstale en su computadora: Git\n\n\nTutoriales\nAbba, Ihechikara Vincent (2021). Git and GitHub Tutorial – Version Control for Beginners. freeCodeCamp.Org. https://www.freecodecamp.org/news/git-and-github-for-beginners/",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#introducción",
    "href": "05-git.html#introducción",
    "title": "5  Git - sistema de control de versiones",
    "section": "Introducción",
    "text": "Introducción\nGit es un sistema de control de versiones diseñado para “rastrear” cambios en el código fuente durante el proceso de desarrollo de software. Sin embargo, puede ser utilizado para llevar el control de los cambios en cualquier conjunto de archivos (ej. documentación, música).\nUn sistema de control de versiones proporciona, entre otras ventajas:\n\nLa capacidad de recuperar versiones anteriores de los archivos.\nLa capacidad de integrar modificaciones efectuadas por varias personas en el mismo conjunto de archivos.\nLa capacidad de mantener varias “ramas” (branches) de un producto (ej. “estable”, “evaluación”, “inestable”, como en el caso de Debian Linux, GRASS GIS y muchos otros proyectos de software libre).\nFacilidades para mantener redundancia y respaldos de los archivos (ej. Programa de respaldos de GitHub). Esta es una facilidad que implementan algunos servicios en la nube.\n\nGit fue diseñado por Linus Torvalds en 2005 durante del desarrollo del kernel del sistema operativo Linux. Se caracteriza por ser un sistema de control de versiones distribuido, lo que significa que el código fuente puede estar alojado en la estación de trabajo de cualquier miembro del equipo de desarrollo. No requiere un repositorio “central”, pero también puede trabajar de esa forma.\nEl protocolo de Git es utilizado en varios sitios que proveen servicios de alojamiento de software, entre los que están SourceForge, Bitbucket, GitLab y GitHub.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#funcionamiento-de-git",
    "href": "05-git.html#funcionamiento-de-git",
    "title": "5  Git - sistema de control de versiones",
    "section": "5.1 Funcionamiento de Git",
    "text": "5.1 Funcionamiento de Git\nDesde el punto de vista de un usuario de Git (ej. un programador), Git se utiliza para sincronizar la versión local (i.e. en una computadora personal) de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente a través de dos operaciones:\n\npush: para “subir” al repositorio remoto los cambios realizados en el repositorio local. Esta operación se realiza mediante el comando git push. Es probable que el sistema remoto le solicite al usuario algún tipo de autenticación (ej. nombre de usuario y clave).\npull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto. Esta operación se realiza mediante el comando git pull.\n\nLas operaciones push y pull se ilustran en la Figura 5.1.\n\n\n\n\n\n\nFigura 5.1: Operaciones push y pull. Imagen de Melinda Higgins.\n\n\n\nAntes de un push, el usuario debe seleccionar los archivos que desea subir mediante el comando git add, el cual pasa los archivos a un “área de espera” (staging area). Luego debe usarse el comando git commit para “guardar” los cambios pendientes en el área de espera. Cada commit guarda el estado del conjunto de archivos en un momento específico (snapshot).\nLa relación entre estas operaciones de Git, se ilustra en la Figura 5.2.\n\n\n\n\n\n\nFigura 5.2: Operaciones de Git. Imagen de Steven Klavins.\n\n\n\nEn la Figura 5.3, se muestra el funcionamiento de Git mediante una comparación con el procesamiento de una compra en línea.\n\n\n\n\n\n\nFigura 5.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.\n\n\n\nOtras operaciones de Git de uso frecuente son:\n\ngit config: para especificar opciones globales de la sesión de Git (ej. nombre del usuario, dirección de correo electrónico).\ngit init: para inicializar un repositorio git.\ngit clone: para clonar (i.e. copiar) un repositorio remoto en la computadora local.\ngit status: para revisar el estado de los archivos y, por ejemplo, saber cuales deben pasarse al área de espera.\ngit log: para revisar el historial de commits.\ngit show: para visualizar los cambios efectuados en los commits.\ngit reset: para regresar al estado correspondiente a un commit anterior.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#recursos-de-interés",
    "href": "05-git.html#recursos-de-interés",
    "title": "5  Git - sistema de control de versiones",
    "section": "5.2 Recursos de interés",
    "text": "5.2 Recursos de interés\nGit. (s. f.). Recuperado 28 de agosto de 2022, de https://git-scm.com/\nGitHub Archive Program. (s. f.). GitHub Archive Program. Recuperado 10 de abril de 2022, de https://archiveprogram.github.com/\nHiggins, M. (s. f.). Reproducible Templates for Analysis and Dissemination. Coursera. Recuperado 11 de abril de 2022, de https://www.coursera.org/learn/reproducible-templates-analysis\nKlavins, S. (2020). Version Control part 1. Medium. https://stevenklavins94.medium.com/version-control-part-1-c5f1b43127f6\n\n\n\nFigura 5.1: Operaciones push y pull. Imagen de Melinda Higgins.\nFigura 5.2: Operaciones de Git. Imagen de Steven Klavins.\nFigura 5.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "06-quarto.html",
    "href": "06-quarto.html",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#trabajo-previo",
    "href": "06-quarto.html#trabajo-previo",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Lecturas\nQuarto - Tutorial: Hello, Quarto. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/get-started/hello/rstudio.html",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#introducción",
    "href": "06-quarto.html#introducción",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "Introducción",
    "text": "Introducción\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Entre sus principales capacidades están:\n\nCrear contenido dinámico con los lenguajes R, Python, Julia y Observable.\nCrear documentos Markdown de texto plano o cuadernos de notas de Jupyter.\nPublicar artículos académicos, reportes, presentaciones, sitios web, blogs y libros en HTML, PDF, MS Word, ePub y otros formatos.\nCrear contenido científico, incluyendo ecuaciones, citas bibliográficas, referencias cruzadas, figuras y otros elementos.\n\nQuarto es la siguiente generación de R Markdown, un formato que permite insertar código en R, y sus salidas, en documentos escritos en Markdown. R Markdown fue introducido por Yihui Xie en 2012, junto con el paquete knitr, cuyo propósito es facilitar la investigación reproducible en R a través de la programación literaria (literate programming), un paradigma de programación propuesto por Donald Knuth en 1984.\nLos programas “literarios” (o “letrados”) están escritos como una exposición lógica en un lenguaje humano similar a la explicación de las fórmulas y ecuaciones empleadas para representar y resolver un problema en un texto de física o de matemáticas. En estos programas, se describe el análisis del problema, su solución y su implementación, intercalando código fuente entre los párrafos (y otros contenidos como imágenes, tablas, gráficos estadísticos y mapas), de forma similar a como en los textos de matemáticas se intercalan las fórmulas y las ecuaciones. La programación literaria puede mejorar enormemente un programa, ya que permite documentar ampliamente en qué consiste el problema a resolver, cómo se resuelve, cómo y por qué se adoptó cierto diseño, cómo se optimizó y cómo se implementó en un lenguaje de programación.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#anatomía-de-un-documento-quarto",
    "href": "06-quarto.html#anatomía-de-un-documento-quarto",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.1 Anatomía de un documento Quarto",
    "text": "6.1 Anatomía de un documento Quarto\nUn documento Quarto tiene tres tipos de contenido:\n\nMetadatos en YAML.\nNarrativa en Markdown.\nBloques de código fuente.\n\n\n6.1.1 Metadatos en YAML\nTodo documento Quarto inicia con un encabezado en la sintaxis YAML (YAML Ain’t Markup Language), el cual contiene metadatos del documento como el título, el autor, la fecha de creación, el formato de salida y la estructura de la tabla de contenidos, entre muchos otros.\nUn encabezado YAML comienza y termina con tres guiones (---) y contiene un conjunto de campos y valores de la forma:\n---\ncampo01: valor01\ncampo02: valor02\ncampo0n: valor0n\n---\nPor ejemplo, un encabezado YAML típico puede ser el siguiente:\n---\ntitle: Mi primer documento Quarto\nformat:\n  html:\n    toc: true\n    toc_float: true\n---\nLos campos del encabezado que dependen de otros campos se anidan con sangrías de dos espacios.\nLos elementos de metadatos que pueden especificarse en el encabezado, pueden variar de acuerdo al formato de salida, como puede verse en los siguientes enlaces:\n\nElementos de metadatos para HTML\nElementos de metadatos para PDF\nElementos metadatos para MS Word\n\nExisten elementos de metadatos para muchos otros formatos de salida (OpenOffice, ePub, presentaciones, wikis, etc.), como puede apreciarse en la Referencia de Quarto.\n\n\n6.1.2 Narrativa en Markdown\nLa narrativa proporciona estructura y contenido al documento en la forma de encabezados, párrafos, enlaces y otros elementos de la sintaxis de Markdown.\n\n\n6.1.3 Bloques de código fuente\nEn Quarto, los bloques (chunks) de código fuente se delimitan con tres backticks, tanto al inicio como al final del bloque. Los bloques de código en R se identifican con {r} y diferentes opciones identificadas con #|. Los bloques de otros lenguajes de programación se identifican con {python} y {julia}, por ejemplo.\nEl siguiente es un ejemplo de bloque de código en R y su salida:\n```{r}\n#| label: graficacion-cars\n#| include: true\n#| echo: false\n\nplot(\n  x = cars$speed,\n  y = cars$dist,\n  main = \"Velocidad vs distancia de frenado\",\n  xlab = \"Velocidad (MPH)\",\n  ylab = \"Distancia (pies)\"\n)\n```\n\n\n\n\n\n\n\n\n\nLa opción label se utiliza para etiquetar el bloque y la de include para especificar si se desea que el bloque y sus resultados se incluyan en el documento de salida.\nLa documentación de las diferentes opciones disponibles para los bloques de código que utilizan el motor (engine) Knitr (el más utilizado con R) se encuentra en Code Cells: Knitr - Quarto.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#cómo-funciona-quarto",
    "href": "06-quarto.html#cómo-funciona-quarto",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.2 ¿Cómo funciona Quarto?",
    "text": "6.2 ¿Cómo funciona Quarto?\nQuarto se apoya en knitr y en Pandoc. knitr ejecuta el código en R (u otro lenguaje) y convierte los documentos a Markdown. Por su parte, Pandoc exporta los documentos Markdown al formato de salida deseado (ej. HTML, PDF, MS Word, MS PowerPoint). Este proceso se ilustra en la Figura 6.1.\n\n\n\n\n\n\nFigura 6.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#ejercicios",
    "href": "06-quarto.html#ejercicios",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.3 Ejercicios",
    "text": "6.3 Ejercicios\nCon Quarto, cree un sitio web en GitHub Pages que muestre los gráficos que programó en la tarea 1 de este curso.\nSeguidamente, se sugiere una serie de pasos para elaborar el sitio.\n\nCree un nuevo proyecto con la opción File - New Project - New Directory - New Project de RStudio.\nEn el nuevo proyecto, cree un nuevo documento con la opción File - New File - Quarto Document de RStudio. Llene los metadatos (título, autor, etc.). Elija HTML como formato de salida.\nGuarde el documento con el nombre index.qmd (RStudio asigna la extensión automáticamente).\nAl inicio del documento, agregue narrativa en Markdown que explique el contenido, la fuente de los datos y la dirección del repositorio en GitHub con el código fuente (este repositorio se crea en un paso posterior).\nAgregue los gráficos y los comentarios de la tarea 1 mediante bloques de código en R y narrativa en Markdown. Divida el documento en secciones mediante el uso de encabezados. Se recomienda asignar una etiqueta a cada bloque de código con la opción #| label:. Considere el uso de otras etiquetas Quarto para, por ejemplo, controlar el despliegue de las salidas y del código fuente.\nPresione el botón Render de RStudio para generar el archivo index.html. Este será el arhivo que se desplegará en GitHub Pages.\nCree un repositorio vacío en su cuenta en GitHub (ej. graficos-base-r).\nSuba al nuevo repositorio los archivos index.qmd e index.html.\nGenere el sitio en GitHub Pages con la opción Settings - Pages - Branch - main - Save de GitHub.\nRepita los pasos 6, 8 y 9 para cada modificación que realice en el documento Quarto.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#recursos-de-interés",
    "href": "06-quarto.html#recursos-de-interés",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.4 Recursos de interés",
    "text": "6.4 Recursos de interés\nCode Cells: Knitr - Quarto (opciones para bloques de código). (s. f.). Recuperado el 26 de setiembre de 2024, de Code Cells: Knitr - Quarto\n\n\n\nFigura 6.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "parte-iv-graficacion-estadistica-r.html",
    "href": "parte-iv-graficacion-estadistica-r.html",
    "title": "IV - Graficación estadística en R",
    "section": "",
    "text": "7 Tidyverse - colección de paquetes para ciencia de datos\n8 dplyr - gramática para manipulación de datos\n9 ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "crumbs": [
      "IV - Graficación estadística en R"
    ]
  },
  {
    "objectID": "07-tidyverse.html",
    "href": "07-tidyverse.html",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#resumen",
    "href": "07-tidyverse.html#resumen",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "",
    "text": "Cada variable debe tener su propia columna.\nCada observación debe tener su propia fila.\nCada valor debe tener su propia celda.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#trabajo-previo",
    "href": "07-tidyverse.html#trabajo-previo",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "",
    "text": "Lecturas\nWickham, H. (2014). Tidy Data. Journal of Statistical Software, 59(1), 1-23. https://doi.org/10.18637/jss.v059.i10\nWickham, Hadley; Çetinkaya-Rundel, Mirne; & Grolemund, Garret (2023). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/ (capítulos 1 -8, 25 - 27)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#introducción",
    "href": "07-tidyverse.html#introducción",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "Introducción",
    "text": "Introducción\nTidyverse es una colección de paquetes de R enfocados en ciencia de datos, una discipina que permite convertir datos no procesados en entendimiento, comprensión y conocimiento.\nLa Figura 7.1 ilustra el modelo de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\n\nFigura 7.1: Modelo de ciencia de datos. Fuente: R for Data Science.\n\n\n\n\nImportar los datos típicamente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en un data frame.\nOrdenar u organizar (to tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable.\nTransformar los datos implica la generación de algún subconjunto de filas y columnas, la creación de nuevas variables o el cálculo de estadísticas (ej. conteos, promedios, mínimos, máximos).\nVisualizar los datos (en tablas, gráficos, mapas, etc.) permite encontrar patrones inesperados o formular nuevas preguntas.\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones.\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general.\n\nLos paquetes de Tidyverse comparten filosofía de diseño, gramática y estructuras de datos para apoyar estos procesos del modelo de ciencia de datos. El concepto de Tidyverse fue introducido por Hadley Wickham, quien también ha programado varios de sus paquetes.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#paquetes",
    "href": "07-tidyverse.html#paquetes",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.1 Paquetes",
    "text": "7.1 Paquetes\nEl núcleo de Tidyverse está compuesto por ocho paquetes base, los cuales proveen las funcionalidades utilizadas más frecuentemente en análisis de datos:\n\ndplyr: gramática que proporciona un conjunto consistente de “verbos” que resuelven los retos más comunes de transformación de datos.\nggplot2: sistema para la creación declarativa de gráficos, basado en el libro The Grammar of Graphics, de Wilkinson et al..\ntidyr: conjunto de funciones para organizar (to tidy) datos, colocando las observaciones, variables y valores en filas, columnas y celdas de estructuras rectangulares.\nreadr: conjunto de funciones para cargar datos de estructuras rectangulares (ej. archivos CSV) en memoria.\npurr: conjunto de herramientas de programación funcional para trabajar con funciones y vectores.\ntibble: un tibble es una redefinición del concepto de data frame, para hacerlos más eficientes y fáciles de usar.\nstringr: colección de funciones para facilitar el trabajo con hileras de caracteres.\nforcats: colección de funciones para facilitar el trabajo con factores.\n\nHay otros paquetes para tareas más especifícas relacionadas con importación, limpieza y modelado de datos, entre otras. Los paquetes de Tidyverse son de los más descargados, entre la totalidad de paquetes del lenguaje de programación R.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#instalación-y-carga",
    "href": "07-tidyverse.html#instalación-y-carga",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.2 Instalación y carga",
    "text": "7.2 Instalación y carga\nLos paquetes de Tidyverse pueden instalarse con la función install.packages(), ya sea de manera conjunta (todos los paquetes básicos) o individualmente:\n\n# Instalación conjunta (toma más tiempo)\ninstall.packages(\"tidyverse\")\n\n# Instalación de paquetes individuales\ninstall.packages(\"ggplot2\")\ninstall.packages(\"dplyr\")\n\nUna vez instalados, los paquetes también pueden cargarse conjunta o separadamente con la función library():\n\n# Carga conjunta\nlibrary(tidyverse)\n\n# Carga de paquetes individuales\nlibrary(ggplot2)\nlibrary(dplyr)\n\nTambién es posible utilizar la notación paquete::funcion() para llamar una función sin necesidad de cargar todo el paquete (siempre y cuando este haya sido instalado):\n\n# Llamado a la función glimpse() del paquete dplyr\ndplyr::glimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "href": "07-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.3 El conjunto de datos palmerpenguins",
    "text": "7.3 El conjunto de datos palmerpenguins\npalmerpenguins es un paquete de datos de R ampliamente utilizado para ejemplificar funciones de exploración y visualización, como las de Tidyverse. Es muy popular en ciencia de datos en general y también está disponible para otros lenguajes de programación (ej. Python, Julia). Se utiliza como una alternativa a otros conjuntos de datos usualmente usados para ejemplos como, por ejemplo, iris.\nLos datos de palmerpenguins fueron recolectados entre 2007 y 2009 por la Dr. Kristen Gorman y el Programa de Investigación Ecológica de Largo Plazo (LTER) de la Estación Palmer. Consisten de 344 observaciones de pingüinos de tres especies, las cuales habitan en tres islas del archipiélago Palmer, en la Antártida. Para cada individuo se registraron variables como especie, sexo, masa (peso), longitud de la aleta (flipper), longitud del pico (bill) y profundidad del pico, entre otras.\nEn R, el paquete puede instalarse con la función install.packages():\n\n# Instalación de palmerpenguins\ninstall.packages(\"palmerpenguins\")\n\nUna vez instalado, el paquete puede cargarse con la función library():\n\n# Carga de palmerpenguins\nlibrary(palmerpenguins)\n\nEl paquete contiene dos conjuntos de datos:\n\npenguins_raw: datos sin procesar.\npenguins: subconjunto curado de los datos sin procesar.\n\npalmerpinguins se utilizará en este capítulo, y en los siguientes, para ejemplificar varias de las funcionalidades de Tidyverse.\n\n7.3.1 Ejemplos de visualizaciones\nSeguidamente se muestran varios tipos de gráficos estadísticos generados con la función ggplot() del paquete ggplot2.\n\n7.3.1.1 Gráficos de dispersión\nEste tipo de gráficos muestra relaciones entre variables numéricas.\n\n# Gráfico de dispersión de longitud del pico vs masa (peso)\npenguins |&gt;\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  ggtitle(\"Longitud del pico vs. masa\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n\n\n\n\n# Gráfico de dispersión de longitud del pico vs masa (peso) por especie\npenguins |&gt;\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species,\n                 shape = species),\n             size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE, aes(color = species)) +\n  scale_color_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Longitud del pico vs. masa por especie\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n\n\n\n\n\n7.3.1.2 Histogramas\nEste tipo de gráficos muestra distribuciones de variables numéricas.\n\n# Distribución de la variable de masa (peso)\npenguins |&gt;\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram() +\n  ggtitle(\"Distribución de la variable masa (peso)\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\")\n\n\n\n\n\n\n\n\n\n# Distribución de la variable de masa (peso) por especie\npenguins |&gt;\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram(aes(fill = species), alpha = 0.5, position = \"identity\") +\n  scale_fill_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Distribución de la variable masa (peso) por especie\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\") +\n  labs(fill = \"Especie\")\n\n\n\n\n\n\n\n\n\n\n7.3.1.3 Diagramas de caja\nEste tipo de gráficos muestra datos a través de sus cuartiles.\n\n# Diagrama de caja de la variable masa (peso)\npenguins |&gt;\n  ggplot(aes(y = body_mass_g)) +\n  geom_boxplot() +\n  ylab(\"Masa (g)\")\n\n\n\n\n\n\n\n\n\n# Diagrama de caja de la variable masa (peso) por especie\npenguins |&gt;\n  ggplot(aes(x = species, y = body_mass_g)) +\n  geom_boxplot(aes(color = species), width = 0.3, show.legend = FALSE) +\n  scale_color_manual(values = c(\"darkorange\", \"purple\", \"cyan4\")) +\n  xlab(\"Especie\") +\n  ylab(\"Masa (g)\")",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#datos-tidy",
    "href": "07-tidyverse.html#datos-tidy",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.4 Datos tidy",
    "text": "7.4 Datos tidy\nLos paquetes de Tidyverse trabajan con datos tidy (i.e. ordenados, organizados), un concepto también introducido por Hadley Wickham y que está relacionado con la organización de los datos en estructuras rectangulares de filas y columnas, similares a las tablas o matrices.\nSegún Wickham, los datos tidy deben cumplir con tres características:\n\nCada variable debe tener su propia columna.\nCada observación debe tener su propia fila.\nCada valor debe tener su propia celda.\n\nEstas características se ilustran en la Figura 7.2.\n\n\n\n\n\n\nFigura 7.2: Datos tidy. Fuente: R for Data Science.\n\n\n\nEl empleo de este modelo de datos es común en todos los paquetes de Tidyverse, lo que posibilita aprender y usar sus funciones con mayor facilidad. Además, permite invertir menos esfuerzo en lidiar con diferentes modelos de datos y así dedicar más tiempo y esfuerzo en los problemas de análisis a resolver.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#pipes",
    "href": "07-tidyverse.html#pipes",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.5 Pipes",
    "text": "7.5 Pipes\nLas funciones de Tidyverse pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%&gt;%) o el del paquete base de R (|&gt;). Los procesos se enlazan con pipes para formar pipelines (tuberías). En este contexto, un pipeline consiste de una cadena de procesos conectados de forma tal que la salida de cada proceso de la cadena es la entrada del próximo. Esto permite la comunicación y sincronización entre los procesos y evita la anidación (nesting) de llamados a funciones.\nEl siguiente ejemplo implementa un pipeline de dos funciones de Tidyverse:\n\n# Cadena de \"pipes\" entre funciones de Tidyverse\npenguins |&gt;\n  dplyr::filter(species == \"Gentoo\") |&gt; # subconjunto de observaciones\n  select(species, bill_length_mm, flipper_length_mm) # subconjunto de columnas\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   &lt;fct&gt;            &lt;dbl&gt;             &lt;int&gt;\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# ℹ 114 more rows\n\n\nUna alternativa a los pipes es la anidación de llamados a funciones:\n\n# Llamados anidados a funciones\nselect(filter(penguins, species == \"Gentoo\"),\n       species,\n       bill_length_mm,\n       flipper_length_mm)\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   &lt;fct&gt;            &lt;dbl&gt;             &lt;int&gt;\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# ℹ 114 more rows\n\n\nEl uso de pipes permite un funcionamiento homogéneo de las funciones de Tidyverse:\n\nEl primer argumento es un data frame. Puede omitirse si la función recibe el data frame a través del operador pipe.\nLos argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).\n\nEl resultado es un nuevo data frame.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#recursos-de-interés",
    "href": "07-tidyverse.html#recursos-de-interés",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.6 Recursos de interés",
    "text": "7.6 Recursos de interés\nCanelón, S. (s.f.). Slides | Silvia Canelón—An Antarctic Tour of the Tidyverse. Recuperado 16 de octubre de 2022, de https://slides.silviacanelon.com/tour-of-the-tidyverse-v2/#/title-slide\n\n\n\nFigura 7.1: Modelo de ciencia de datos. Fuente: R for Data Science.\nFigura 7.2: Datos tidy. Fuente: R for Data Science.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html",
    "href": "08-dplyr.html",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#trabajo-previo",
    "href": "08-dplyr.html#trabajo-previo",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "",
    "text": "Lecturas\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (s. f.). R for Data Science (2nd ed.) Chapter 4 - Data transformation. Recuperado 5 de mayo de 2024, de https://r4ds.hadley.nz/data-transform.html",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#introducción",
    "href": "08-dplyr.html#introducción",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "Introducción",
    "text": "Introducción\nEl paquete dplyr de Tidyverse es descrito como una gramática para la manipulación de datos, la cual proporciona un conjunto consistente de “verbos” que ayuda a solucionar los retos de procesamiento de datos más comunes. Los principales verbos (i.e. funciones) de esta gramática son:\nselect(): selecciona columnas con base en sus nombres.\nfilter(): selecciona filas con base en sus valores.\narrange(): cambia el orden de las filas.\nmutate(): crea nuevas columnas, las cuales se expresan como funciones de columnas existentes.\nsummarize(): agrupa y resume valores.\nTodas estas operaciones pueden combinarse con la función group_by(), la cual ejecuta cualquiera de las operaciones anteriores “en grupo”. Además, dplyr proporciona funciones adicionales para tareas más específicas.\nLas funciones de dplyr pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%&gt;%) o el del paquete base de R (|&gt;). En el material de este curso, se prefiere la segunda opción. Los pipes se utilizan para comunicar procesos y así formar pipelines (tuberías).\nTodas las funciones de dplyr trabajan de manera similar:\n\nEl primer argumento siempre es un data frame. Puede omitirse si la función recibe el data frame a través del operador pipe.\nLos argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).\n\nEl resultado siempre es un nuevo data frame.\n\nYa que cada función de dplyr se especializa en una sola tarea, usualmente es necesario encadenar funciones mediante pipes para lograr un objetivo de procesamiento de datos. Por ejemplo, el siguiente bloque de código usa tres verbos, o funciones, de dplyr para obtener la masa promedio de cada especie de pingüinos que habita en la isla Biscoe.\n\n# Cálculo de la masa promedio para cada especie de pingüinos\n# que habita en la isla Biscoe\npenguins |&gt;\n  filter(island == \"Biscoe\") |&gt; \n  group_by(species) |&gt; \n  summarize(\n    body_mass_g_mean = mean(body_mass_g, na.rm = TRUE)\n  )\n\nA tibble: 2 × 2\nspecies body_mass_g_mean\n&lt;fct&gt;              &lt;dbl&gt;\nAdelie          3710.659\nGentoo          5076.016",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#instalación-y-carga",
    "href": "08-dplyr.html#instalación-y-carga",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.1 Instalación y carga",
    "text": "8.1 Instalación y carga\nEl paquete dplyr puede instalarse junto con todos los demás paquete de Tidyverse o de manera individual:\n\n# Instalación conjunta de Tidyverse\ninstall.packages(\"tidyverse\")\n\n# Instalación individual\ninstall.packages(\"dplyr\")\n\nUna vez instalado, dplyr puede cargarse con la función library():\n\n# Carga conjunta de Tidyverse\nlibrary(tidyverse)\n\n# Carga individual\nlibrary(dplyr)\n\nSeguidamente, se cargan algunos paquetes adicionales que se utilizan en este capítulo.\n\n# Carga de readr, paquete para lectura de datos\nlibrary(readr)\n\n# Carga de tidyr, paquete para creación de datos \"tidy\"\nlibrary(tidyr)\n\n# Carga de knitr, paquete para integrar salidas en R en documentos dinámicos\n# (ej. Quarto). En este capítulo se usa para generar tablas.\nlibrary(knitr)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#conjuntos-de-datos-para-ejemplos",
    "href": "08-dplyr.html#conjuntos-de-datos-para-ejemplos",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.2 Conjuntos de datos para ejemplos",
    "text": "8.2 Conjuntos de datos para ejemplos\nEn los ejemplos de este capítulo, se utilizan dos conjunto de datos:\n\nPingüinos del archipiélago Palmer, contenido en el paquete palmerpenguins.\nDelitos cometidos en Costa Rica en 2023, disponibles en el sitio Datos Abiertos del Organismo de Investigación Judicial (OIJ).\n\n\n8.2.1 Pingüinos del archipiélago Palmer\nPara cargar el conjunto de datos penguins, basta con cargar el paquete palmerpenguins.\n\n# Carga del paquete de datos palmerpenguins\nlibrary(palmerpenguins)\n\nLa función glimpse() despliega la estructura de un conjunto de datos, incluyendo los nombres de las columnas, sus tipos de datos y una muestra de estos:\n\n# Estructura del conjunto de datos penguins\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nLa función también puede llamarse mediante un pipe:\n\n# Estructura del conjunto de datos penguins\npenguins |&gt;\n  glimpse()\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nUn conjunto de datos puede visualizarse al escribir su nombre en la consola de R o en un programa:\n\n# Despliegue de los datos de penguins\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\npenguins es un tibble, un tipo especial de data frame que se utiliza en Tidyverse. La diferencia más importante entre un tibble y un data frame es la manera en la que se imprimen: los tibbles están diseñados para conjuntos de datos grandes, por lo que solo muestran los primeros registros y las columnas que caben en la pantalla. Un data frame regular muestra todas sus columnas y muchos más registros, lo que dificulta su visualización. Note la diferencia, por ejemplo, con la forma en la que se despliega el conjunto de datos iris (observe también la diferencia entre las salidas de class(iris) y class(penguins)). A pesar de estas diferencias en el despliegue, en general, un data frame regular y un tibble pueden tratarse indistintamente.\nPara generar una salida más estilizada, puede usarse la función knitr::kable(), la cual genera tablas para documentos web. En el siguiente ejemplo, se obtienen los primeros registros de penguins con la función head() y se despliegan en una tabla mediante kable().\n\n# Despliegue de los primeros registros de penguins en una tabla kable\npenguins |&gt;\n  head(n = 10) |&gt;\n  kable(format = \"html\")\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\n\n\nAdelie\nTorgersen\n38.9\n17.8\n181\n3625\nfemale\n2007\n\n\nAdelie\nTorgersen\n39.2\n19.6\n195\n4675\nmale\n2007\n\n\nAdelie\nTorgersen\n34.1\n18.1\n193\n3475\nNA\n2007\n\n\nAdelie\nTorgersen\n42.0\n20.2\n190\n4250\nNA\n2007\n\n\n\n\n\n\n\n\n\n8.2.2 Delitos cometidos en Costa Rica en 2023\nSe utiliza la función readr::read_csv() para leer un archivo CSV almacenado en el repositorio GitHub de este curso, con los datos de las estadísticas policiales proporcionados por el OIJ en formato Excel. readr::read_csv() es más eficiente que read.csv() (del paquete base de R) y tiene otras ventajas como detección automática de tipos de datos y mejor integración con otros paquetes de Tidyverse (ej. dplyr, tidyr, ggplot2).\n\n# Carga de los datos de delitos cometidos en 2023\ndelitos_2023 &lt;-\n  read_csv(\n    \"https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2024-i/main/datos/oij/estadisticas-policiales/estadisticaspoliciales2023.csv\"\n  )\n\nEstructura del conjunto de datos:\n\n# Estructura de los datos de delitos cometidos en 2023\nglimpse(delitos_2023)\n\nRows: 49,609\nColumns: 12\n$ Delito       &lt;chr&gt; \"ASALTO\", \"ASALTO\", \"HURTO\", \"ASALTO\", \"ASALTO\", \"HURTO\",…\n$ SubDelito    &lt;chr&gt; \"ARMA BLANCA\", \"ARMA BLANCA\", \"ARDID PREVIO/DISTRACCION\",…\n$ Fecha        &lt;chr&gt; \"12/31/2023\", \"12/31/2023\", \"12/31/2023\", \"12/31/2023\", \"…\n$ Hora         &lt;chr&gt; \"21:00:00 - 23:59:59\", \"21:00:00 - 23:59:59\", \"21:00:00 -…\n$ Victima      &lt;chr&gt; \"PERSONA\", \"PERSONA\", \"PERSONA\", \"PERSONA\", \"PERSONA\", \"V…\n$ SubVictima   &lt;chr&gt; \"PEATON [PERSONA]\", \"PEATON [PERSONA]\", \"TAXISTA [PERSONA…\n$ Edad         &lt;chr&gt; \"Mayor de edad\", \"Mayor de edad\", \"Mayor de edad\", \"Mayor…\n$ Genero       &lt;chr&gt; \"HOMBRE\", \"MUJER\", \"HOMBRE\", \"HOMBRE\", \"HOMBRE\", \"MUJER\",…\n$ Nacionalidad &lt;chr&gt; \"COSTA RICA\", \"COSTA RICA\", \"COSTA RICA\", \"NICARAGUA\", \"C…\n$ Provincia    &lt;chr&gt; \"SAN JOSE\", \"SAN JOSE\", \"SAN JOSE\", \"SAN JOSE\", \"SAN JOSE…\n$ Canton       &lt;chr&gt; \"SAN JOSE\", \"MORAVIA\", \"DESAMPARADOS\", \"SAN JOSE\", \"SAN J…\n$ Distrito     &lt;chr&gt; \"MERCED\", \"SAN VICENTE\", \"SAN MIGUEL\", \"HOSPITAL\", \"HOSPI…\n\n\nDespliegue de los datos (debido a que delitos_2023 es un data frame, pero no un tibble, se limitan manualmente las filas y columnas que se muestran):\n\n# Despliegue de los primeros registros de delitos en una tabla kable\ndelitos_2023 |&gt;\n  head(n = 10) |&gt;\n  kable(format = \"html\")\n\n\n\n\nDelito\nSubDelito\nFecha\nHora\nVictima\nSubVictima\nEdad\nGenero\nNacionalidad\nProvincia\nCanton\nDistrito\n\n\n\n\nASALTO\nARMA BLANCA\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nCOSTA RICA\nSAN JOSE\nSAN JOSE\nMERCED\n\n\nASALTO\nARMA BLANCA\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nMUJER\nCOSTA RICA\nSAN JOSE\nMORAVIA\nSAN VICENTE\n\n\nHURTO\nARDID PREVIO/DISTRACCION\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nTAXISTA [PERSONA]\nMayor de edad\nHOMBRE\nCOSTA RICA\nSAN JOSE\nDESAMPARADOS\nSAN MIGUEL\n\n\nASALTO\nINMOVILIZACION\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nNICARAGUA\nSAN JOSE\nSAN JOSE\nHOSPITAL\n\n\nASALTO\nARMA DE FUEGO\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nCOSTA RICA\nSAN JOSE\nSAN JOSE\nHOSPITAL\n\n\nHURTO\nPOR DESCUIDO\n12/31/2023\n21:00:00 - 23:59:59\nVIVIENDA\nNO APLICA [VIVIENDA]\nMayor de edad\nMUJER\nCOSTA RICA\nSAN JOSE\nDOTA\nJARDIN\n\n\nASALTO\nARREBATO\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPASAJERO DE TRANSPORTE PUBLICO [PERSONA]\nMayor de edad\nMUJER\nCOSTA RICA\nSAN JOSE\nSAN JOSE\nDESCONOCIDO\n\n\nASALTO\nGOLPES\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nCOSTA RICA\nPUNTARENAS\nCORREDORES\nCORREDOR\n\n\nASALTO\nINMOVILIZACION\n12/31/2023\n21:00:00 - 23:59:59\nPERSONA\nPEATON [PERSONA]\nMayor de edad\nHOMBRE\nITALIA\nSAN JOSE\nSAN JOSE\nHATILLO\n\n\nHURTO\nCON LLAVE\n12/31/2023\n21:00:00 - 23:59:59\nVIVIENDA\nNO APLICA [VIVIENDA]\nAdulto Mayor\nMUJER\nCOSTA RICA\nGUANACASTE\nNICOYA\nNICOYA",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#funciones",
    "href": "08-dplyr.html#funciones",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.3 Funciones",
    "text": "8.3 Funciones\nEn esta sección, se describen y ejemplifican las principales funciones de dplyr.\n\n8.3.1 select()\nLa función select() selecciona (y opcionalmente renombra) columnas de un data frame con base en sus nombres.\n\n# Selección de las columnas species, bill_length_mm y sex\npenguins |&gt;\n  select(species, bill_length_mm, sex)\n\n# A tibble: 344 × 3\n   species bill_length_mm sex   \n   &lt;fct&gt;            &lt;dbl&gt; &lt;fct&gt; \n 1 Adelie            39.1 male  \n 2 Adelie            39.5 female\n 3 Adelie            40.3 female\n 4 Adelie            NA   &lt;NA&gt;  \n 5 Adelie            36.7 female\n 6 Adelie            39.3 male  \n 7 Adelie            38.9 female\n 8 Adelie            39.2 male  \n 9 Adelie            34.1 &lt;NA&gt;  \n10 Adelie            42   &lt;NA&gt;  \n# ℹ 334 more rows\n\n\nCambio de nombres de columnas:\n\n# Selección y cambio de nombre de las columnas \n# species, bill_length_mm y sex\npenguins |&gt;\n  select(especie = species,\n         longitud_pico_mm = bill_length_mm,\n         sexo = sex)\n\n# A tibble: 344 × 3\n   especie longitud_pico_mm sexo  \n   &lt;fct&gt;              &lt;dbl&gt; &lt;fct&gt; \n 1 Adelie              39.1 male  \n 2 Adelie              39.5 female\n 3 Adelie              40.3 female\n 4 Adelie              NA   &lt;NA&gt;  \n 5 Adelie              36.7 female\n 6 Adelie              39.3 male  \n 7 Adelie              38.9 female\n 8 Adelie              39.2 male  \n 9 Adelie              34.1 &lt;NA&gt;  \n10 Adelie              42   &lt;NA&gt;  \n# ℹ 334 more rows\n\n\nEl operador : permite seleccionar un rango de columnas continuas:\n\n# Selección de las columnas desde species a flipper_length_mm\npenguins |&gt;\n  select(species:flipper_length_mm)\n\n# A tibble: 344 × 5\n   species island    bill_length_mm bill_depth_mm flipper_length_mm\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181\n 2 Adelie  Torgersen           39.5          17.4               186\n 3 Adelie  Torgersen           40.3          18                 195\n 4 Adelie  Torgersen           NA            NA                  NA\n 5 Adelie  Torgersen           36.7          19.3               193\n 6 Adelie  Torgersen           39.3          20.6               190\n 7 Adelie  Torgersen           38.9          17.8               181\n 8 Adelie  Torgersen           39.2          19.6               195\n 9 Adelie  Torgersen           34.1          18.1               193\n10 Adelie  Torgersen           42            20.2               190\n# ℹ 334 more rows\n\n\nSelección de todas las columnas que cumplen una condición:\n\n# Selección de las columnas numéricas\npenguins |&gt;\n  select(where(is.numeric))\n\n# A tibble: 344 × 5\n   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g  year\n            &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;int&gt;\n 1           39.1          18.7               181        3750  2007\n 2           39.5          17.4               186        3800  2007\n 3           40.3          18                 195        3250  2007\n 4           NA            NA                  NA          NA  2007\n 5           36.7          19.3               193        3450  2007\n 6           39.3          20.6               190        3650  2007\n 7           38.9          17.8               181        3625  2007\n 8           39.2          19.6               195        4675  2007\n 9           34.1          18.1               193        3475  2007\n10           42            20.2               190        4250  2007\n# ℹ 334 more rows\n\n\n\n\n8.3.2 filter()\nLa función filter() retorna un subconjunto de un data frame con todas las filas que satisfacen una condición (i.e. expresión lógica).\nPuede utilizar los operadores relacionales:\n\n== (igual que) Note la diferencia con el operador de asignación (=)\n!= (diferente de)\n&gt; (estrictamente mayor que), &gt;= (mayor o igual que)\n&lt; (estrictamente menor que), &lt;= (menor o igual que)\n\nY los operadores lógicos:\n\n& (AND o Y lógico)\n| (OR u O lógico)\n! (NOT o NO lógico)\n\nEjemplos de uso de expresiones y operadores lógicos:\n\n# Pingüinos de la especie 'Adelie' \n# con longitud del pico mayor o igual a 45 mm\npenguins |&gt;\n  filter(species == 'Adelie' & bill_length_mm &gt;= 45)\n\n# A tibble: 3 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           46            21.5               194        4200\n2 Adelie  Torgersen           45.8          18.9               197        4150\n3 Adelie  Biscoe              45.6          20.3               191        4600\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n# Pingüinos de las especies 'Adelie' o 'Gentoo'\npenguins |&gt;\n  filter(species == 'Adelie' | species == 'Gentoo')\n\n# A tibble: 276 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 266 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n# Pingüinos de especies diferentes a 'Chinstrap'\npenguins |&gt;\n  filter(!(species == 'Chinstrap'))\n\n# A tibble: 276 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 266 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n# Homicidios cometidos en el cantón de Sarapiquí\ndelitos_2023 |&gt;\n  filter(Delito == \"HOMICIDIO\" & Canton == \"SARAPIQUI\") |&gt;\n  select(Canton, SubDelito, Fecha, Edad, Nacionalidad) |&gt;\n  kable()\n\n\n\n\n\n\n\n\n\n\n\nCanton\nSubDelito\nFecha\nEdad\nNacionalidad\n\n\n\n\nSARAPIQUI\nDISCUSION/RIÑA\n12/06/2023\nDesconocido\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n10/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n10/16/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n09/30/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n09/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/07/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/05/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n06/25/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n05/31/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n05/22/2023\nDesconocido\nCOSTA RICA\n\n\nSARAPIQUI\nDISCUSION/RIÑA\n05/16/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n04/12/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nPOR LA COMISION DE OTRO DELITO\n03/18/2023\nMayor de edad\nNICARAGUA\n\n\nSARAPIQUI\nDISCUSION/RIÑA\n03/13/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n02/16/2023\nMayor de edad\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n01/31/2023\nAdulto Mayor\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n01/31/2023\nMayor de edad\nCOSTA RICA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n01/07/2023\nMayor de edad\nCOSTA RICA\n\n\n\n\n\n\n# Homicidios cometidos en el cantón de Sarapiquí \n# a personas no costarricenses\ndelitos_2023 |&gt;\n  filter(Delito == \"HOMICIDIO\" &\n           Canton == \"SARAPIQUI\" & Nacionalidad != \"COSTA RICA\") |&gt;\n  select(Canton, SubDelito, Fecha, Edad, Nacionalidad) |&gt;\n  kable()\n\n\n\n\n\n\n\n\n\n\n\nCanton\nSubDelito\nFecha\nEdad\nNacionalidad\n\n\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n10/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n09/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/28/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n07/07/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n06/25/2023\nDesconocido\nDesconocido\n\n\nSARAPIQUI\nPOR LA COMISION DE OTRO DELITO\n03/18/2023\nMayor de edad\nNICARAGUA\n\n\nSARAPIQUI\nAJUSTE DE CUENTAS/VENGANZA\n02/16/2023\nMayor de edad\nDesconocido\n\n\n\n\n\n\n# Pingüinos con longitud del pico mayor o igual al promedio\n#   El argumento lógico na.rm de mean() \n#   indica si los valores NA (\"not available\") \n#   deben ser removidos antes del cálculo\npenguins |&gt;\n  filter(bill_length_mm &gt;= mean(bill_length_mm, na.rm = TRUE))\n\n# A tibble: 175 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           46            21.5               194        4200\n 2 Adelie  Dream               44.1          19.7               196        4400\n 3 Adelie  Torgersen           45.8          18.9               197        4150\n 4 Adelie  Biscoe              45.6          20.3               191        4600\n 5 Adelie  Torgersen           44.1          18                 210        4000\n 6 Gentoo  Biscoe              46.1          13.2               211        4500\n 7 Gentoo  Biscoe              50            16.3               230        5700\n 8 Gentoo  Biscoe              48.7          14.1               210        4450\n 9 Gentoo  Biscoe              50            15.2               218        5700\n10 Gentoo  Biscoe              47.6          14.5               215        5400\n# ℹ 165 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nCondiciones relacionadas con valores NA (nulos):\n\n# Filas con valor NA en la columna sex\npenguins |&gt;\n  select(species, island, sex) |&gt;\n  filter(is.na(sex))\n\n# A tibble: 11 × 3\n   species island    sex  \n   &lt;fct&gt;   &lt;fct&gt;     &lt;fct&gt;\n 1 Adelie  Torgersen &lt;NA&gt; \n 2 Adelie  Torgersen &lt;NA&gt; \n 3 Adelie  Torgersen &lt;NA&gt; \n 4 Adelie  Torgersen &lt;NA&gt; \n 5 Adelie  Torgersen &lt;NA&gt; \n 6 Adelie  Dream     &lt;NA&gt; \n 7 Gentoo  Biscoe    &lt;NA&gt; \n 8 Gentoo  Biscoe    &lt;NA&gt; \n 9 Gentoo  Biscoe    &lt;NA&gt; \n10 Gentoo  Biscoe    &lt;NA&gt; \n11 Gentoo  Biscoe    &lt;NA&gt; \n\n\nLa función tidyr::drop_na() remueve las filas con valores NA en una o varias columnas.\n\n# Filas con valor diferente a NA en la columna sex\npenguins |&gt;\n  select(species,\n         bill_length_mm,\n         bill_depth_mm,\n         flipper_length_mm,\n         body_mass_g,\n         sex) |&gt;\n  drop_na(sex)\n\n# A tibble: 333 × 6\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt; \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            36.7          19.3               193        3450 female\n 5 Adelie            39.3          20.6               190        3650 male  \n 6 Adelie            38.9          17.8               181        3625 female\n 7 Adelie            39.2          19.6               195        4675 male  \n 8 Adelie            41.1          17.6               182        3200 female\n 9 Adelie            38.6          21.2               191        3800 male  \n10 Adelie            34.6          21.1               198        4400 male  \n# ℹ 323 more rows\n\n\n\n# Filas con valor diferente a NA en cualquier columna\npenguins |&gt;\n  select(species,\n         bill_length_mm,\n         bill_depth_mm,\n         flipper_length_mm,\n         body_mass_g,\n         sex) |&gt;\n  drop_na()\n\n# A tibble: 333 × 6\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt; \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            36.7          19.3               193        3450 female\n 5 Adelie            39.3          20.6               190        3650 male  \n 6 Adelie            38.9          17.8               181        3625 female\n 7 Adelie            39.2          19.6               195        4675 male  \n 8 Adelie            41.1          17.6               182        3200 female\n 9 Adelie            38.6          21.2               191        3800 male  \n10 Adelie            34.6          21.1               198        4400 male  \n# ℹ 323 more rows\n\n\n\n\n8.3.3 arrange()\nLa función arrange() cambia el orden de las filas de un data frame de acuerdo con los valores de las columnas seleccionadas.\n\n# Ordenamiento ascendente por las columnas \n# bill_length_mm y bill_depth_mm\npenguins |&gt;\n  arrange(bill_length_mm, bill_depth_mm)\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Dream               32.1          15.5               188        3050\n 2 Adelie  Dream               33.1          16.1               178        2900\n 3 Adelie  Torgersen           33.5          19                 190        3600\n 4 Adelie  Dream               34            17.1               185        3400\n 5 Adelie  Torgersen           34.1          18.1               193        3475\n 6 Adelie  Torgersen           34.4          18.4               184        3325\n 7 Adelie  Biscoe              34.5          18.1               187        2900\n 8 Adelie  Torgersen           34.6          17.2               189        3200\n 9 Adelie  Torgersen           34.6          21.1               198        4400\n10 Adelie  Biscoe              35            17.9               190        3450\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nPor defecto, las columnas se ordenan de manera acendente. Si se desea un orden descendente, puede utilizarse la función desc().\n\n# Ordenamiento descendente por las columnas \n# bill_length_mm y bill_depth_mm\npenguins |&gt;\n  arrange(desc(bill_length_mm), desc(bill_depth_mm))\n\n# A tibble: 344 × 8\n   species   island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo    Biscoe           59.6          17                 230        6050\n 2 Chinstrap Dream            58            17.8               181        3700\n 3 Gentoo    Biscoe           55.9          17                 228        5600\n 4 Chinstrap Dream            55.8          19.8               207        4000\n 5 Gentoo    Biscoe           55.1          16                 230        5850\n 6 Gentoo    Biscoe           54.3          15.7               231        5650\n 7 Chinstrap Dream            54.2          20.8               201        4300\n 8 Chinstrap Dream            53.5          19.9               205        4500\n 9 Gentoo    Biscoe           53.4          15.8               219        5500\n10 Chinstrap Dream            52.8          20                 205        4550\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nNótese que los valores NA se ubican al final de cualquier ordenamiento.\n\n\n8.3.4 mutate()\nLa función mutate() crea o modifica columnas en un data frame.\n\n# Creación de la columna body_mass_kg,\n# correspondiente al valor de body_mass_g, pero expresado en kg\npenguins |&gt;\n  select(species, body_mass_g) |&gt;\n  mutate(body_mass_kg = body_mass_g/1000)\n\n# A tibble: 344 × 3\n   species body_mass_g body_mass_kg\n   &lt;fct&gt;         &lt;int&gt;        &lt;dbl&gt;\n 1 Adelie         3750         3.75\n 2 Adelie         3800         3.8 \n 3 Adelie         3250         3.25\n 4 Adelie           NA        NA   \n 5 Adelie         3450         3.45\n 6 Adelie         3650         3.65\n 7 Adelie         3625         3.62\n 8 Adelie         4675         4.68\n 9 Adelie         3475         3.48\n10 Adelie         4250         4.25\n# ℹ 334 more rows\n\n\n\n# Creación de las columnas body_mass_g_mean (promedio de masa) y\n# body_mass_g_normalized (masa normalizada con respecto al promedio)\npenguins |&gt;\n  select(species, body_mass_g) |&gt;\n  mutate(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE)) |&gt;\n  mutate(body_mass_g_normalized = body_mass_g / body_mass_g_mean)\n\n# A tibble: 344 × 4\n   species body_mass_g body_mass_g_mean body_mass_g_normalized\n   &lt;fct&gt;         &lt;int&gt;            &lt;dbl&gt;                  &lt;dbl&gt;\n 1 Adelie         3750            4202.                  0.892\n 2 Adelie         3800            4202.                  0.904\n 3 Adelie         3250            4202.                  0.773\n 4 Adelie           NA            4202.                 NA    \n 5 Adelie         3450            4202.                  0.821\n 6 Adelie         3650            4202.                  0.869\n 7 Adelie         3625            4202.                  0.863\n 8 Adelie         4675            4202.                  1.11 \n 9 Adelie         3475            4202.                  0.827\n10 Adelie         4250            4202.                  1.01 \n# ℹ 334 more rows\n\n\n\n# Creación de las columnas \n# Fecha_Date (tipo Date), Anio, Mes y Dia (enteros)\ndelitos_2023 |&gt;\n  select(Fecha) |&gt;\n  mutate(Fecha_Date = as.Date(delitos_2023$Fecha, format=\"%m/%d/%Y\")) |&gt;\n  mutate(Anio = as.integer(format(as.Date(delitos_2023$Fecha, format=\"%m/%d/%Y\"), \"%Y\"))) |&gt;  \n  mutate(Dia = as.integer(format(as.Date(delitos_2023$Fecha, format=\"%m/%d/%Y\"), \"%m\"))) |&gt;\n  mutate(Mes = as.integer(format(as.Date(delitos_2023$Fecha, format=\"%m/%d/%Y\"), \"%d\"))) |&gt;\n  slice_head(n = 10)\n\n# A tibble: 10 × 5\n   Fecha      Fecha_Date  Anio   Dia   Mes\n   &lt;chr&gt;      &lt;date&gt;     &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1 12/31/2023 2023-12-31  2023    12    31\n 2 12/31/2023 2023-12-31  2023    12    31\n 3 12/31/2023 2023-12-31  2023    12    31\n 4 12/31/2023 2023-12-31  2023    12    31\n 5 12/31/2023 2023-12-31  2023    12    31\n 6 12/31/2023 2023-12-31  2023    12    31\n 7 12/31/2023 2023-12-31  2023    12    31\n 8 12/31/2023 2023-12-31  2023    12    31\n 9 12/31/2023 2023-12-31  2023    12    31\n10 12/31/2023 2023-12-31  2023    12    31\n\n\nLa función group_by() agrupa una o más columnas. Generalmente, esto se hace con el objetivo de rea\n\n# Creación de la columnas \n# body_mass_g_mean_species (promedio de masa de la especie) y\n# body_mass_g_species_normalized (masa normalizada con respecto al promedio de la especie)\npenguins |&gt;\n  select(species, body_mass_g) |&gt;\n  group_by(species) |&gt;\n  mutate(body_mass_g_mean_species = mean(body_mass_g, na.rm = TRUE)) |&gt;\n  mutate(body_mass_g_species_normalized = body_mass_g / body_mass_g_mean_species)\n\n# A tibble: 344 × 4\n# Groups:   species [3]\n   species body_mass_g body_mass_g_mean_species body_mass_g_species_normalized\n   &lt;fct&gt;         &lt;int&gt;                    &lt;dbl&gt;                          &lt;dbl&gt;\n 1 Adelie         3750                    3701.                          1.01 \n 2 Adelie         3800                    3701.                          1.03 \n 3 Adelie         3250                    3701.                          0.878\n 4 Adelie           NA                    3701.                         NA    \n 5 Adelie         3450                    3701.                          0.932\n 6 Adelie         3650                    3701.                          0.986\n 7 Adelie         3625                    3701.                          0.980\n 8 Adelie         4675                    3701.                          1.26 \n 9 Adelie         3475                    3701.                          0.939\n10 Adelie         4250                    3701.                          1.15 \n# ℹ 334 more rows\n\n\n\n\n8.3.5 summarize()\nLa función summarize() se utiliza generalmente junto con la función group_by() para realizar cálculos en grupos de filas de un data frame. group_by() agrupa las filas y summarize() realiza los cálculos (ej. sumas, promedios) en las columnas, para cada grupo. El resultado es un nuevo data frame con una fila por grupo. Si no hay agrupación, se retorna una sola fila correspondiente a los cálculos para todo el data frame.\nEjemplos de cálculos en grupos:\n\n# Mmínimo, máximo, promedio de masa y cantidad de individuos \n# para cada especie de pingüinos\npenguins |&gt;\n  group_by(species) |&gt;\n  summarize(\n    body_mass_g_min = min(body_mass_g, na.rm = TRUE),\n    body_mass_g_max = max(body_mass_g, na.rm = TRUE),\n    body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),\n    n = n()\n  )\n\n# A tibble: 3 × 5\n  species   body_mass_g_min body_mass_g_max body_mass_g_mean     n\n  &lt;fct&gt;               &lt;int&gt;           &lt;int&gt;            &lt;dbl&gt; &lt;int&gt;\n1 Adelie               2850            4775            3701.   152\n2 Chinstrap            2700            4800            3733.    68\n3 Gentoo               3950            6300            5076.   124\n\n\nLa función n() cuenta la cantidad de filas en un grupo.\n\n# Cantidad de homicidios por provincia y cantón\ndelitos_2023 |&gt;\n  filter(Delito == \"HOMICIDIO\") |&gt;\n  group_by(Provincia, Canton) |&gt;\n  summarize(\n    homicidios_2023 = n()\n  ) |&gt;\n  arrange(desc(homicidios_2023)) |&gt;\n  kable()\n\n\n\n\nProvincia\nCanton\nhomicidios_2023\n\n\n\n\nLIMON\nLIMON\n91\n\n\nSAN JOSE\nSAN JOSE\n82\n\n\nPUNTARENAS\nPUNTARENAS\n68\n\n\nLIMON\nMATINA\n50\n\n\nALAJUELA\nALAJUELA\n44\n\n\nLIMON\nPOCOCI\n31\n\n\nGUANACASTE\nNICOYA\n28\n\n\nSAN JOSE\nDESAMPARADOS\n26\n\n\nGUANACASTE\nSANTA CRUZ\n24\n\n\nSAN JOSE\nALAJUELITA\n23\n\n\nCARTAGO\nCARTAGO\n21\n\n\nLIMON\nSIQUIRRES\n21\n\n\nSAN JOSE\nGOICOECHEA\n20\n\n\nALAJUELA\nSAN CARLOS\n19\n\n\nHEREDIA\nSARAPIQUI\n19\n\n\nCARTAGO\nPARAISO\n17\n\n\nHEREDIA\nHEREDIA\n17\n\n\nPUNTARENAS\nPARRITA\n17\n\n\nGUANACASTE\nLIBERIA\n16\n\n\nPUNTARENAS\nCORREDORES\n16\n\n\nCARTAGO\nLA UNION\n15\n\n\nPUNTARENAS\nQUEPOS\n15\n\n\nALAJUELA\nSAN RAMON\n13\n\n\nPUNTARENAS\nGARABITO\n13\n\n\nSAN JOSE\nPEREZ ZELEDON\n13\n\n\nGUANACASTE\nCARRILLO\n11\n\n\nCARTAGO\nTURRIALBA\n10\n\n\nLIMON\nGUACIMO\n10\n\n\nLIMON\nTALAMANCA\n10\n\n\nSAN JOSE\nESCAZU\n8\n\n\nSAN JOSE\nASERRI\n7\n\n\nSAN JOSE\nTIBAS\n7\n\n\nSAN JOSE\nVASQUEZ DE CORONADO\n7\n\n\nALAJUELA\nLOS CHILES\n6\n\n\nGUANACASTE\nCANAS\n6\n\n\nSAN JOSE\nCURRIDABAT\n6\n\n\nSAN JOSE\nMONTES DE OCA\n6\n\n\nGUANACASTE\nABANGARES\n5\n\n\nPUNTARENAS\nESPARZA\n5\n\n\nPUNTARENAS\nGOLFITO\n5\n\n\nPUNTARENAS\nOSA\n5\n\n\nALAJUELA\nGRECIA\n4\n\n\nCARTAGO\nEL GUARCO\n4\n\n\nGUANACASTE\nLA CRUZ\n4\n\n\nHEREDIA\nSAN RAFAEL\n4\n\n\nALAJUELA\nATENAS\n3\n\n\nALAJUELA\nGUATUSO\n3\n\n\nALAJUELA\nNARANJO\n3\n\n\nALAJUELA\nOROTINA\n3\n\n\nCARTAGO\nOREAMUNO\n3\n\n\nGUANACASTE\nBAGACES\n3\n\n\nHEREDIA\nSANTO DOMINGO\n3\n\n\nPUNTARENAS\nMONTES DE ORO\n3\n\n\nSAN JOSE\nLEON CORTES\n3\n\n\nSAN JOSE\nMORAVIA\n3\n\n\nALAJUELA\nPOAS\n2\n\n\nALAJUELA\nUPALA\n2\n\n\nCARTAGO\nALVARADO\n2\n\n\nGUANACASTE\nTILARAN\n2\n\n\nHEREDIA\nSANTA BARBARA\n2\n\n\nPUNTARENAS\nCOTO BRUS\n2\n\n\nSAN JOSE\nMORA\n2\n\n\nALAJUELA\nRIO CUARTO\n1\n\n\nCARTAGO\nJIMENEZ\n1\n\n\nGUANACASTE\nNANDAYURE\n1\n\n\nHEREDIA\nBARVA\n1\n\n\nHEREDIA\nFLORES\n1\n\n\nHEREDIA\nSAN PABLO\n1\n\n\nPUNTARENAS\nBUENOS AIRES\n1\n\n\nSAN JOSE\nPURISCAL\n1\n\n\nSAN JOSE\nSANTA ANA\n1\n\n\nSAN JOSE\nTARRAZU\n1\n\n\n\n\n\n\n# Cantidad de registros por delito y subdelito\ndelitos_2023 |&gt;\n  group_by(Delito, SubDelito) |&gt;\n  summarize(\n    n = n()\n  ) |&gt;\n  arrange(desc(n)) |&gt;\n  kable()\n\n\n\n\nDelito\nSubDelito\nn\n\n\n\n\nHURTO\nPOR DESCUIDO\n8326\n\n\nROBO\nFORZADURA\n6066\n\n\nASALTO\nARMA DE FUEGO\n4915\n\n\nTACHA DE VEHICULO\nTACHA DE VEHICULO\n3863\n\n\nASALTO\nARMA BLANCA\n2925\n\n\nHURTO\nPOR CONFIANZA\n2924\n\n\nHURTO\nCARTERISTA\n2869\n\n\nROBO DE VEHICULO\nDESCUIDO\n2356\n\n\nASALTO\nARREBATO\n1915\n\n\nROBO\nBOQUETE\n1385\n\n\nROBO\nESCALAMIENTO\n1274\n\n\nASALTO\nGOLPES\n1248\n\n\nROBO DE VEHICULO\nASALTO\n1070\n\n\nROBO DE VEHICULO\nCOCHERAZO\n750\n\n\nHURTO\nARDID PREVIO/DISTRACCION\n728\n\n\nROBO\nCORTA CANDADOS\n695\n\n\nROBO\nRUPTURA VENTANA\n682\n\n\nASALTO\nINTIMIDACION VERBAL\n666\n\n\nHOMICIDIO\nAJUSTE DE CUENTAS/VENGANZA\n633\n\n\nHURTO\nOTRO O INDETERMINADO\n633\n\n\nROBO\nQUITAN CELOSIAS\n502\n\n\nHURTO\nCON LLAVE\n484\n\n\nROBO DE VEHICULO\nPOR CONFIANZA\n399\n\n\nASALTO\nCANDADO CHINO\n352\n\n\nROBO\nOTRO O INDETERMINADO\n345\n\n\nASALTO\nINMOVILIZACION\n331\n\n\nHURTO\nPROGRESIVOS\n233\n\n\nASALTO\nARMA CONTUNDENTE\n170\n\n\nASALTO\nOTRO O INDETERMINADO\n149\n\n\nROBO DE VEHICULO\nOTRO O INDETERMINADO\n133\n\n\nHOMICIDIO\nDISCUSION/RIÑA\n118\n\n\nHURTO\nRETIRO DE CAJERO AUTOMATICO\n116\n\n\nHOMICIDIO\nPOR LA COMISION DE OTRO DELITO\n83\n\n\nHURTO\nUSO DE SOMNIFERO\n74\n\n\nROBO DE VEHICULO\nARDID PREVIO\n51\n\n\nHURTO\nGANZUA/VARILLA\n47\n\n\nHOMICIDIO\nVIOLENCIA DOMESTICA\n26\n\n\nASALTO\nUSO DE GAS\n19\n\n\nHOMICIDIO\nOTRO O INDETERMINADO\n16\n\n\nHOMICIDIO\nREPELIENDO ACTIVIDAD CRIMINAL\n12\n\n\nHOMICIDIO\nPROFESIONAL\n9\n\n\nHOMICIDIO\nNO DETERMINADO\n5\n\n\nHURTO\nDESCONOCIDO\n5\n\n\nASALTO\nDESCONOCIDO\n3\n\n\nROBO\nDESCONOCIDO\n3\n\n\nHOMICIDIO\nFEMICIDIO\n1\n\n\n\n\n\nEjemplo de cálculos sin agrupamiento:\n\n# Promedio de masa y n cantidad de registros de pingüinos\npenguins |&gt;\n  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),\n            n = n())\n\n# A tibble: 1 × 2\n  body_mass_g_mean     n\n             &lt;dbl&gt; &lt;int&gt;\n1            4202.   344\n\n\n\n\n8.3.6 Otras\n\n8.3.6.1 distinct()\nLa función distinct() retorna las combinaciones únicas de filas en un data frame.\n\n# Valores distintos de la columna Victima\n\ndelitos_2023 |&gt;\n  distinct(Victima) |&gt;\n  kable()\n\n\n\n\nVictima\n\n\n\n\nPERSONA\n\n\nVIVIENDA\n\n\nVEHICULO\n\n\nEDIFICACION\n\n\nOTROS\n\n\n\n\n\n\n\n8.3.6.2 count()\nUna forma alternativa a summarize() para realizar un conteo es con la función count():\n\n# Conteo de delitos por tipo de Victima\ndelitos_2023 |&gt;\n  count(Victima)\n\n# A tibble: 5 × 2\n  Victima         n\n  &lt;chr&gt;       &lt;int&gt;\n1 EDIFICACION  6981\n2 OTROS        1946\n3 PERSONA     19448\n4 VEHICULO    11476\n5 VIVIENDA     9758\n\n# Expresión equivalente con summarize\ndelitos_2023 |&gt;\n  group_by(Victima) |&gt;\n  summarize(n = n()) |&gt;\n  kable()\n\n\n\n\nVictima\nn\n\n\n\n\nEDIFICACION\n6981\n\n\nOTROS\n1946\n\n\nPERSONA\n19448\n\n\nVEHICULO\n11476\n\n\nVIVIENDA\n9758",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#ejercicios",
    "href": "08-dplyr.html#ejercicios",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.4 Ejercicios",
    "text": "8.4 Ejercicios\nUtilice las funciones de dplyr para responder a las siguientes preguntas sobre el conjunto de datos penguins:\n\n¿Cuántos individuos de cada sexo hay en cada especie?\n¿Cuál es el mínimo, máximo y promedio de masa corporal (peso) por especie y sexo?\n¿Cuántos individuos se observaron durante cada año?\n¿Cuántos individuos de cada especie se observaron durante cada año?\n¿Cuántos individuos de cada especie y cada sexo se observaron durante cada año?\n¿Cuál es el promedio de masa corporal (peso) por año?\n¿Cuál es el promedio de masa corporal (peso) por año para cada especie?",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#recursos-de-interés",
    "href": "08-dplyr.html#recursos-de-interés",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.5 Recursos de interés",
    "text": "8.5 Recursos de interés\nRStudio. (2017). Data transformation with dplyr::Cheat Sheet. https://github.com/rstudio/cheatsheets/blob/45c1e642468695830fd8b724587ccfe8901e2185/data-transformation.pdf",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  }
]