[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PF-0953 Programación en R 2024-II",
    "section": "",
    "text": "Bienvenida\nEste es un curso introductorio a la programación de computadoras y al procesamiento de datos geoespaciales mediante el lenguaje de programación R. También se estudian herramientas para facilitar la reproducibilidad de los procedimientos y la comunicación de las soluciones a través de Internet y otros medios. Se imparte en la Maestría Académica en Gestión Integrada del Recurso Hídrico para Latinoamérica y el Caribe de la Universidad de Costa Rica.\nEl enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplican en diversos escenarios de procesamiento de datos las habilidades y conocimientos aprendidos. No se requiere de experiencia en programación de computadoras. Es recomendable contar con conocimentos básicos de datos geoespaciales y sistemas de información geográfica.\nTanto las lecciones teóricas como las prácticas se imparten de manera presencial, con apoyo de medios virtuales. Los contenidos del curso y los recursos relacionados se comparten en el sitio web https://pf0953-programacionr.github.io/2024-ii/ y en la plataforma Mediación Virtual de la Universidad de Costa Rica.\n\n\nObjetivos\nAl finalizar el curso, el estudiantado será capaz de:\n\nDesarrollar programas en el lenguaje de programación R orientados al procesamiento de datos geoespaciales.\nAplicar un enfoque de ciencia de datos en los procesos de importación, transformación, visualización, análisis y comunicación de datos.\nDesarrollar soluciones reproducibles a problemas computacionales mediante R.\nIntegrar visualizaciones tabulares, gráficas y geoespaciales de datos en documentos y aplicaciones interactivas desarrolladas en R.\n\n\n\nPrograma\nEl programa del curso está disponible en programa del curso.\n\n\nCiclos anteriores\nEste sitio web corresponde al curso impartido durante el segundo ciclo lectivo de 2024. Para consultar las versiones de otros años y ciclos lectivos, puede visitar:\n\n2022-II\n\n\n\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "programa_curso.html",
    "href": "programa_curso.html",
    "title": "Programa del curso",
    "section": "",
    "text": "Programa del curso",
    "crumbs": [
      "Programa del curso"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html",
    "href": "01-introduccion-programacion-computadoras.html",
    "title": "1  Introducción a la programación de computadoras",
    "section": "",
    "text": "Introducción\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones tales como cálculos aritméticos y operaciones lógicas, entre otras. Un conjunto de instrucciones orientado a la resolución de un problema específico mediante una computadora se denomina programa. La programabilidad de las computadoras permite que su funcionamiento pueda modificarse sin alterar sus componentes físicos, lo que las hace mucho más versátiles que otros tipos de máquinas y posibilita que ayuden a resolver una gran variedad de problemas.\nLas computadoras se programan mediante lenguajes de dos niveles: lenguajes de máquina y lenguajes de programación. En este capítulo, se describe el papel de los lenguajes de programación y el modelo Entrada - Procesamiento - Salida en el que se basa la estructura de los programas. También se detallan los componentes principales de la arquitectura de computadoras más popular en la actualidad.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#trabajo-previo",
    "href": "01-introduccion-programacion-computadoras.html#trabajo-previo",
    "title": "1  Introducción a la programación de computadoras",
    "section": "",
    "text": "Lecturas\nDowney, Allen B. (2024). Chapter 1: Programming as a way of thinking en Think Python: How to Think Like a Computer Scientist (3rd ed.). O’Reilly Media. https://allendowney.github.io/ThinkPython/chap01.html\nSeverance, D. C. R. (2016). Chapter 1: Why should you learn to write programs? en Python for Everybody: Exploring Data in Python 3 (S. Blumenberg & E. Hauser, Eds.). CreateSpace Independent Publishing Platform. https://www.py4e.com/html3/",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#introducción",
    "href": "01-introduccion-programacion-computadoras.html#introducción",
    "title": "1  Introducción a la programación de computadoras",
    "section": "Introducción",
    "text": "Introducción\nUna computadora es una máquina que ejecuta automáticamente secuencias de instrucciones tales como cálculos aritméticos y operaciones lógicas, entre otras. Un conjunto de instrucciones orientado a la resolución de un problema específico mediante una computadora se denomina programa. La programabilidad de las computadoras permite que su funcionamiento pueda modificarse sin alterar sus componentes físicos, lo que las hace mucho más versátiles que otros tipos de máquinas y posibilita que ayuden a resolver una gran variedad de problemas.\nLas computadoras se programan mediante lenguajes de dos niveles: lenguajes de máquina y lenguajes de programación. En este capítulo, se describe el papel de los lenguajes de programación y el modelo Entrada - Procesamiento - Salida en el que se basa la estructura de los programas. También se detallan los componentes principales de la arquitectura de computadoras más popular en la actualidad.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "parte-i-introduccion-programacion-computadoras-ciencia-datos.html",
    "href": "parte-i-introduccion-programacion-computadoras-ciencia-datos.html",
    "title": "I - Introducción a la programación de computadoras y a la ciencia de datos",
    "section": "",
    "text": "1 Introducción a la programación de computadoras\n2 Introducción a la ciencia de datos",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#lenguajes-para-programar-computadoras",
    "href": "01-introduccion-programacion-computadoras.html#lenguajes-para-programar-computadoras",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.1 Lenguajes para programar computadoras",
    "text": "1.1 Lenguajes para programar computadoras\nLas computadoras pueden programarse mediante lenguajes de varios niveles. En esta sección, se describen el lenguaje de máquina, el más cercano al hardware de la computadora, y los lenguajes de programación, los cuales abstraen detalles técnicos y de hardware para lograr que la programación sea más intuitiva, más rápida y menos propensa a errores.\n\n1.1.1 Lenguajes de máquina\nLas computadoras modernas son electrónicas y utilizan circuitos integrados para procesar y almacenar información en forma de señales eléctricas. Esta representación de la información se basa en un sistema binario (de dos estados): 0 (voltaje bajo) y 1 (voltaje alto).\nEn el nivel más básico, las computadoras pueden programarse introduciendo directamente combinaciones de unos y ceros, conocidas como lenguaje de máquina en la Unidad Central de Procesamiento (CPU), el componente de hardware encargado de ejecutar las instrucciones.\nPor ejemplo, la Figura 1.1 muestra el programa Hola mundo (Hello World) en lenguaje de máquina. Este programa simplemente imprime la hilera de texto “Hola mundo” en la pantalla. Suele ser usado como introducción al estudio de la programación de computadoras.\n\n\n\n\n\n\nFigura 1.1: Lenguaje de máquina correspondiente a la implementación del programa “Hola mundo” en el lenguaje C (mostrado abajo). Imagen de Tanveer Salim.\n\n\n\n/* PROGRAMA \"Hola mundo\" EN LENGUAJE C */\n\nint main void()\n{\n  printf(\"hello, world\\n\");\n  return 0;\n}\nInternamente, el lenguaje de máquina ejecuta un conjunto de instrucciones muy básicas como, por ejemplo:\n\nSumar dos números.\nComprobar si un número es igual a cero.\nCopiar datos de una sección a otra de la memoria de la computadora.\n\nLos lenguajes de máquina son específicos para cada tipo de CPU. Así, por ejemplo, el lenguaje de máquina de un procesador Intel, uno de los más usados en computadoras personales, es diferente al lenguaje de máquina de un procesador PowerPC, utilizado tanto en computadoras personales (como antiguas Macintosh), como en consolas de videojuegos y sistemas incrustados (ej. en dispositivos electrónicos).\n\n\n1.1.2 Lenguajes de programación\nDebido a que el lenguaje de máquina es poco amigable para las personas, actualmente es más común utilizar lenguajes de programación para resolver problemas mediante computadoras. Los lenguajes de programación consisten de instrucciones compuestas por palabras y expresiones similares a las de los lenguajes humanos como, por lo general, el idioma inglés. Existe una gran variedad de lenguajes de programación, debido a los diferentes fines para los que fueron creados y a su evolución histórica, entre otras razones.\nLas instrucciones de los lenguajes de programación deben ser traducidas al lenguaje de máquina para que puedan ser ejecutados por la computadora. Esta traducción se realiza mediante programas llamados compiladores (para lenguajes compilados como C y C++) o interpretadores (para lenguajes interpretados como Python y R). Mientras que los lenguajes de máquina son específicos para cada CPU, algunos lenguajes de programación pueden ser ejecutados en diferentes plataformas, con el compilador o interpretador adecuado.\nComo ejemplo, considere problema del cálculo del índice de masa corporal (IMC). El IMC indica si una persona tiene una masa (peso) saludable en relación con su estatura. Se obtiene mediante la fórmula:\n\\[\nimc = \\frac{masa}{estatura^2}\n\\]\nEl resultado se interpreta de la siguiente manera:\n\nIMC menor que 18.5: Peso bajo.\nIMC mayor o igual que 18.5 y menor que 25: Peso normal.\nIMC mayor o igual que 25: Sobrepeso.\n\nEl siguiente programa en el lenguaje Python calcula e interpreta el IMC de una persona.\n# CÁLCULO E INTERPRETACIÓN DEL IMC DE UNA PERSONA\n\n\n# ENTRADA\n\n# Datos de masa (kg) y estatura (m) de una persona\nmasa = 65\nestatura = 1.7\n\n\n# PROCESAMIENTO\n\n# Cálculo del IMC\nimc = masa / estatura**2\n\n# Interpretación del IMC\nif (imc &lt; 18.5):\n  interpretacion_imc = \"Peso bajo\"\nelif (imc &lt; 25):\n  interpretacion_imc = \"Peso normal\"\nelse:\n  interpretacion_imc = \"Sobrepeso\"\n\n\n# SALIDA\n\n# Impresión de los resultados\nprint(\"El valor del IMC es:\", imc)\nprint(\"Corresponde a:\", interpretacion_imc)\nA manera de ejercicio, puede escribir y ejecutar el programa anterior en una consola de Python. Modifique los datos de entrada de masa y estatura y observe los cambios en los resultados.\nEn el ejemplo anterior puede observarse como el programa sigue un modelo conocido como “Entrada - Procesamiento - Salida”, el cual se describe en detalle en la sección siguiente.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#modelo-entrada---procesamiento---salida",
    "href": "01-introduccion-programacion-computadoras.html#modelo-entrada---procesamiento---salida",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.2 Modelo Entrada - Procesamiento - Salida",
    "text": "1.2 Modelo Entrada - Procesamiento - Salida\nLas computadoras trabajan con un modelo de “Entrada - Procesamiento - Salida”: reciben datos de entrada (ej. números), los procesan (ej. realizan cálculos aritméticos) y generan salidas (ej. resultados de los cálculos).\nEl modelo “Entrada - Procesamiento - Salida” es un concepto fundamental en análisis de sistemas de información y desarrollo de programas. Su esquema se presenta en la Figura 1.2.\n\n\n\n\n\n\nFigura 1.2: Modelo “Entrada - Procesamiento - Salida”\n\n\n\n\nLa Entrada se refiere a los datos que se introducen en un sistema o programa para ser procesados. Pueden ingresarse a través de diferentes medios como teclados, ratones, cámaras, sensores, archivos y servicios web, entre otros.\nEl Procesamiento es el conjunto de instrucciones que generan salidas a partir de las entradas. Estas intrucciones pueden incluir cálculos matemáticos, operaciones lógicas y operaciones de control, entre muchas posibilidades.\nPor último, la Salida es el resultado del procesamiento como, por ejemplo, resultado de cálculos aritméticos.\n\nEl modelo “Entrada - Procesamiento - Salida” se implementa en los componentes físicos mediante la arquitectura de computadoras, como se explica a continuación.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#arquitectura-de-computadoras",
    "href": "01-introduccion-programacion-computadoras.html#arquitectura-de-computadoras",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.3 Arquitectura de computadoras",
    "text": "1.3 Arquitectura de computadoras\nLa arquitectura de computadoras es un área de estudio enfocada en el diseño de los componentes principales de un sistema informático.\n\n1.3.1 Evolución histórica\nLa arquitectura de las computadoras modernas es el resultado de un proceso que ha tomado varios siglos, incluyendo la fabricación de calculadoras mecánicas en el siglo XVII, con capacidades para realizar operaciones aritméticas básicas, y el diseño en el siglo XIX de la máquina analítica de Charles Babbage, una computadora mecánica que incorporaba algunas características de las computadoras modernas.\nEn 1936, el matemático inglés Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas y que funcionó como un modelo teórico de gran importancia para desarrollos posteriores, como los dispositivos eletromecánicos Bombe y Colossus en el Reino Unido, de uso específico para criptografía durante la II Guerra Mundial. Algunos años después, en 1946, el ejército de los Estados Unidos desarrolló ENIAC (Electronic Numerical Integrator And Computer), considerada por algunos como la primera computadora de uso general y que fue inicialmente diseñada para calcular tablas de tiro de artillería.\n\n\n1.3.2 Arquitectura de von Neumann\nEn 1945, el matemático húngaro-estadounidense John von Neumann (1903-1957) propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada de los componentes físicos que ejecutan las instrucciones. Este modelo permite que las computadoras sean más fáciles de programase y reprogramarse y es conocido actualmente como arquitectura de von Neumann. La arquitectura de von Neumann se ilustra en la Figura 1.3.\n\n\n\n\n\n\nFigura 1.3: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\n\n\n\n\n1.3.2.1 Componentes de la arquitectura de von Neumann\n\n1.3.2.1.1 Memoria principal\nAlmacena las instrucciones de los programas y los datos que utilizan estos programas. Es común denominarla como RAM (Random Access Memory, Memoria de Acceso Aleatorio), lo que significa que toma el mismo tiempo acceder a cualquier posición de la memoria. Cada posición de memoria tiene una dirección a la que se hace referencia cuando se desea leer o escribir.\n\n\n1.3.2.1.2 Unidad Central de Procesamiento\nTambién se le conoce como CPU (Central Processing Unit, Unidad Central de Procesamiento). Ejecuta las instrucciones de los programas en lenguaje de máquina. Está compuesta por dos partes:\n\nUnidad de Control: determina cuál es la siguiente instrucción a ejecutar. Contiene memorias temporales de alta velocidad y poca capacidad llamadas registros, para almacenar los operandos y el resultado de las instrucciones.\nUnidad de Aritmética y Lógica o ALU (Arithmetic and Logic Unit): ejecuta las operaciones aritméticas y lógicas.\n\n\n\n1.3.2.1.3 Sistemas de entrada y salida\nPermiten que la computadora interactúe con el usuario y, en general, con el mundo exterior. Algunos ejemplos son el teclado y el ratón, como sistemas de entrada, y la pantalla y la impresora, como sistemas de salida.\n\n\n\nFigura 1.1: Lenguaje de máquina correspondiente a la implementación del programa “Hola mundo” en el lenguaje C (mostrado abajo). Imagen de Tanveer Salim.\nFigura 1.2: Modelo “Entrada - Procesamiento - Salida”\nFigura 1.3: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html",
    "href": "02-introduccion-ciencia-datos.html",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "href": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "Lecturas\nÇetinkaya-Rundel, Mine, & Hardin, Johanna (2021). Chapter 1: Hello data en Introduction to Modern Statistics (1st ed.). OpenIntro, Inc. https://openintro-ims.netlify.app/data-hello\nSingleton, Alex David; Spielman, Seth; & Brunsdon, Chris (2016). Establishing a framework for Open Geographic Information science. International Journal of Geographical Information Science, 30(8), 1507-1521. https://doi.org/10.1080/13658816.2015.1137579\nWickham, Hadley; Çetinkaya-Rundel, Mirne; & Grolemund, Garret (2023). Introduction en R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/intro",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#introducción",
    "href": "02-introduccion-ciencia-datos.html#introducción",
    "title": "2  Introducción a la ciencia de datos",
    "section": "Introducción",
    "text": "Introducción\nUna investigación estadística se basa en datos. Los datos acostumbran representarse en tablas, en las cuales cada fila es una observación y cada columna es una variable. Una observación corresponde a un elemento de datos que ha sido estudiado y cada variable a una característica de ese elemento. Las variables pueden ser numéricas o categóricas. Las numéricas se subdividen en discretas y continuas y las categóricas en nominales y ordinales.\nLa ciencia de datos es una disciplina que permite convertir datos sin procesar en comprensión y conocimiento. El ciclo de vida de un proyecto de ciencia de datos incluye los procesos importar, ordenar, transformar, visualizar, modelar y comunicar. La programación de computadoras puede emplearse en cualquier etapa del ciclo de vida de un proyecto para automatizar tareas y a resolver nuevos problemas con mayor facilidad.\nEl surgimiento de la ciencia de datos está motivado por un incremento acelerado de la cantidad de datos existentes, así como de la disponibilidad de herramientas computacionales y de infraestructura informática para procesarlos y analizarlos. Estos cambios tecnológicos han sido apoyados por un cambio cultural propiciado por movimientos como el de ciencia abierta (open science), el cual promueve el acceso libre a la investigación científica, incluidas las publicaciones, los datos, las metodologías y el código fuente.\nUn aspecto crucial de la ciencia abierta es la reproducibilidad, que garantiza que los resultados de una investigación puedan ser verificados y validados por otros investigadores. Hay varias herramientas que pueden facilitar la reproducibilidad en ciencia de datos, incluyendo lenguajes de programación, lenguajes de marcado y sistemas de control de versiones.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#datos",
    "href": "02-introduccion-ciencia-datos.html#datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.1 Datos",
    "text": "2.1 Datos\nLos científicos tratan de responder preguntas mediante métodos rigurosos y observaciones cuidadosas. Estas observaciones, recopiladas de notas de campo, encuestas y experimentos, entre otras fuentes, forman la columna vertebral de una investigación estadística y se denominan datos. La presentación y descripción efectivas de los datos constituyen el primer paso en un análisis Çetinkaya-Rundel & Hardin (2021). Esta sección introduce una estructura para organizar los datos, así como alguna terminología que se utilizará a lo largo de este curso.\n\n2.1.1 Observaciones y variables\nLa tabla 1 contiene 10 filas de un conjunto de datos. Cada fila representa una persona. En términos estadísticos, cada fila corresponde a una observación. Las columnas representan características de las personas. Cada columna corresponde a una variable.\n\n\n\nTabla 1. Datos de personas.\n\n\n\n\ncedula\n\n\nprovincia\n\n\nequipo\n\n\npeso\n\n\nestatura\n\n\nsexo\n\n\ncantidad_hermanos\n\n\nnivel_guitarra\n\n\n\n\n\n\n709880238\n\n\nLimón\n\n\nSaprissa\n\n\n51.0\n\n\n1.51\n\n\ndesconocido\n\n\n0\n\n\nnulo\n\n\n\n\n400680168\n\n\nHeredia\n\n\nHerediano\n\n\n98.5\n\n\n1.87\n\n\nhombre\n\n\n1\n\n\nalto\n\n\n\n\n509210285\n\n\nGuanacaste\n\n\nLiberia\n\n\n91.6\n\n\n1.65\n\n\nmujer\n\n\n4\n\n\nbajo\n\n\n\n\n701950272\n\n\nLimón\n\n\nLiberia\n\n\n60.6\n\n\n1.68\n\n\nmujer\n\n\n1\n\n\nalto\n\n\n\n\n309880238\n\n\nCartago\n\n\nCartaginés\n\n\n59.1\n\n\n1.73\n\n\nmujer\n\n\n3\n\n\nbajo\n\n\n\n\n908280708\n\n\nDesconocida\n\n\nSan Carlos\n\n\n59.2\n\n\n1.89\n\n\nhombre\n\n\n3\n\n\nbajo\n\n\n\n\n505580938\n\n\nGuanacaste\n\n\nCartaginés\n\n\n65.2\n\n\n1.70\n\n\nmujer\n\n\n3\n\n\nalto\n\n\n\n\n504080488\n\n\nGuanacaste\n\n\nSporting\n\n\n76.2\n\n\n1.76\n\n\nhombre\n\n\n3\n\n\nexperto\n\n\n\n\n709950244\n\n\nLimón\n\n\nAlajuelense\n\n\n71.6\n\n\n1.80\n\n\nhombre\n\n\n4\n\n\nbajo\n\n\n\n\n206080825\n\n\nAlajuela\n\n\nAlajuelense\n\n\n64.6\n\n\n1.52\n\n\nhombre\n\n\n2\n\n\nbajo\n\n\n\n\n\n\n2.1.2 Tipos de variables\nLas variables de los datos de la tabla 1 son de varios tipos, cuya jerarquía se muestra en la Figura 2.1.\n\n\n\n\n\n\nFigura 2.1: Tipos de variables estadísticas. Imagen de Çetinkaya-Rundel & Hardin (2021)\n\n\n\nSeguidamente, se describen estos tipos de datos de las variables.\n\n2.1.2.1 Numéricas\nCorresponden a números a los cuales se les pueden aplicar operaciones como suma, resta, multiplicación, división y otras similares. Las variables numéricas puden ser discretas o continuas.\n\n2.1.2.1.1 Discretas\nToman valores específicos que se pueden contar. La variable cantidad_hermanos es discreta. Existe una separación clara entre sus posibles valores. Por ejemplo, es posible tener 1, 2 o 3 hermanos, pero no 2.5.\n\n\n2.1.2.1.2 Continuas\nPueden tomar cualquier valor dentro de un intervalo o rango continuo. Estas variables se caracterizan por su capacidad para representar medidas precisas y pueden asumir un número infinito de valores, incluso dentro de un rango limitado (ej. entre 0 y 1). Las variables peso y estatura son continuas.\n\n\n\n2.1.2.2 Categóricas\nLas variables categóricas (también llamadas cualitativas), son aquellas que describen una característica o cualidad de una observación y pueden utilizarse para clasificar las observaciones en grupos o categorías. A diferencia de las variables numéricas, que expresan cantidades, las variables categóricas expresan atributos no numéricos. Las variables categóricas pueden ser nominales u ordinales.\n\n2.1.2.2.1 Nominales\nNo existe un orden inherente o jerarquía entre las categorías. Las variables provincia, equipo y sexo son nominales.\n\n\n2.1.2.2.2 Ordinales\nHay un orden o jerarquía clara entre las categorías. La variable nivel_guitarra, con sus valores nulo, bajo, alto y experto, es ordinal.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#referencias-bibliográficas",
    "href": "02-introduccion-ciencia-datos.html#referencias-bibliográficas",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.5 Referencias bibliográficas",
    "text": "2.5 Referencias bibliográficas\n\n\nÇetinkaya-Rundel, M., & Hardin, J. (2021). Introduction to\nModern Statistics (1st ed.). OpenIntro,\nInc. Retrieved from https://openintro-ims.netlify.app/\n\n\nGandrud, C. (2020). Reproducible research with R and\nRStudio (Third edition). Boca Raton, FL: CRC Press.\n\n\nHarrison, D., & Rubinfeld, D. L. (1978). Hedonic housing prices and\nthe demand for clean air. Journal of Environmental Economics and\nManagement, 5(1), 81–102. https://doi.org/10.1016/0095-0696(78)90006-2\n\n\nKrugman, P. (2013). Opinion  The\nExcel Depression. The New York Times.\nRetrieved from https://www.nytimes.com/2013/04/19/opinion/krugman-the-excel-depression.html\n\n\nPeng, R. D. (2011). Reproducible Research in\nComputational Science. Science,\n334(6060), 1226–1227. https://doi.org/10.1126/science.1213847\n\n\nPrince, S. J. D. (2023). Understanding deep learning. The MIT\nPress. Retrieved from http://udlbook.com\n\n\nSingleton, A. D., Spielman, S., & Brunsdon, C. (2016). Establishing\na framework for Open Geographic\nInformation science. International Journal of\nGeographical Information Science, 30(8), 1507–1521. https://doi.org/10.1080/13658816.2015.1137579\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\nData Science: Import,\nTidy, Transform, Visualize, and\nModel Data (2nd ed.). O’Reilly Media.\nRetrieved from https://r4ds.hadley.nz/\n\n\n\n\n\nFigura 2.1: Tipos de variables estadísticas. Imagen de Çetinkaya-Rundel & Hardin (2021)\nFigura 2.2: Ciclo de vida de un proyecto de ciencia de datos. Imagen de Wickham et al. (2023)\nFigura 2.3: Problemas de regresión y clasificación. Imagen de Prince (2023)\nFigura 2.4: Modelo de aprendizaje automático. Imagen de Prince (2023).\nFigura 2.5: Espectro de reproducibilidad. Imagen de Anita Graser basada en Peng (2011).",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#ciclo-de-vida-de-un-proyecto-de-ciencia-de-datos",
    "href": "02-introduccion-ciencia-datos.html#ciclo-de-vida-de-un-proyecto-de-ciencia-de-datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.2 Ciclo de vida de un proyecto de ciencia de datos",
    "text": "2.2 Ciclo de vida de un proyecto de ciencia de datos\nLa ciencia de datos es una disciplina que permite convertir datos “crudos” (sin procesar) en comprensión y conocimiento Wickham, Çetinkaya-Rundel, & Grolemund (2023). Se basa en la estadística y en las ciencias de la computación, entre otras disciplinas.\n\n2.2.1 Procesos\nLa Figura 2.2 ilustra el ciclo de vida de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\n\nFigura 2.2: Ciclo de vida de un proyecto de ciencia de datos. Imagen de Wickham et al. (2023)\n\n\n\n\n2.2.1.1 Importar\nImportar los datos generalmente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en estructuras apropiadas para este propósito en un lenguaje de programación.\n\n\n2.2.1.2 Ordenar\nOrdenar o estructurar (to tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable. En algunos casos, pueden requerirse estructuras de otros tipos.\n\n\n2.2.1.3 Transformar\nTransformar los datos incluye, entre otras operaciones, la generación de algún subconjunto de observaciones o variables del conjunto original, la creación de nuevas variables a partir de las ya existentes o el cálculo de estadísticas como conteos y promedios.\nUna vez que los datos están bien estructurados y con las variables que se requieren para el análisis, se puede proceder a la generación de conocimiento mediante dos mecanismos: la visualización y la modelización. Ambos tienen fortalezas y debilidades y es común iterar varias veces entre uno y otro.\n\n\n2.2.1.4 Visualizar\nVisualizar los datos en tablas, gráficos, mapas u otros formatos permite encontrar patrones inesperados o formular nuevas preguntas. Una buena visualización también puede indicar si se están formulando preguntas equivocadas o utilizando datos que no son apropiados para el problema que se desea resolver. Es importante tener en cuenta que las visualizaciones deben ser interpretadas por seres humanos. Por este motivo, visualizaciones como gráficos estadísticos y mapas deben ser seleccionadas con cuidado y elaborarse detalladamente.\n\n\n2.2.1.5 Modelar\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones. Al ser herramientas matemáticas o computacionales, los modelos muchas veces pueden mejorarse mediante el empleo de mayores capacidades de cómputo, lo que los hace menos dependientes de la intervención humana, como en el caso de las visualizaciones.\n\n\n2.2.1.6 Comunicar\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general. No importa lo bien que los modelos y visualizaciones ayuden a entender los datos si los resultados no pueden ser comunicados a otras personas.\n\n\n2.2.1.7 Programar\nLa programación de computadoras se utiliza de manera transversal en los procesos recién descritos. Puede emplearse en cualquier etapa del ciclo de vida de un proyecto de ciencia de datos. Es útil para automatizar tareas y a resolver nuevos problemas con mayor facilidad.\n\n\n\n2.2.2 Ejemplos\nLas etapas iniciales de un proyecto de ciencia de datos incluyen técnicas estadísticas convencionales como el análisis exploratorio de datos (EDA), mientras que las más avanzadas pueden involucrar técnicas de inteligencia artificial como aprendizaje automático (machine learning) y aprendizaje profundo (deep learning).\nLa Figura 2.3 ilustra varios problemas resueltos mediante regresión y clasificación, dos técnicas que se utilizan en deep learning. En cada caso, hay una entrada que puede tener diversos formatos como un conjunto de números, una hilera de texto, un archivo de sonido o una imagen. Esta entrada se transforma y se codifica como un vector de números. Este vector constituye la entrada del modelo de regresión o clasificación. El modelo convierte la entrada en un vector de salida que se “traduce” de nuevo a un formato adecuado.\n\n\n\n\n\n\nFigura 2.3: Problemas de regresión y clasificación. Imagen de Prince (2023)\n\n\n\nEl modelo de a) predice el precio de una vivienda en función de características de entrada como el área en pies cuadrados y el número de dormitorios 1. Se trata de un problema de regresión, ya el modelo retorna un número real (no asigna una categoría). El modelo de la figura b) recibe la estructura química de una molécula como entrada y predice su punto de congelación y su punto de ebullición. Este es un problema de regresión multivariada, ya que la salida incluye más de un número.\nEl modelo en c) recibe como entrada una hilera de texto que contiene las calificaciones de varios aspectos a evaluar sobre una comida en un restaurante (plato principal, ensalada, sopa, postre, etc.) y predice si el resultado general es positivo o negativo. Es un problema de clasificación binaria porque el modelo asigna como salida una de dos categorías. El vector de salida contiene las probabilidades de posible valor. Los modelos en d) y e) corresponden a problemas de clasificación multiclase. Aquí, el modelo asigna el valor de salida a una de n &gt; 2 categorías. En el primer caso, la entrada es un archivo de audio y el modelo predice el género musical al que pertenece. En el segundo caso, la entrada es una imagen y el modelo predice qué objeto contiene. En cada caso, el modelo devuelve un vector de tamaño n que contiene las probabilidades de las n categorías.\nEn la Figura 2.3, los modelos de deep learning se muestran como “cajas negras” que reciben una entrada y retornan una salida, sin entrar en detalles de como se procesa la entrada. Hay muchas posibilidades para implementar estas “cajas negras”. Considere un modelo para predecir la estatura de un niño a partir de su edad, como el de la Figura 2.4. En este caso, el modelo es una ecuación que describe como la estatura promedio varía en función de la edad. Al ingresar la edad a la ecuación, retorna la estatura.\n\n\n\n\n\n\nFigura 2.4: Modelo de aprendizaje automático. Imagen de Prince (2023).\n\n\n\nEl surgimiento de la ciencia de datos está motivado por un incremento acelerado de la cantidad de datos existentes, así como de la disponibilidad de herramientas computacionales (lenguajes de programación, motores de bases de datos) y de infraestructura informática (hospedaje de datos, hospedaje de aplicaciones) para procesarlos y analizarlos. Los cambios tecnológicos han sido apoyados por un cambio cultural propiciado por movimientos como los de código abierto (open source), datos abiertos (open data), acceso abierto (open access) y ciencia abierta (open science). La ciencia abierta, que de alguna manera engloba a los otros movimientos abiertos, promueve el acceso libre a la investigación científica, incluidas las publicaciones, los datos, las metodologías y el código fuente, de manera que sean accesibles a todos los niveles de la sociedad. Un aspecto crucial de la ciencia abierta es la reproducibilidad, que garantiza que los resultados de una investigación puedan ser verificados y validados por otros investigadores.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#footnotes",
    "href": "02-introduccion-ciencia-datos.html#footnotes",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "Como ejemplo, puede revisar el problema de la estimación de precios de viviendas en Boston en Harrison & Rubinfeld (1978) (el texto completo está en https://deepblue.lib.umich.edu/bitstream/handle/2027.42/22636/0000186.pdf) y acceder a los datos correspondientes en Kaggle.↩︎",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#reproducibilidad",
    "href": "02-introduccion-ciencia-datos.html#reproducibilidad",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.3 Reproducibilidad",
    "text": "2.3 Reproducibilidad\nLa reproducibilidad es la capacidad de un ensayo o experimento de ser reproducido por otros. Más formalmente, en investigación cuantitativa, un análisis se considera reproducible si “el código fuente y los datos utilizados por un investigador para llegar a un resultado están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado” Gandrud (2020).\nLa reproducibilidad, junto con la falsabilidad, es uno de los pilares del método científico. Sin embargo, en años recientes, se ha generado una creciente preocupación debido a que muchos estudios científicos publicados fallan las pruebas de reproducibilidad, dando lugar a una crisis de reproducibilidad o replicabilidad en varias ciencias Krugman (2013).\nEl concepto de reproducibilidad es cada vez más importante debido, entre otras razones, al aumento exponencial de datos disponibles y a la aplicación de la programación de computadoras, para procesar estos datos, por parte de especialistas de muchas disciplinas.\nAlex Singleton y otros autores han identificado los siguientes retos para la reproducibilidad en ciencia de datos geoespaciales Singleton, Spielman, & Brunsdon (2016):\n\nLos datos deben ser de dominio público y estar disponibles para los investigadores.\nEl software utilizado debe ser de código abierto (open source) y estar disponible para ser revisado.\nSiempre que sea posible, los flujos de trabajo deben ser públicos y con enlaces a los datos, software y métodos de análisis, junto con la documentación necesaria.\nEl proceso de revisión por pares (peer review process) y la publicación académica deben requerir la presentación de un modelo de flujo de trabajo e idealmente la disponibilidad de los materiales necesarios para la replicación.\nEn los casos en los que la reproducibilidad total no sea posible (ej. datos sensibles), los investigadores deben esforzarse por incluir todos los aspectos que puedan de un marco de trabajo abierto.\n\nEn general, el estándar mínimo de reproducibilidad requiere que los datos y el código fuente estén disponibles para otros investigadores Peng (2011). Sin embargo, dependiendo de las circunstancias y recursos disponibles, existe todo un espectro de posibilidades, que se ilustra en la Figura 2.5.\n\n\n\n\n\n\nFigura 2.5: Espectro de reproducibilidad. Imagen de Anita Graser basada en Peng (2011).",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#herramientas-para-ciencia-de-datos",
    "href": "02-introduccion-ciencia-datos.html#herramientas-para-ciencia-de-datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.4 Herramientas para ciencia de datos",
    "text": "2.4 Herramientas para ciencia de datos\nComo se ha mencionado, la programación de computadoras es una actividad presente durante todos los procesos de ciencia de datos. Hay muchos lenguajes que pueden utilizarse en este campo. Entre los más populares, pueden mencionarse Python, R, SQL y JavaScript.\nPor otra parte, la documentación es vital durante todo el ciclo de vida de una investigación reproducible. Se recomienda utilizar mecanismos estandarizados y abiertos como el lenguaje de marcado de hipertexto (HTML, en inglés, HyperText Markup Language) o Markdown, con los cuales pueden crearse documentos mediante editores de texto simples (i.e. no se requiere de software propietario), y exportables a varios formatos (ej. LaTeX, PDF).\nPara dar mantenimiento, tanto al código fuente como a la documentación, es necesario un sistema de control de versiones como Git, el cual permite llevar el registro de los cambios en archivos y también facilita el trabajo colaborativo al reunir las modificaciones hechas por varias personas. Git es usado en varias plataformas que comparten código fuente (ej. GitHub, GitLab) y que ofrecen servicios relacionados, como hospedaje de sitios web.",
    "crumbs": [
      "I - Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "parte-ii-lenguaje-programacion-r.html",
    "href": "parte-ii-lenguaje-programacion-r.html",
    "title": "II - El lenguaje de programación R",
    "section": "",
    "text": "3 R - lenguaje de programación para análisis estadístico",
    "crumbs": [
      "II - El lenguaje de programación R"
    ]
  },
  {
    "objectID": "03-r.html",
    "href": "03-r.html",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#trabajo-previo",
    "href": "03-r.html#trabajo-previo",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "Lecturas\nGrolemund, G., & Wickham, H. (2014). Chapter 1 - Chapter 12 en Hands-On Programming with R: Write Your Own Functions And Simulations. O’Reilly Media. https://rstudio-education.github.io/hopr/",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#introducción",
    "href": "03-r.html#introducción",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "Introducción",
    "text": "Introducción\nR es un lenguaje de programación y un entorno enfocado en graficación y en análisis estadístico. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como agricultura, biomedicina, bioinformática, finanzas, hidrología, teledetección y geografía entre muchos otros.\nAlgunas de las principales características del lenguaje de programación R son:\n\nEs interpretado: las instrucciones se traducen una por una a lenguaje de máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables de un programa solo pueden tener un tipo de datos.\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\n\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\nLa Comprehensive R Archive Network (CRAN) es una red mundial distribuida de servidores que albergan el código y la documentación oficial de R y sus paquetes. Las tasks views de CRAN categorizan la funcionalidad de R de acuerdo con temáticas determinadas.\nPara programar en R, puede utilizarse una interfaz de línea de comandos, editores de código fuente (ej. Visual Studio Code) y también entornos integrados de desarrollo (IDE, en inglés Integrated Development Environment) como Jupyter o RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "href": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.1 El ambiente de desarrollo integrado RStudio",
    "text": "3.1 El ambiente de desarrollo integrado RStudio\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de Posit Cloud. La Figura 3.1 muestra la interfaz de RStudio.\n\n\n\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.\n\n\n\nAdemás de edición de código fuente, RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas.\nEjercicios\n1. Instale en su computadora:\n\nSistema base del lenguaje R.\n\nRStudio Desktop.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conceptos-fundamentales",
    "href": "03-r.html#conceptos-fundamentales",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.2 Conceptos fundamentales",
    "text": "3.2 Conceptos fundamentales\n\n3.2.1 Manejo de datos\n\n3.2.1.1 Tipos y estructuras de datos\nR maneja los datos en una gran variedad de tipos y estructuras, los cuales incluyen tipos básicos como números, caracteres y lógicos y tipos compuestos como matrices y listas que permiten manejar varios valores conjuntamente.\nUna de las herramientas fundamentales en R para el manejo y análisis de datos es el data frame. Un data frame es una estructura rectangular de filas y columnas, en la que cada fila corresponde a una observación y cada columna a una variable. Las columnas pueden ser de diferentes tipos: números, caracteres, lógicos y muchos otros. Un data frame puede verse como lo que comúmmente se conoce como una tabla de datos (ej. las de las hojas de cálculo). Los data frames permiten realizar operaciones sobre los datos como creación de subconjuntos, ordenamientos, filtrados, cálculos estadísticos (promedio, desviación estándar, mínimo, máximo, etc.) y muchas otras.\nLos tipos y estructuras de datos de R se estudiarán con más detalle en este capítulo.\n\n\n3.2.1.2 Conjuntos de datos para ejemplos y pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"iris\"\n?iris\n\n# Visualización de iris\nView(iris)\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\nPapers with Code - conjuntos de datos\nGapminder\n\n\n\n\n3.2.2 Funciones\n\n3.2.2.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.2.2.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2024-ii\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n1. Obtenga la ruta de su directorio de trabajo con la función getwd() y anótela.\n2. Cambie la ruta de su directorio de trabajo con la función setwd() a cualquier otro directorio en el que tenga derechos de escritura. Verifique el cambio usando nuevamente getwd().\n3. Con la función create.file(), cree un archivo llamado hola.R y escriba ahí el programa “Hola mundo”: cat(\"Hola mundo\")\n4. Ejecute su programa con los botones Run y Source de RStudio.\n5. Cambie nuevamente su directorio de trabajo a la ruta que anotó en el paso 1. Copie ahí su programa y ejecútelo nuevamente.\n\n\n3.2.2.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno, sin necesidad de escribir sus nombres.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), de la instalación básica de R, para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n1. Estudie la documentación de la función plot() y agregue al gráfico anterior:\n\nUn título.\n\nUn subtítulo.\n\n\n\n3.2.2.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\n3.2.3 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. También hay paquetes que contienen datos (ej. los resultados de un censo).\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\nEn el siguiente ejemplo, se instala el paquete titanic, el cual contiene datos sobre el destino de los pasajeros durante el viaje inaugural del transatlántico RMS Titanic, resumida según el estatus económico (clase), sexo, edad y supervivencia de cada pasajero.\n\n# Instalación del paquete titanic (note las comillas)\ninstall.packages(\"titanic\")\n\nSeguidamente, el paquete titanic se carga con la función library().\n\n# Carga de titanic\nlibrary(titanic)\n\n\n\n3.2.4 Visualización de datos\n\n3.2.4.1 La función View()\nEl conjunto de datos titanic_train puede observarse, con sus observaciones y variables, con la función View(), la cual permite visualizar un conjunto de datos en una tabla.\n\n# Visualización del conjunto de datos titanic_train\nView(titanic_train)\n\nEste conjunto de datos se utiliza para entrenar modelos de aprendizaje automático (machine learning) para que realicen, por ejemplo, predicciones (ej. la supervivencia o muerte de un pasajero con base en variables como edad, clase, sexo y otras). Las predicciones del modelo se evalúan con titanic_test, el conjunto de datos de evaluación.\n\n\n3.2.4.2 Funciones básicas de graficación estadística\nLa instalación básica de R, la cual incluye el paquete base y el paquete graphics, ofrece una gran variedad de funciones para elaborar gráficos estadísticos. Esta funcionalidad se enriquece gracias al aporte de paquetes elaborados por terceros, los cuales se estudiarán posteriormente en este curso. Entre los tipos de gráficos que pueden elaborarse con la instalación básica de R están los gráficos de dispersión, los gráficos de barras, los gráficos de pastel y los histogramas.\n\n3.2.4.2.1 Gráficos de barras\nUn gráfico de barras permite representar variables de un conjunto de datos mediante barras rectangulares de longitud proporcional a los valores representados. Los gráficos de barras se utilizan principalmente para representar datos que involucran variables categóricas. Permiten comparar fácilmente cantidades o números asociados a diferentes categorías. Por ejemplo, se puede usar un gráfico de barras para mostrar la cantidad de ventas de diferentes tipos de productos, la población en diferentes ciudades, o las puntuaciones obtenidas por estudiantes en diferentes materias.\nEl siguiente gráfico de barras muestra la cantidad de pasajeros por clase en titanic_train, mediante la función barplot(), una de las funciones de graficación básica de R. Esta función recibe como argumento los valores que se desea representar en las barras, por lo que antes se utiliza la función table() para generar una tabla de contingencia con las cantidades de pasajeros que viajaban en cada clase.\n\n# Cantidades de pasajeros por clase\npasajeros_por_clase &lt;- table(titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase\n## \n##   1   2   3 \n## 216 184 491\n\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height = pasajeros_por_clase,\n  main = \"Cantidad de pasajeros por clase en el Titanic\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n\n\n\n\n\n\n\n\nLa cantidad de pasajeros en cada clase puede subdividirse en fallecidos y sobrevivientes.\n\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\npasajeros_por_clase_sobrevivencia &lt;- \n  table(titanic_train$Survived, titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase_sobrevivencia\n##    \n##       1   2   3\n##   0  80  97 372\n##   1 136  87 119\n\nEl siguiente gráfico de barras apiladas muestra la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\n\n# Gráfico de barras apiladas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas. Note el uso del argumento beside.\n\n# Gráfico de barras agrupadas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n3.2.4.2.2 Gráficos de pastel\nLos gráficos de pastel se utilizan para mostrar proporciones o porcentajes, representando la composición de un todo. Son especialmente útiles para resaltar cómo se divide un conjunto en categorías, donde cada segmento del pastel (slice o “rebanada”) representa la proporción o porcentaje de esa categoría dentro del total. Por lo tanto, son más adecuados para visualizar datos categóricos o cualitativos, no para datos numéricos continuos.\nLa cantidad de pasajeros por clase en titanic_train también puede mostrarse en un gráfico de pastel, mediante la función pie de la instalación básica de R.\n\n# Gráfico de pastel por clase de pasajero\npie(\n  x = pasajeros_por_clase, \n  main = \"Distribución de pasajeros por clase en el Titanic\",\n  labels = paste(names(pasajeros_por_clase), \":\", pasajeros_por_clase)\n)\n\n\n\n\n\n\n\n\n\n\n3.2.4.2.3 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (en este caso, llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable.\nEn la instalación básica de R, los histogramas se implementan mendiante la función hist().\n\nhist(\n  x = titanic_train$Age, \n  breaks = 8,\n  main = \"Distribución de la edad de los pasajeros del Titanic\", \n  xlab = \"Edad\", \n  ylab = \"Frecuencia\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas.\nGuarde los gráficos en un archivo PDF (puede consultar Saving plots to a file with pdf(), jpeg() and png()).\n\n\n\n\n\n3.2.5 Tipos de datos\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\nR proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz. R también permite que el programador defina sus propios objetos.\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y &lt;- (o -&gt;). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\n\n# Número\nx &lt;- 10\nx\n## [1] 10\n\n# Otro número\n20 -&gt; y\ny\n## [1] 20\n\n# Hilera de caracteres\nnombre &lt;- 'Manuel'\nnombre\n## [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias &lt;- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n## [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"    \"Viernes\"  \n## [7] \"Sábado\"\n\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\nEl tipo de un objeto puede consultarse con la función typeof(). Por ejemplo:\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(nombre)\n## [1] \"character\"\ntypeof(dias)\n## [1] \"character\"\n\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\n\n3.2.5.1 Tipos básicos\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\n\n3.2.5.1.1 Números\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\n\n# Declaración de variables numéricas\nx &lt;- 5\ny &lt;- 0.5\n\n# Suma\nx + y\n## [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(x + y)\n## [1] \"double\"\n\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\n\n# Números enteros\nx &lt;- 10L\ny &lt;- as.integer(15)\n\n# Multiplicación\nx * y\n## [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"integer\"\ntypeof(x * y)\n## [1] \"integer\"\n\n\n\n3.2.5.1.2 Caracteres\nSe utilizan para representar textos. Deben estar entre comillas simples ('') o dobles (\"\").\n\n# Hileras de caracteres\nnombre &lt;- \"María\"\napellido &lt;- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n## [1] \"María Pérez\"\n\n\n\n3.2.5.1.3 Lógicos\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\n\n# Variable lógica\na &lt;- 1 &lt; 2\na\n## [1] TRUE\n\n# Variable lógica\nb &lt;- 1 &gt; 2\nb\n## [1] FALSE\n\nLas expresiones lógicas pueden combinarse con operadores como:\n\n& (Y, en inglés AND)\n| (O, en inglés OR)\n! (NO, en inglés NOT)\n\n\n# Operador lógico AND\n(1 &lt; 2) & (3 &lt; 4)\n## [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 &lt;= 10)\n## [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n## [1] TRUE\n\n\n\n3.2.5.1.4 Vectores\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\n\n3.2.5.1.4.1 Definición\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\n\n# Definición de un vector de números\nvector_numeros &lt;- c(1, 7, 32, 45, 57)\nvector_numeros\n## [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres &lt;- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n## [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia (i.e. una lista ordenada):\n\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia &lt;- 1:10\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia &lt;- -5:5\nvector_secuencia\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia &lt;- -0.5:3.7\nvector_secuencia\n## [1] -0.5  0.5  1.5  2.5  3.5\n\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\n\n# Definición de un vector de números en secuencia de 1 a 10\nvector_secuencia &lt;- seq(1, 10)\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números en secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia &lt;- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n## [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números en secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia &lt;- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n## [1] 1.500000 4.133333 6.766667 9.400000\n\n\n\n3.2.5.1.4.2 Indexación\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\n\n# Vector de nombres de países\npaises &lt;- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n## [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"\n\n# Elemento en el índice 3\npaises[3]\n## [1] \"China\"\n\nEl operador : puede utilizarse para especificar un rango de índices:\n\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n## [1] \"Francia\"   \"China\"     \"Australia\"\n\nCon la función c(), es posible especificar un conjunto de índices particulares:\n\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n## [1] \"Argentina\" \"Australia\" \"México\"\n\nLos números negativos pueden usarse para excluir índices:\n\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n## [1] \"Argentina\" \"Francia\"   \"México\"\n\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\n\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n## [1] \"Argentina\" \"Francia\"   \"Australia\"\n\n\n\n3.2.5.1.4.3 Operaciones\nEn los vectores pueden aplicarse operaciones aritméticas:\n\na &lt;- c(1, 3, 5, 7)\nb &lt;- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n## [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n## [1]  2 12 30 56\n\nY también pueden realizarse operaciones relacionales:\n\n# Comparación con el operador &lt;\na &lt; b\n## [1] TRUE TRUE TRUE TRUE\n\n\n\n\n3.2.5.1.5 Matrices\nUna matriz es una estructura bidimensional de filas y columnas.\n\n3.2.5.1.5.1 Definición\nLas matrices se definen mediante la función matrix().\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm &lt;- matrix(1:9, nrow=3, ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm &lt;- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos &lt;- c(18, 500, 25, 1000, 30, 2000)\nfilas &lt;- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas &lt;- c(\"Edad\", \"Salario\")\n\nm &lt;- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n## Laura   30    2000\n\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\n\n\n3.2.5.1.5.2 Indexación\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\n\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n## [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n##    Edad Salario \n##      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n##   Ana Mario Laura \n##   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n##    Edad Salario \n##      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n##   Ana Mario Laura \n##   500  1000  2000\n\n\n\n3.2.5.1.5.3 Operaciones\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\n\na &lt;- matrix(1:4, nrow=2, ncol=2)\na\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n\nb &lt;- matrix(5:8, nrow=2, ncol=2)\nb\n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\n# Suma de matrices\na + b\n##      [,1] [,2]\n## [1,]    6   10\n## [2,]    8   12\n\n# Multiplicación de matrices\na * b\n##      [,1] [,2]\n## [1,]    5   21\n## [2,]   12   32\n\n# Comparación de matrices con el operador &gt;\na &gt; b\n##       [,1]  [,2]\n## [1,] FALSE FALSE\n## [2,] FALSE FALSE\n\n\n\n\n\n3.2.5.2 Tipos compuestos\n\n3.2.5.2.1 Data Frames\nUn data frame es una estructura bidimensional similar a lo que comúnmente se conoce como una tabla. Sus filas corresponden a las observaciones de un conjunto de datos y sus columnas a las variables. Internamente, se componen de varios vectores, factores y/o matrices de la misma longitud. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o una tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\n\n3.2.5.2.1.1 Definición\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\n\n# Vector de nombres de países\npaises &lt;-\n  c(\"Panamá\",\n    \"Costa Rica\",\n    \"Nicaragua\",\n    \"El Salvador\",\n    \"Honduras\",\n    \"Guatemala\",\n    \"Belice\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones &lt;- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises &lt;- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       4.1\n## 2  Costa Rica       5.0\n## 3   Nicaragua       6.2\n## 4 El Salvador       6.4\n## 5    Honduras       9.2\n## 6   Guatemala      16.9\n## 7      Belice       0.3\n\n\n\n3.2.5.2.1.2 Indexación\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\n\n# Fila 1\npoblaciones_paises[1, ]\n##     pais poblacion\n## 1 Panamá       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n##       pais poblacion\n## 1   Panamá       4.1\n## 5 Honduras       9.2\n## 7   Belice       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n## [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n## [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n## [1] 4.1 5.0 6.2 6.4\n\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\n\n# Columna de nombres de países\npoblaciones_paises$pais\n## [1] \"Panamá\"      \"Costa Rica\"  \"Nicaragua\"   \"El Salvador\" \"Honduras\"   \n## [6] \"Guatemala\"   \"Belice\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises_2 &lt;- poblaciones_paises # copia del dataframe original\npoblaciones_paises_2$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises_2\n##          pais poblacion\n## 1      Panamá       8.2\n## 2  Costa Rica      10.0\n## 3   Nicaragua      12.4\n## 4 El Salvador      12.8\n## 5    Honduras      18.4\n## 6   Guatemala      33.8\n## 7      Belice       0.6\n\nLa notación de paréntesis cuadrados ([]) y el signo de dólar ($) también permite crear subconjuntos con base en expresiones lógicas.\n\n# Ejemplos de uso de la notación $\n\n# Países con población mayor a 6 millones de habitantes\npoblaciones_paises[poblaciones_paises$poblacion &gt; 6,]\n\n         pais poblacion\n3   Nicaragua       6.2\n4 El Salvador       6.4\n5    Honduras       9.2\n6   Guatemala      16.9\n\n\n\n\n3.2.5.2.1.3 Operaciones\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\n\n# Lectura de archivo CSV ubicado en la Web\ncovid &lt;-\n  read.csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv\"\n  )\n\n# Despliegue de los datos del data frame\ncovid\n##          pais fallecidos recuperados activos positivos\n## 1      Panamá       6198      351949    3845    361992\n## 2  Costa Rica       3125      199779   32370    235274\n## 3   Guatemala       7345      194075   16725    218145\n## 4    Honduras       4981       77020  121358    203359\n## 5 El Salvador       2089       64208    1864     68161\n## 6      Belice        318       12164     114     12596\n## 7   Nicaragua        181        5212      57      5450\n\nLa función str() despliega la estructura de un data frame u otro objeto R.\n\n# Estructura del data frame\nstr(poblaciones_paises)\n\n'data.frame':   7 obs. of  2 variables:\n $ pais     : chr  \"Panamá\" \"Costa Rica\" \"Nicaragua\" \"El Salvador\" ...\n $ poblacion: num  4.1 5 6.2 6.4 9.2 16.9 0.3\n\n\nLa función summary() proporciona un resumen de los contenidos de un data frame:\n\n# Resumen de los contenidos del data frame\nsummary(poblaciones_paises)\n\n     pais             poblacion     \n Length:7           Min.   : 0.300  \n Class :character   1st Qu.: 4.550  \n Mode  :character   Median : 6.200  \n                    Mean   : 6.871  \n                    3rd Qu.: 7.800  \n                    Max.   :16.900  \n\n\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\n\n# Vista de los casos de COVID-19\nView(covid, \"Casos de COVID-19 en Centramérica\")\n\n\n\n\n3.2.5.2.2 Factores\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\n\n3.2.5.2.2.1 Definición\nUn factor se crea con la función factor().\n\n# Factor de valores de sexo\nsexo &lt;- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\n\n\n\n3.2.5.2.2.2 Operaciones\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\n\n# Etiquetas de los niveles\nlevels(sexo)\n## [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n## [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n## sexo\n##  Femenino Masculino \n##         2         2\n\n\n\n\n\n3.2.5.3 Otros\n\n3.2.5.3.1 Fechas\nLas fechas se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, una fecha en R se almacena como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\n\n3.2.5.3.1.1 Operaciones\nLa función Sys.Date() retorna la fecha actual.\n\n# Fecha actual\nfecha_actual &lt;- Sys.Date()\nfecha_actual\n## [1] \"2024-08-29\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n## [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n## [1] \"Date\"\n\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato. El formato que se usa por defecto (y el recomendado) es el que corresponde a la norma ISO 8601 (ej. 2023-12-03), pero pueden emplearse otros también.\n\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 &lt;- \"2020-01-01\"\nfecha_01 &lt;- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n\n[1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 &lt;- \"31/01/2020\"\nfecha_02 &lt;- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n\n[1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n\nTime difference of 30 days\n\n\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers.\n\n\n\n\n\n3.2.6 Definición de funciones\nAdemás de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.\nToda función tiene tres partes esenciales:\n\nUn nombre.\nUn conjunto de argumentos.\nUn conjunto de líneas de código, también llamado el cuerpo de la función.\n\nPara programar una función, debe definirse cada una de esas partes por medio de la palabra reservada function function().\nPor ejemplo, la siguiente función calcula la nota final de un curso con base en los argumentos correspondientes a los promedios de exámenes, proyectos y tareas.\n\n# Función que calcula la nota final de un curso\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos,\n                       promedio_tareas) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  return(factor_examenes + factor_proyectos + factor_tareas)\n}\n\nLa función return() es la que define el valor de retorno de la función. Si no se incluye, la función retorna la última expresión evaluada.\nAhora que está definida, la función nota_final() puede ser “llamada”, con diferentes argumentos:\n\n# Si ni se incluyen los nombres de los argumentos, \n# la función asume que se ingresan en el mismo orden en el que fueron definidos\nnota_final(100, 50, 0)\n## [1] 70\n\n# El uso de los nombres de argumentos \n# permite modificar su orden\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\n## [1] 70\n\nSi se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.\nSeguidamente, la función nota_final() se redefine asignando valores por defecto a algunos de los argumentos:\n\n# Redefinición de la función nota final,\n# con valores por defecto para los argumentos\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos = 0,\n                       promedio_tareas = 0) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  # Al no llamarse a la función return(), se retorna la última expresión:\n  factor_examenes + factor_proyectos + factor_tareas\n}\n\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\n## [1] 70\n\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\nnota_final(100, promedio_proyectos = 50)\n## [1] 70\n\nEjercicios\n1. Defina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.\n2. Defina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.\n3. Defina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros).\n\n\n3.2.7 Condicionales\nLas sentencias condicionales evalúan una expresión lógica (i.e. condición) y ejecutan, o no, un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.\nLos condicionales en R se implementa mediante la sentencia if y sus cláusulas else y else if.\n\n3.2.7.1 La sentencia if\nLa sentencia if evalúa una condición (i.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.\n\n# Sintaxis de la sentencia if\nif (condicion) {\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\n}\n\nPor ejemplo:\n\n# Edad de una persona\nedad &lt;- 25\n\n# Se utiliza la sentencia if para determinar \n# si la persona es adulta\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n}\n## [1] \"Adulto\"\n\nYa sea que se ejecute o no el bloque del if, el programa continúa con las instrucciones que siguen al bloque, si las hay.\n\n\n3.2.7.2 La cláusula else\nUna sentencia if puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa. Por ejemplo:\n\nedad &lt;- 15\n\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n} else {\n  print(\"Menor\")\n}\n\n[1] \"Menor\"\n\n\n\n\n3.2.7.3 La cláusula else if\nUna sentencia if también puede ir seguida de una o varias cláusulas else if, las cuales evalúan condiciones adicionales.\n\nedad &lt;- 70\n\nif (edad &lt; 18) {\n  print(\"Menor\")\n} else if (edad &lt; 65) {\n  print(\"Adulto\")\n} else {\n  print(\"Adulto mayor\")\n}\n\n[1] \"Adulto mayor\"\n\n\nLas cláusulas else if deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else if como la cláusula else son opcionales.\nEjercicios\n1. Defina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente a la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de masa corporal - Wikipedia.\n\n\n\n3.2.8 Ciclos\nLos ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con sentencias que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.\nLos ciclos en R se implementan mediante las sentencias for, while y repeat, en combinación con las sentencias break y next.\nR provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que no es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.\n\n3.2.8.1 La sentencia for\nLa sentencia for repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración (i.e. cada “vuelta” del ciclo), el valor del elemento que está siendo procesado se almacena en una variable.\n\n# Sintaxis de la sentencia for\nfor (variable in vector) {\n  # bloque de instrucciones\n}\n\nPor ejemplo, el siguiente bloque de código utiliza un ciclo de tipo for para recorrer un vector de nombres e imprimir un saludo para cada uno.\n\n# Vector con nombres de personas\nvector_nombres &lt;- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Recorrido del vector\nfor (nombre in vector_nombres) {\n  cat(\"Hola\", nombre, \"\\n\")\n}\n## Hola Andrés \n## Hola Beatriz \n## Hola Carlos \n## Hola Marta \n## Hola Pedro \n## Hola Sara\n\nEn el siguiente ejemplo, se utiliza otro ciclo for para recorrer un vector de números y sumar sus elementos.\n\n# Vector de números\nvector_numeros &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\n\n# Variable para la suma de los números\nsuma &lt;- 0\n\n# Recorrido del vector\nfor (x in vector_numeros) {\n  suma &lt;- suma + x\n}\n\n# Impresión de la suma\ncat(\"Suma:\", suma)\n## Suma: 140.95\n\nSeguidamente, se utiliza dos for “anidados” para sumar los elementos de cada una de las columnas de una matriz.\n\n# Matriz de números\nmatriz_numeros &lt;- matrix(1:12, nrow=3, ncol=4)\nmatriz_numeros\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\n# Ciclo externo para recorrer las columnas de la matriz\nfor (j in 1:ncol(matriz_numeros)) {\n  suma_columna &lt;- 0\n  # Ciclo interno para recorrer las elementos de cada columna\n  for (i in 1:nrow(matriz_numeros)) {\n    suma_columna &lt;- suma_columna + matriz_numeros[i, j]\n  }\n  print(suma_columna)\n}\n## [1] 6\n## [1] 15\n## [1] 24\n## [1] 33\n\nEjercicios\n1. Utilice un ciclo for para recorrer el vector vector_numeros y calcular el promedio de sus elementos.\n2. Utilice dos ciclos for anidados para recorrer la matriz vector_numeros y calcular el promedio de cada una de sus columnas.\n\n\n3.2.8.2 La sentencia while\nLa sentencia while evalúa una condición (i.e. una expresión lógica) en cada iteración de un ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.\n\n# Sintaxis de la sentencia while\nwhile (condicion) {\n  # bloque de instrucciones \n}\n\nEn el siguiente ejemplo, se utiliza un ciclo while para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta &lt;- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\nwhile (leer_respuesta() != \"42\") {   \n  print(\"¡Su respuesta es incorrecta!\")\n}\n\nEjercicios\n1. Utilice un ciclo while para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#recursos-de-interés",
    "href": "03-r.html#recursos-de-interés",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.3 Recursos de interés",
    "text": "3.3 Recursos de interés\nFind Open Datasets and Machine Learning Projects | Kaggle. (s. f.). Recuperado 24 de abril de 2022, de https://www.kaggle.com/datasets\nIndicators | Data. (s.f.). Recuperado 11 de septiembre de 2022, de https://data.worldbank.org/indicator\nNewest «r» Questions. (s. f.). Stack Overflow. Recuperado 24 de abril de 2022, de https://stackoverflow.com/questions/tagged/r\nPapers with Code—Machine Learning Datasets. (s.f.). Recuperado 11 de septiembre de 2022, de https://paperswithcode.com/datasets\nR Language Definition. (s. f.). Recuperado 24 de abril de 2022, de https://cran.r-project.org/doc/manuals/r-release/R-lang.html\nR Package Documentation. (s.f.). Recuperado 11 de septiembre de 2022, de https://rdrr.io/\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.",
    "crumbs": [
      "II - El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "href": "parte-iii-herramientas-investigacion-reproducible-desarrollo-colaborativo.html",
    "title": "III - Herramientas para investigación reproducible y desarrollo colaborativo",
    "section": "",
    "text": "5 Reproducibilidad\n6 Markdown - lenguaje de marcado\n7 Git - sistema de control de versiones\n8 Quarto - sistema de publicación técnica y científica",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo"
    ]
  },
  {
    "objectID": "04-markdown.html",
    "href": "04-markdown.html",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#trabajo-previo",
    "href": "04-markdown.html#trabajo-previo",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "",
    "text": "Lecturas\nQuarto - Markdown Basics. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/authoring/markdown-basics.html\n\n\nTutoriales\nMarkdown Tutorial. (s.f.). Recuperado el 1 de marzo de 2024, de https://www.markdowntutorial.com/",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#introducción",
    "href": "04-markdown.html#introducción",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "Introducción",
    "text": "Introducción\nMarkdown es un lenguaje de marcado, creado en 2004 por John Gruber y Aaron Swartz. Las “marcas” se utilizan para especificar aspectos de la estructura (ej. títulos, encabezados), estilo (ej. negritas, itálicas) y semántica de un documento. Markdown se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcado (ej. Lenguaje de Marcado de Hipertexto o HTML), por lo que se considera un lenguaje de marcado ligero.\nLos documentos escritos en Markdown pueden exportarse a una gran variedad de formatos (ej. HTML, DOC, PDF, LaTex) para ser usados en libros, presentaciones o páginas web, entre otros fines.\nLas variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:\n\nR Markdown: para el lenguaje R.\nQuarto: es la “siguiente generación” de R Markdown, con soporte para más lenguajes de programación (Python, Julia, Observable, R) y motores de procesamiento (Jupyter, Knitr), entre otras mejoras. Más que una variación de Markdown es un sistema de publicación de documentos técnicos y científicos que utiliza Markdown.\nPython Markdown: para el lenguaje Python.\nGitHub Flavored Markdown: para la plataforma GitHub.\nPandoc’s Markdown: para el programa Pandoc de conversión entre formatos.\n\nPuede encontrarse una lista más extensa de variaciones de Markdown en Markdown Flavors.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#ejemplo-de-documento",
    "href": "04-markdown.html#ejemplo-de-documento",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.1 Ejemplo de documento",
    "text": "4.1 Ejemplo de documento\nEl siguiente es un ejemplo de documento Markdown. Se muestra primero la sintaxis del documento y luego la manera en la que se visualiza.\n\n4.1.1 Sintaxis\nLa sintaxis del documento incluye marcas para un encabezado, texto en negrita, texto en itálica, hipervínculos y una imagen.\n\n\n### Los satélites galileanos\n\nSe llaman **satélites galileanos** los cuatro satélites de\n[Júpiter](https://es.wikipedia.org/wiki/J%C3%BApiter_(planeta))\ndescubiertos en 1610 por el astrónomo italiano\n[Galileo Galilei](https://es.wikipedia.org/wiki/Galileo_Galilei) (1564 - 1642): \n*Ío*, *Europa*, *Ganimedes* y *Calisto*. \nSon los más grandes de los satélites de Júpiter, \nsiendo visibles incluso con telescopios de baja potencia.\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n**Figura 1**. Los cuatro satélites galileanos, \nen una composición que compara sus tamaños con el tamaño de Júpiter. \nEn orden descendente, son *Ío*, *Europa*, *Ganimedes* y *Calisto*.\n\n\n\n\n4.1.2 Visualización\n\n\n\nLos satélites galileanos\nSe llaman satélites galileanos los cuatro satélites de Júpiter descubiertos en 1610 por el astrónomo italiano Galileo Galilei (1564 - 1642): Ío, Europa, Ganimedes y Calisto. Son los más grandes de los satélites de Júpiter, siendo visibles incluso con telescopios de baja potencia.\n\nFigura 1. Los cuatro satélites galileanos, en una composición que compara sus tamaños con el tamaño de Júpiter. En orden descendente, son Ío, Europa, Ganimedes y Calisto.\n\nEl contenido de este ejemplo está basado en Satélite galileano - Wikipedia, la enciclopedia libre.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#herramientas-para-escritura-de-documentos",
    "href": "04-markdown.html#herramientas-para-escritura-de-documentos",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.5 Herramientas para escritura de documentos",
    "text": "4.5 Herramientas para escritura de documentos\nMarkdown se escribe en “texto simple o plano” (i.e. texto sin formato, compuesto únicamente por caracteres que son legibles por humanos), por lo que puede escribirse con cualquier editor de texto. Se recomienda el uso de editores orientados a programación, también llamados editores de código fuente, los cuales proporcionan facilidades para el programador, como coloración de palabras clave, sangrado y autocompletado, entre otras.\nTambién pueden utilizarse Entornos Integrados de Desarrollo o IDE, los cuales son aplicaciones informáticas que proporcionan servicios integrales para facilitarle al programador el desarrollo de software. Además de un editor de código fuente, un IDE incluye funciones para depuración (i.e. identificación de errores), interpretación y compilación de programas, entre otras.\nAlgunos de los editores de código fuente o IDE recomendados para Markdown son:\n\nVisual Studio Code: editor de código fuente muy popular y de código abierto. Puede editar código de múltiples lenguajes de programación y sintaxis asociadas\nRStudio: IDE para desarrollo en el lenguaje de programación R, el cual también puede manejar código en otros lenguajes de programación y sintaxis.\n\nNo se recomienda el uso de procesadores de texto (ej. Microsoft Word, Libre Office Writer), debido a que introducen caracteres especiales que no son reconocidos por Markdown.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#sintaxis",
    "href": "04-markdown.html#sintaxis",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.6 Sintaxis",
    "text": "4.6 Sintaxis\nEn esta sección, se muestran los principales elementos de sintaxis de Markdown y sus salidas.\n\n\n4.6.1 Encabezados\nHay seis niveles de encabezados en Markdown, siendo el nivel 1 el de letras más grandes y el 6 el de letras más pequeñas. Se especifican mediante símbolos de numeral (#) antes del texto del encabezado (note el espacio entre el último signo de numeral y el inicio del texto).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n# Encabezado de nivel 1\n\n\n\nEncabezado de nivel 1\n\n\n\n\n\n## Encabezado de nivel 2\n\n\n\nEncabezado de nivel 2\n\n\n\n\n\n### Encabezado de nivel 3\n\n\n\nEncabezado de nivel 3\n\n\n\n\n\n#### Encabezado de nivel 4\n\n\n\nEncabezado de nivel 4\n\n\n\n\n\n##### Encabezado de nivel 5\n\n\n\nEncabezado de nivel 5\n\n\n\n\n\n###### Encabezado de nivel 6\n\n\n\nEncabezado de nivel 6\n\n\n\n\nPara los encabezados de nivel 1 y nivel 2, existe una sintaxis alterna, con símbolos de igual (=====) o guiones (-----) bajo el texto del encabezado.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nOtro encabezado de nivel 1 ==========================\n\n\n\n\nOtro encabezado de nivel 1\n\n\n\n\n\nOtro encabezado de nivel 2 --------------------------\n\n\n\nOtro encabezado de nivel 2\n\n\n\n\n\n\n4.6.2 Párrafos\nLos párrafos deben separarse mediante (al menos) una línea en blanco. Un simple cambio de línea no generará un nuevo párrafo.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\n\n\n\n4.6.3 Negrita\nHay dos sintaxis para especificar texto en negrita: con dos asteriscos (**) o con dos guiones bajos (__), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n**Texto en negrita**\n\n\nTexto en negrita\n\n\n\n\n__Otro texto en negrita__\n\n\nOtro texto en negrita\n\n\n\n\n\n4.6.4 Itálica\nHay dos sintaxis para especificar texto en itálica: con un asterisco (*) o con un guión bajo (_), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n*Texto en itálica*\n\n\nTexto en itálica\n\n\n\n\n_Otro texto en itálica_\n\n\nOtro texto en itálica\n\n\n\n\n\n4.6.5 Citas textuales\nSe especifican con un símbolo de “mayor que” (&gt;) antes de cada línea.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n&gt; *And on the pedestal these words appear:* &gt; *\"My name is Ozymandias, king of kings:* &gt; *Look on my works, ye Mighty, and despair!\"* *Percy Bysshe Shelley, \"Ozymandias\" (1818)*\n\n\n\n “And on the pedestal these words appear:”My name is Ozymandias, king of kings: Look on my works, ye Mighty, and despair!“ \n\nPercy Bysshe Shelley, “Ozymandias” (1818)\n\n\n\n\n\n4.6.6 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento al que conduce el enlace.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n[Proyecto Gutenberg](https://www.gutenberg.org/)\n\n\nProyecto Gutenberg\n\n\n\n\n\n4.6.7 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n![Imagen local](img/Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n![Imagen remota](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n\n4.6.8 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento.\n2. Segundo elemento.\n3. Tercer elemento.\n\n\n\n\nPrimer elemento.\nSegundo elemento.\nTercer elemento.\n\n\n\n\n\n\n4.6.9 Listas no numeradas\nSe definen con guiones (-) o asteriscos (*) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento.\n- Otro elemento.\n- Otro elemento más.\n\n\n\n\nUn elemento.\n\nOtro elemento.\n\nOtro elemento más.\n\n\n\n\n\n\n\n4.6.10 Notación matemática\nLas expresiones en notación matemática (ej. ecuaciones) se escriben con base en la sintaxis de LaTeX. Se delimitan (al inicio y al final) con:\n\nUn símbolo de dólar ($), para ecuaciones dentro de un renglón (inline math).\nDos símbolos de dólar ($$), para ecuaciones en su propio bloque (display math).\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEquivalencia entre masa y energía: $E = mc^{2}$\n\n\n\nEquivalencia entre masa y energía: \\(E = mc^{2}\\)\n\n\n\n\nEquivalencia entre masa y energía: $$E = mc^{2}$$\n\n\nEquivalencia entre masa y energía:\n\\[E = mc^{2}\\]\n\n\n\nPara más detalles sobre la sintaxis de las expresiones matemáticas, se recomienda consultar:\n\nWriting mathematical expressions - GitHub Docs\nLaTeX/Mathematics",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#ejercicios",
    "href": "04-markdown.html#ejercicios",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.3 Ejercicios",
    "text": "4.3 Ejercicios\n\nEn RStudio, cree un nuevo proyecto con la opción File - New Project - New Directory - New Project de RStudio.\nEn el nuevo proyecto, cree un nuevo documento Markdown con la opción File - New File - Markdown File de RStudio. y escriba en este un breve curriculum académico o profesional.\n\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.\nPuede usar información ficticia (no incluya datos confidenciales o sensibles).\nEspecifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y no utilice imágenes para las que no tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).\nAsegúrese de utilizar los siguientes elementos de sintaxis Markdown:\n\nEncabezados de varios niveles.\nNegritas e itálicas.\nListas.\nEnlaces a sitios web.\nImágenes (al menos una local y una remota).\n\n\nGuarde el documento con el nombre README.md (RStudio asigna la extensión automáticamente).\nCree una cuenta gratuita en la plataforma de desarrollo colaborativo de software GitHub.\nCree un repositorio vacío en su cuenta en GitHub (ej. curriculum-vitae).\nSuba al nuevo repositorio el archivo README.md.\nGenere un sitio web en el servicio de alojamiento GitHub Pages con la opción Settings - Pages - Branch - main - Save de GitHub.\nRepita los pasos 6 y 7 para cada modificación que realice en el documento Markdown.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#recursos-de-interés",
    "href": "04-markdown.html#recursos-de-interés",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.4 Recursos de interés",
    "text": "4.4 Recursos de interés\nDaring Fireball: Markdown. (s. f.). Recuperado 25 de marzo de 2023, de https://daringfireball.net/projects/markdown/\nLaTeX/Mathematics—Wikibooks, open books for an open world. (s. f.). Recuperado 25 de marzo de 2023, de https://en.wikibooks.org/wiki/LaTeX/Mathematics\nMarkdown Guide. (s. f.). Recuperado 10 de abril de 2022, de https://www.markdownguide.org/\nWriting mathematical expressions. (s. f.). GitHub Docs. Recuperado 25 de marzo de 2023, de https://ghdocs-prod.azurewebsites.net/en/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "04-markdown.html#sintaxis-1",
    "href": "04-markdown.html#sintaxis-1",
    "title": "4  Markdown - lenguaje de marcado",
    "section": "4.2 Sintaxis",
    "text": "4.2 Sintaxis\nEn esta sección, se muestran los principales elementos de sintaxis de Markdown y sus salidas.\n\n\n4.2.1 Encabezados\nHay seis niveles de encabezados en Markdown, siendo el nivel 1 el de letras más grandes y el 6 el de letras más pequeñas. Se especifican mediante símbolos de numeral (#) antes del texto del encabezado (note el espacio entre el último signo de numeral y el inicio del texto).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n# Encabezado de nivel 1\n\n\n\nEncabezado de nivel 1\n\n\n\n\n\n## Encabezado de nivel 2\n\n\n\nEncabezado de nivel 2\n\n\n\n\n\n### Encabezado de nivel 3\n\n\n\nEncabezado de nivel 3\n\n\n\n\n\n#### Encabezado de nivel 4\n\n\n\nEncabezado de nivel 4\n\n\n\n\n\n##### Encabezado de nivel 5\n\n\n\nEncabezado de nivel 5\n\n\n\n\n\n###### Encabezado de nivel 6\n\n\n\nEncabezado de nivel 6\n\n\n\n\nPara los encabezados de nivel 1 y nivel 2, existe una sintaxis alterna, con símbolos de igual (=====) o guiones (-----) bajo el texto del encabezado.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nOtro encabezado de nivel 1 ==========================\n\n\n\n\nOtro encabezado de nivel 1\n\n\n\n\n\nOtro encabezado de nivel 2 --------------------------\n\n\n\nOtro encabezado de nivel 2\n\n\n\n\n\n\n4.2.2 Párrafos\nLos párrafos deben separarse mediante (al menos) una línea en blanco.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\nEste es el texto que corresponde al primer párrafo de un documento.\nEste es el texto que corresponde al segundo párrafo de un documento.\n\n\n\n\n\n4.2.3 Cambios de línea\nSi se requiere un cambio de línea sin una línea en blanco entre párrafos, pueden agregarse dos espacios en blanco al final de la línea () o también un espacio y una barra invertida (\\).\n\n\n4.2.4 Texto en negrita\nHay dos sintaxis para especificar texto en negrita: con dos asteriscos (**) o con dos guiones bajos (__), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n**Texto en negrita**\n\n\nTexto en negrita\n\n\n\n\n__Otro texto en negrita__\n\n\nOtro texto en negrita\n\n\n\n\n\n4.2.5 Texto en itálica\nHay dos sintaxis para especificar texto en itálica: con un asterisco (*) o con un guión bajo (_), antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n*Texto en itálica*\n\n\nTexto en itálica\n\n\n\n\n_Otro texto en itálica_\n\n\nOtro texto en itálica\n\n\n\n\n\n4.2.6 Texto tachado\nEl texto tachado se especifica con dos guiones (--) antes y después del texto.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n--Texto tachado--\n\n\nTexto tachado\n\n\n\n\n\n4.2.7 Superíndices y subíndices\nUn superíndice se especifica con un acento circunflejo (^) antes y después del texto que se desea mostrar como superíndice. Un subíndice se especifica con un guión (-) antes y después del texto que se desea mostrar como subíndice.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nsuperíndice^2^\n\n\nsuperíndice2\n\n\n\n\nsubíndice-2-\n\n\nsubíndice2\n\n\n\n\n\n4.2.8 Líneas horizontales\nTres o más asteriscos (***) generan una línea horizontal:\n***\n\nTambién puede generarse con tres o más guiones (---):\n---\n\n\n\n4.2.9 Citas textuales\nSe especifican con un símbolo de “mayor que” (&gt;) antes de cada línea.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n&gt; *And on the pedestal these words appear:*\n&gt; *\"My name is Ozymandias, king of kings:*\n&gt; *Look on my works, ye Mighty, and despair!\"*\nPercy Bysshe Shelley, \"Ozymandias\" (1818)\n\n\n\n And on the pedestal these words appear: “My name is Ozymandias, king of kings: Look on my works, ye Mighty, and despair!” \n\nPercy Bysshe Shelley, “Ozymandias” (1818)\n\n\n\n\n\n4.2.10 Enlaces (hipervínculos)\nSe definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento al que conduce el enlace.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n[Proyecto Gutenberg](https://www.gutenberg.org/)\n\n\nProyecto Gutenberg\n\n\n\n\n\n4.2.11 Imágenes\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota. Una imagen local se encuentra en la misma computadora en la que está el documento que la referencia, mientras que una imagen remota se encuentra en otra computadora a la que se accede mediante un protocolo de redes como el Protocolo de transferencia de hipertexto (HTTP).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n![Imagen local](img/Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\n\n![Imagen remota](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Jupiter_and_the_Galilean_Satellites.jpg/168px-Jupiter_and_the_Galilean_Satellites.jpg)\n\n\n\n\n\n\nMarkdown no cuenta con sintaxis para especificar el tamaño de una imagen, pero esto puede lograrse con el Lenguaje de marcado de hipertexto (HTML, HyperText Markup Language), su elemento img y sus atributos height y width, los cuales especifican la altura y el ancho de una imagen (las unidades por defecto son pixeles).\nPor ejemplo, la expresión HTML:\n&lt;img src=\"img/Jupiter_and_the_Galilean_Satellites.jpg\" height=\"100\" alt=\"Imagen local\"&gt;\ngenera como salida una imagen de 100 pixeles de altura:\n\nSi se usa solo el atributo height, width se ajusta automáticamente y viceversa.\n\n\n4.2.12 Listas numeradas\nSe definen con números (1. 2. 3. ...) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento.\n2. Segundo elemento.\n3. Tercer elemento.\n\n\n\n\nPrimer elemento.\nSegundo elemento.\nTercer elemento.\n\n\n\n\nLas listas numeradas pueden anidarse para mostrar la información de una forma jerárquica. Para crear un nivel de anidación, deben usarse sangrías con una cantidad de espacios consistente en toda la lista. La numeración se ordena automáticamente (incluso si hay errores).\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento\n            1. Elemento anidado\n            2. Elemento anidado\n2. Segundo elemento\n            1. Elemento anidado\n            2. Elemento anidado\n3. Tercer elemento\n            1. Elemento anidado\n            2. Elemento anidado\n\n\n\n\nPrimer elemento\n\nElemento anidado\nElemento anidado\n\nSegundo elemento\n\nElemento anidado\nElemento anidado\n\nTercer elemento\n\nElemento anidado\nElemento anidado\n\n\n\n\n\n\n\n4.2.13 Listas no numeradas\nSe definen con guiones (-), asteriscos (*) o signos de adición (+) antes de cada elemento.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento\n- Otro elemento\n- Otro elemento más\n\n\n\n\nUn elemento\n\nOtro elemento\n\nOtro elemento más\n\n\n\n\n\nLas listas no numeradas también pueden anidarse. Debe utilizarse un mínimo de dos espacios en los elementos anidados.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n- Un elemento\n            + Elemento anidado\n            + Elemento anidado\n- Otro elemento\n            + Elemento anidado\n            + Elemento anidado\n- Otro elemento más\n            + Elemento anidado\n            + Elemento anidado\n\n\n\n\nUn elemento\n\nElemento anidado\nElemento anidado\n\nOtro elemento\n\nElemento anidado\nElemento anidado\n\nOtro elemento más\n\nElemento anidado\nElemento anidado\n\n\n\n\n\nLas listas numeradas y las no numeradas pueden intercalarse.\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\n1. Primer elemento\n            - Elemento anidado\n            - Elemento anidado\n2. Segundo elemento\n            - Elemento anidado\n            - Elemento anidado\n3. Tercer elemento\n            - Elemento anidado\n            - Elemento anidado\n\n\n\n\nPrimer elemento\n\nElemento anidado\nElemento anidado\n\nSegundo elemento\n\nElemento anidado\nElemento anidado\n\nTercer elemento\n\nElemento anidado\nElemento anidado\n\n\n\n\n\n\n\n4.2.14 Notación matemática\nLas expresiones en notación matemática (ej. ecuaciones) se escriben con base en la sintaxis de LaTeX. Se delimitan (al inicio y al final) con:\n\nUn símbolo de dólar ($), para ecuaciones dentro de un renglón (inline math).\nDos símbolos de dólar ($$), para ecuaciones en su propio bloque (display math).\n\n\n\n\nSintaxis Markdown\n\n\nSalida\n\n\n\n\nEquivalencia entre masa y energía: $E = mc^{2}$\n\n\n\nEquivalencia entre masa y energía: \\(E = mc^{2}\\)\n\n\n\n\nEquivalencia entre masa y energía: $$E = mc^{2}$$\n\n\nEquivalencia entre masa y energía:\n\\[E = mc^{2}\\]\n\n\n\nPara más detalles sobre la sintaxis de las expresiones matemáticas, se recomienda consultar:\n\nWriting mathematical expressions - GitHub Docs\nLaTeX/Mathematics\n\n\n\n4.2.15 Bloques de código fuente\nLos documentos Markdown pueden contener bloques de código fuente, ya sea incrustados en una línea de texto (inline) o en líneas separadas.\n\n4.2.15.1 Bloques en línea\nPara mostrar fragmentos cortos de código en una sola línea dentro del texto, se usa una sola comilla invertida o backtick para delimitar el código.\nPor ejemplo, la sintaxis:\nEste es un fragmento de código en línea: `x = 10`\ngenera:\nEste es un fragmento de código en línea: x = 10\n\n\n4.2.15.2 Bloques multilínea\nPara fragmentos de código de múltiples líneas, se utilizan tres comillas invertidas o una sangría de cuatro espacios al inicio de cada línea.\nEl siguiente es un ejemplo de bloque de código delimitado con comillas invertidas (la forma más usada):\n\n```\nfunction sumar(a, b) {\n  return a + b;\n}\n```\n\nSe visualiza como:\nfunction sumar(a, b) {\n  return a + b;\n}\nSi el código es de un lenguaje específico, puede indicarse para resaltar (y colorear) la sintaxis. Por ejemplo, para un bloque de código en R, se escribe r después de las tres comillas invertidas.\nSintaxis de código en R:\n\n```r\n# Gráfico de dispersón del conjunto de datos cars con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n```\n\nVisualización de código en R:\n# Gráfico de dispersón del conjunto de datos cars con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\nEl uso de resaltado de sintaxis con bloques de código lo hace más fácil de leer y comprender. El resultado (colores, fuentes de texto, etc.) de sintaxis depende de la plataforma o editor de Markdown que se utilice. Plataformas como GitHub y algunos editores soportan muchos lenguajes, mientras que otros pueden no reconocer todos.\nPara más información sobre el uso de bloques de código en documentos Markdown, se recomienda consultar:\n\nCreating and highlighting code blocks\nThe languages YAML file\nMarkdown Code Block: Including Code In .md Files - Markdown Land\n\nNótese que los bloques de código en un documento Markdown normal (con extensión .md) no se ejecutan, solo se muestran. Sin embargo, hay sistemas como Quarto y Jupyter Notebooks que permiten combinar narrativa em Markdown con bloques de código ejecutables.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Markdown - lenguaje de marcado</span>"
    ]
  },
  {
    "objectID": "05-quarto.html",
    "href": "05-quarto.html",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#trabajo-previo",
    "href": "05-quarto.html#trabajo-previo",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Lecturas\nQuarto - Tutorial: Hello, Quarto. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/get-started/hello/rstudio.html",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#introducción",
    "href": "05-quarto.html#introducción",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "Introducción",
    "text": "Introducción\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Entre sus principales capacidades están:\n\nCrear contenido dinámico con los lenguajes R, Python, Julia y Observable.\nCrear documentos Markdown de texto plano o cuadernos de notas de Jupyter.\nPublicar artículos académicos, reportes, presentaciones, sitios web, blogs y libros en HTML, PDF, MS Word, ePub y otros formatos.\nCrear contenido científico, incluyendo ecuaciones, citas bibliográficas, referencias cruzadas, figuras y otros elementos.\n\nQuarto es la siguiente generación de R Markdown, un formato que permite insertar código en R, y sus salidas, en documentos escritos en Markdown. R Markdown fue introducido por Yihui Xie en 2012, junto con el paquete knitr, cuyo propósito es facilitar la investigación reproducible en R a través de la programación literaria (literate programming), un paradigma de programación propuesto por Donald Knuth en 1984.\nLos programas “literarios” (o “letrados”) están escritos como una exposición lógica en un lenguaje humano similar a la explicación de las fórmulas y ecuaciones empleadas para representar y resolver un problema en un texto de física o de matemáticas. En estos programas, se describe el análisis del problema, su solución y su implementación, intercalando código fuente entre los párrafos (y otros contenidos como imágenes, tablas, gráficos estadísticos y mapas), de forma similar a como en los textos de matemáticas se intercalan las fórmulas y las ecuaciones. La programación literaria puede mejorar enormemente un programa, ya que permite documentar ampliamente en qué consiste el problema a resolver, cómo se resuelve, cómo y por qué se adoptó cierto diseño, cómo se optimizó y cómo se implementó en un lenguaje de programación.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#anatomía-de-un-documento-quarto",
    "href": "05-quarto.html#anatomía-de-un-documento-quarto",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.1 Anatomía de un documento Quarto",
    "text": "5.1 Anatomía de un documento Quarto\nUn documento Quarto tiene tres tipos de contenido:\n\nMetadatos en YAML.\nNarrativa en Markdown.\nBloques de código fuente.\n\n\n5.1.1 Metadatos en YAML\nTodo documento Quarto inicia con un encabezado en la sintaxis YAML (YAML Ain’t Markup Language), el cual contiene metadatos del documento como el título, el autor, la fecha de creación, el formato de salida y la estructura de la tabla de contenidos, entre muchos otros.\nUn encabezado YAML comienza y termina con tres guiones (---) y contiene un conjunto de campos y valores de la forma:\n---\ncampo01: valor01\ncampo02: valor02\ncampo0n: valor0n\n---\nPor ejemplo, un encabezado YAML típico puede ser el siguiente:\n---\ntitle: Mi primer documento Quarto\nformat:\n  html:\n    toc: true\n    toc_float: true\n---\nLos campos del encabezado que dependen de otros campos se anidan con sangrías de dos espacios.\nLos elementos de metadatos que pueden especificarse en el encabezado, pueden variar de acuerdo al formato de salida, como puede verse en los siguientes enlaces:\n\nElementos de metadatos para HTML\nElementos de metadatos para PDF\nElementos metadatos para MS Word\n\nExisten elementos de metadatos para muchos otros formatos de salida (OpenOffice, ePub, presentaciones, wikis, etc.), como puede apreciarse en la Referencia de Quarto.\n\n\n5.1.2 Narrativa en Markdown\nLa narrativa proporciona estructura y contenido al documento en la forma de encabezados, párrafos, enlaces y otros elementos de la sintaxis de Markdown.\n\n\n5.1.3 Bloques de código fuente\nEn Quarto, los bloques (chunks) de código fuente se delimitan con tres backticks, tanto al inicio como al final del bloque. Los bloques de código en R se identifican con {r} y diferentes opciones identificadas con #|. Los bloques de otros lenguajes de programación se identifican con {python} y {julia}, por ejemplo.\nEl siguiente es un ejemplo de bloque de código en R y su salida:\n```{r}\n#| label: graficacion-cars\n#| include: true\n#| echo: false\n\nplot(\n  x = cars$speed,\n  y = cars$dist,\n  main = \"Velocidad vs distancia de frenado\",\n  xlab = \"Velocidad (MPH)\",\n  ylab = \"Distancia (pies)\"\n)\n```\n\n\n\n\n\n\n\n\n\nLa opción label se utiliza para etiquetar el bloque y la de include para especificar si se desea que el bloque y sus resultados se incluyan en el documento de salida.\nLa documentación de las diferentes opciones disponibles para los bloques de código que utilizan el motor (engine) Knitr (el más utilizado con R) se encuentra en Code Cells: Knitr - Quarto.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#cómo-funciona-quarto",
    "href": "05-quarto.html#cómo-funciona-quarto",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.2 ¿Cómo funciona Quarto?",
    "text": "5.2 ¿Cómo funciona Quarto?\nQuarto se apoya en knitr y en Pandoc. knitr ejecuta el código en R (u otro lenguaje) y convierte los documentos a Markdown. Por su parte, Pandoc exporta los documentos Markdown al formato de salida deseado (ej. HTML, PDF, MS Word, MS PowerPoint). Este proceso se ilustra en la Figura 5.1.\n\n\n\n\n\n\nFigura 5.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#ejercicios",
    "href": "05-quarto.html#ejercicios",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.3 Ejercicios",
    "text": "5.3 Ejercicios\nCon Quarto, cree un sitio web en GitHub Pages que muestre los gráficos que programó en la tarea 1 de este curso.\nSeguidamente, se sugiere una serie de pasos para elaborar el sitio.\n\nCree un nuevo proyecto con la opción File - New Project - New Directory - New Project de RStudio.\nEn el nuevo proyecto, cree un nuevo documento con la opción File - New File - Quarto Document de RStudio. Llene los metadatos (título, autor, etc.). Elija HTML como formato de salida.\nGuarde el documento con el nombre index.qmd (RStudio asigna la extensión automáticamente).\nAl inicio del documento, agregue narrativa en Markdown que explique el contenido, la fuente de los datos y la dirección del repositorio en GitHub con el código fuente (este repositorio se crea en un paso posterior).\nAgregue los gráficos y los comentarios de la tarea 1 mediante bloques de código en R y narrativa en Markdown. Divida el documento en secciones mediante el uso de encabezados. Se recomienda asignar una etiqueta a cada bloque de código con la opción #| label:. Considere el uso de otras etiquetas Quarto para, por ejemplo, controlar el despliegue de las salidas y del código fuente.\nPresione el botón Render de RStudio para generar el archivo index.html. Este será el arhivo que se desplegará en GitHub Pages.\nCree un repositorio vacío en su cuenta en GitHub (ej. graficos-base-r).\nSuba al nuevo repositorio los archivos index.qmd e index.html.\nGenere el sitio en GitHub Pages con la opción Settings - Pages - Branch - main - Save de GitHub.\nRepita los pasos 6, 8 y 9 para cada modificación que realice en el documento Quarto.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-quarto.html#recursos-de-interés",
    "href": "05-quarto.html#recursos-de-interés",
    "title": "5  Quarto - sistema de publicación técnica y científica",
    "section": "5.4 Recursos de interés",
    "text": "5.4 Recursos de interés\nCode Cells: Knitr - Quarto (opciones para bloques de código). (s. f.). Recuperado el 26 de setiembre de 2024, de Code Cells: Knitr - Quarto\n\n\n\nFigura 5.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "05-git.html",
    "href": "05-git.html",
    "title": "5  Git - sistema de control de versiones",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#trabajo-previo",
    "href": "05-git.html#trabajo-previo",
    "title": "5  Git - sistema de control de versiones",
    "section": "",
    "text": "Instalación de software\nInstale en su computadora: Git\n\n\nTutoriales\nAbba, Ihechikara Vincent (2021). Git and GitHub Tutorial – Version Control for Beginners. freeCodeCamp.Org. https://www.freecodecamp.org/news/git-and-github-for-beginners/",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#introducción",
    "href": "05-git.html#introducción",
    "title": "5  Git - sistema de control de versiones",
    "section": "Introducción",
    "text": "Introducción\nGit es un sistema de control de versiones diseñado para “rastrear” cambios en el código fuente durante el proceso de desarrollo de software. Sin embargo, puede ser utilizado para llevar el control de los cambios en cualquier conjunto de archivos (ej. documentación, música).\nUn sistema de control de versiones proporciona, entre otras ventajas:\n\nLa capacidad de recuperar versiones anteriores de los archivos.\nLa capacidad de integrar modificaciones efectuadas por varias personas en el mismo conjunto de archivos.\nLa capacidad de mantener varias “ramas” (branches) de un producto (ej. “estable”, “evaluación”, “inestable”, como en el caso de Debian Linux, GRASS GIS y muchos otros proyectos de software libre).\nFacilidades para mantener redundancia y respaldos de los archivos (ej. Programa de respaldos de GitHub). Esta es una facilidad que implementan algunos servicios en la nube.\n\nGit fue diseñado por Linus Torvalds en 2005 durante del desarrollo del kernel del sistema operativo Linux. Se caracteriza por ser un sistema de control de versiones distribuido, lo que significa que el código fuente puede estar alojado en la estación de trabajo de cualquier miembro del equipo de desarrollo. No requiere un repositorio “central”, pero también puede trabajar de esa forma.\nEl protocolo de Git es utilizado en varios sitios que proveen servicios de alojamiento de software, entre los que están SourceForge, Bitbucket, GitLab y GitHub.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#funcionamiento-de-git",
    "href": "05-git.html#funcionamiento-de-git",
    "title": "5  Git - sistema de control de versiones",
    "section": "5.1 Funcionamiento de Git",
    "text": "5.1 Funcionamiento de Git\nDesde el punto de vista de un usuario de Git (ej. un programador), Git se utiliza para sincronizar la versión local (i.e. en una computadora personal) de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente a través de dos operaciones:\n\npush: para “subir” al repositorio remoto los cambios realizados en el repositorio local. Esta operación se realiza mediante el comando git push. Es probable que el sistema remoto le solicite al usuario algún tipo de autenticación (ej. nombre de usuario y clave).\npull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto. Esta operación se realiza mediante el comando git pull.\n\nLas operaciones push y pull se ilustran en la Figura 5.1.\n\n\n\n\n\n\nFigura 5.1: Operaciones push y pull. Imagen de Melinda Higgins.\n\n\n\nAntes de un push, el usuario debe seleccionar los archivos que desea subir mediante el comando git add, el cual pasa los archivos a un “área de espera” (staging area). Luego debe usarse el comando git commit para “guardar” los cambios pendientes en el área de espera. Cada commit guarda el estado del conjunto de archivos en un momento específico (snapshot).\nLa relación entre estas operaciones de Git, se ilustra en la Figura 5.2.\n\n\n\n\n\n\nFigura 5.2: Operaciones de Git. Imagen de Steven Klavins.\n\n\n\nEn la Figura 5.3, se muestra el funcionamiento de Git mediante una comparación con el procesamiento de una compra en línea.\n\n\n\n\n\n\nFigura 5.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.\n\n\n\nOtras operaciones de Git de uso frecuente son:\n\ngit config: para especificar opciones globales de la sesión de Git (ej. nombre del usuario, dirección de correo electrónico).\ngit init: para inicializar un repositorio git.\ngit clone: para clonar (i.e. copiar) un repositorio remoto en la computadora local.\ngit status: para revisar el estado de los archivos y, por ejemplo, saber cuales deben pasarse al área de espera.\ngit log: para revisar el historial de commits.\ngit show: para visualizar los cambios efectuados en los commits.\ngit reset: para regresar al estado correspondiente a un commit anterior.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "05-git.html#recursos-de-interés",
    "href": "05-git.html#recursos-de-interés",
    "title": "5  Git - sistema de control de versiones",
    "section": "5.2 Recursos de interés",
    "text": "5.2 Recursos de interés\nGit. (s. f.). Recuperado 28 de agosto de 2022, de https://git-scm.com/\nGitHub Archive Program. (s. f.). GitHub Archive Program. Recuperado 10 de abril de 2022, de https://archiveprogram.github.com/\nHiggins, M. (s. f.). Reproducible Templates for Analysis and Dissemination. Coursera. Recuperado 11 de abril de 2022, de https://www.coursera.org/learn/reproducible-templates-analysis\nKlavins, S. (2020). Version Control part 1. Medium. https://stevenklavins94.medium.com/version-control-part-1-c5f1b43127f6\n\n\n\nFigura 5.1: Operaciones push y pull. Imagen de Melinda Higgins.\nFigura 5.2: Operaciones de Git. Imagen de Steven Klavins.\nFigura 5.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Git - sistema de control de versiones</span>"
    ]
  },
  {
    "objectID": "06-quarto.html",
    "href": "06-quarto.html",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#trabajo-previo",
    "href": "06-quarto.html#trabajo-previo",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "",
    "text": "Lecturas\nQuarto - Tutorial: Hello, Quarto. (s.f.). Quarto. Recuperado el 1 de marzo de 2024, de https://quarto.org/docs/get-started/hello/rstudio.html",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#introducción",
    "href": "06-quarto.html#introducción",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "Introducción",
    "text": "Introducción\nQuarto es un sistema de publicación de documentos técnicos y científicos, basado en código abierto. Entre sus principales capacidades están:\n\nCrear contenido dinámico con los lenguajes R, Python, Julia y Observable.\nCrear documentos Markdown de texto plano o cuadernos de notas de Jupyter.\nPublicar artículos académicos, reportes, presentaciones, sitios web, blogs y libros en HTML, PDF, MS Word, ePub y otros formatos.\nCrear contenido científico, incluyendo ecuaciones, citas bibliográficas, referencias cruzadas, figuras y otros elementos.\n\nQuarto es la siguiente generación de R Markdown, un formato que permite insertar código en R, y sus salidas, en documentos escritos en Markdown. R Markdown fue introducido por Yihui Xie en 2012, junto con el paquete knitr, cuyo propósito es facilitar la investigación reproducible en R a través de la programación literaria (literate programming), un paradigma de programación propuesto por Donald Knuth en 1984.\nLos programas “literarios” (o “letrados”) están escritos como una exposición lógica en un lenguaje humano similar a la explicación de las fórmulas y ecuaciones empleadas para representar y resolver un problema en un texto de física o de matemáticas. En estos programas, se describe el análisis del problema, su solución y su implementación, intercalando código fuente entre los párrafos (y otros contenidos como imágenes, tablas, gráficos estadísticos y mapas), de forma similar a como en los textos de matemáticas se intercalan las fórmulas y las ecuaciones. La programación literaria puede mejorar enormemente un programa, ya que permite documentar ampliamente en qué consiste el problema a resolver, cómo se resuelve, cómo y por qué se adoptó cierto diseño, cómo se optimizó y cómo se implementó en un lenguaje de programación.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#anatomía-de-un-documento-quarto",
    "href": "06-quarto.html#anatomía-de-un-documento-quarto",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.1 Anatomía de un documento Quarto",
    "text": "6.1 Anatomía de un documento Quarto\nUn documento Quarto tiene tres tipos de contenido:\n\nMetadatos en YAML.\nNarrativa en Markdown.\nBloques de código fuente.\n\n\n6.1.1 Metadatos en YAML\nTodo documento Quarto inicia con un encabezado en la sintaxis YAML (YAML Ain’t Markup Language), el cual contiene metadatos del documento como el título, el autor, la fecha de creación, el formato de salida y la estructura de la tabla de contenidos, entre muchos otros.\nUn encabezado YAML comienza y termina con tres guiones (---) y contiene un conjunto de campos y valores de la forma:\n---\ncampo01: valor01\ncampo02: valor02\ncampo0n: valor0n\n---\nPor ejemplo, un encabezado YAML típico puede ser el siguiente:\n---\ntitle: Mi primer documento Quarto\nformat:\n  html:\n    toc: true\n    toc_float: true\n---\nLos campos del encabezado que dependen de otros campos se anidan con sangrías de dos espacios.\nLos elementos de metadatos que pueden especificarse en el encabezado, pueden variar de acuerdo al formato de salida, como puede verse en los siguientes enlaces:\n\nElementos de metadatos para HTML\nElementos de metadatos para PDF\nElementos metadatos para MS Word\n\nExisten elementos de metadatos para muchos otros formatos de salida (OpenOffice, ePub, presentaciones, wikis, etc.), como puede apreciarse en la Referencia de Quarto.\n\n\n6.1.2 Narrativa en Markdown\nLa narrativa proporciona estructura y contenido al documento en la forma de encabezados, párrafos, enlaces y otros elementos de la sintaxis de Markdown.\n\n\n6.1.3 Bloques de código fuente\nEn Quarto, los bloques (chunks) de código fuente se delimitan con tres backticks, tanto al inicio como al final del bloque. Los bloques de código en R se identifican con {r} y diferentes opciones identificadas con #|. Los bloques de otros lenguajes de programación se identifican con {python} y {julia}, por ejemplo.\nEl siguiente es un ejemplo de bloque de código en R y su salida:\n```{r}\n#| label: graficacion-cars\n#| include: true\n#| echo: false\n\nplot(\n  x = cars$speed,\n  y = cars$dist,\n  main = \"Velocidad vs distancia de frenado\",\n  xlab = \"Velocidad (MPH)\",\n  ylab = \"Distancia (pies)\"\n)\n```\n\n\n\n\n\n\n\n\n\nLa opción label se utiliza para etiquetar el bloque y la de include para especificar si se desea que el bloque y sus resultados se incluyan en el documento de salida.\nLa documentación de las diferentes opciones disponibles para los bloques de código que utilizan el motor (engine) Knitr (el más utilizado con R) se encuentra en Code Cells: Knitr - Quarto.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#cómo-funciona-quarto",
    "href": "06-quarto.html#cómo-funciona-quarto",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.2 ¿Cómo funciona Quarto?",
    "text": "6.2 ¿Cómo funciona Quarto?\nQuarto se apoya en knitr y en Pandoc. knitr ejecuta el código en R (u otro lenguaje) y convierte los documentos a Markdown. Por su parte, Pandoc exporta los documentos Markdown al formato de salida deseado (ej. HTML, PDF, MS Word, MS PowerPoint). Este proceso se ilustra en la Figura 6.1.\n\n\n\n\n\n\nFigura 6.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#ejercicios",
    "href": "06-quarto.html#ejercicios",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.3 Ejercicios",
    "text": "6.3 Ejercicios\nCon Quarto, cree un sitio web en GitHub Pages que muestre los gráficos que programó en la tarea 1 de este curso.\nSeguidamente, se sugiere una serie de pasos para elaborar el sitio.\n\nCree un nuevo proyecto con la opción File - New Project - New Directory - New Project de RStudio.\nEn el nuevo proyecto, cree un nuevo documento con la opción File - New File - Quarto Document de RStudio. Llene los metadatos (título, autor, etc.). Elija HTML como formato de salida.\nGuarde el documento con el nombre index.qmd (RStudio asigna la extensión automáticamente).\nAl inicio del documento, agregue narrativa en Markdown que explique el contenido, la fuente de los datos y la dirección del repositorio en GitHub con el código fuente (este repositorio se crea en un paso posterior).\nAgregue los gráficos y los comentarios de la tarea 1 mediante bloques de código en R y narrativa en Markdown. Divida el documento en secciones mediante el uso de encabezados. Se recomienda asignar una etiqueta a cada bloque de código con la opción #| label:. Considere el uso de otras etiquetas Quarto para, por ejemplo, controlar el despliegue de las salidas y del código fuente.\nPresione el botón Render de RStudio para generar el archivo index.html. Este será el arhivo que se desplegará en GitHub Pages.\nCree un repositorio vacío en su cuenta en GitHub (ej. graficos-base-r).\nSuba al nuevo repositorio los archivos index.qmd e index.html.\nGenere el sitio en GitHub Pages con la opción Settings - Pages - Branch - main - Save de GitHub.\nRepita los pasos 6, 8 y 9 para cada modificación que realice en el documento Quarto.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "06-quarto.html#recursos-de-interés",
    "href": "06-quarto.html#recursos-de-interés",
    "title": "6  Quarto - sistema de publicación técnica y científica",
    "section": "6.4 Recursos de interés",
    "text": "6.4 Recursos de interés\nCode Cells: Knitr - Quarto (opciones para bloques de código). (s. f.). Recuperado el 26 de setiembre de 2024, de Code Cells: Knitr - Quarto\n\n\n\nFigura 6.1: Conversión de un documento Quarto (.qmd) a su formato de salida. Imagen de quarto.org.",
    "crumbs": [
      "III - Herramientas para investigación reproducible y desarrollo colaborativo",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Quarto - sistema de publicación técnica y científica</span>"
    ]
  },
  {
    "objectID": "parte-iv-graficacion-estadistica-r.html",
    "href": "parte-iv-graficacion-estadistica-r.html",
    "title": "IV - Graficación estadística en R",
    "section": "",
    "text": "7 Tidyverse - colección de paquetes para ciencia de datos\n8 dplyr - gramática para manipulación de datos\n9 ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "crumbs": [
      "IV - Graficación estadística en R"
    ]
  },
  {
    "objectID": "07-tidyverse.html",
    "href": "07-tidyverse.html",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#resumen",
    "href": "07-tidyverse.html#resumen",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "",
    "text": "Cada variable debe tener su propia columna.\nCada observación debe tener su propia fila.\nCada valor debe tener su propia celda.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#trabajo-previo",
    "href": "07-tidyverse.html#trabajo-previo",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "",
    "text": "Lecturas\nWickham, H. (2014). Tidy Data. Journal of Statistical Software, 59(1), 1-23. https://doi.org/10.18637/jss.v059.i10\nWickham, Hadley; Çetinkaya-Rundel, Mirne; & Grolemund, Garret (2023). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/ (capítulos 1 -8, 25 - 27)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#introducción",
    "href": "07-tidyverse.html#introducción",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "Introducción",
    "text": "Introducción\nTidyverse es una colección de paquetes de R enfocados en ciencia de datos, una discipina que permite convertir datos no procesados en entendimiento, comprensión y conocimiento.\nLa Figura 7.1 ilustra el modelo de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\n\nFigura 7.1: Modelo de ciencia de datos. Fuente: R for Data Science.\n\n\n\n\nImportar los datos típicamente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en un data frame.\nOrdenar u organizar (to tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable.\nTransformar los datos implica la generación de algún subconjunto de filas y columnas, la creación de nuevas variables o el cálculo de estadísticas (ej. conteos, promedios, mínimos, máximos).\nVisualizar los datos (en tablas, gráficos, mapas, etc.) permite encontrar patrones inesperados o formular nuevas preguntas.\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones.\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general.\n\nLos paquetes de Tidyverse comparten filosofía de diseño, gramática y estructuras de datos para apoyar estos procesos del modelo de ciencia de datos. El concepto de Tidyverse fue introducido por Hadley Wickham, quien también ha programado varios de sus paquetes.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#paquetes",
    "href": "07-tidyverse.html#paquetes",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.1 Paquetes",
    "text": "7.1 Paquetes\nEl núcleo de Tidyverse está compuesto por ocho paquetes base, los cuales proveen las funcionalidades utilizadas más frecuentemente en análisis de datos:\n\ndplyr: gramática que proporciona un conjunto consistente de “verbos” que resuelven los retos más comunes de transformación de datos.\nggplot2: sistema para la creación declarativa de gráficos, basado en el libro The Grammar of Graphics, de Wilkinson et al..\ntidyr: conjunto de funciones para organizar (to tidy) datos, colocando las observaciones, variables y valores en filas, columnas y celdas de estructuras rectangulares.\nreadr: conjunto de funciones para cargar datos de estructuras rectangulares (ej. archivos CSV) en memoria.\npurr: conjunto de herramientas de programación funcional para trabajar con funciones y vectores.\ntibble: un tibble es una redefinición del concepto de data frame, para hacerlos más eficientes y fáciles de usar.\nstringr: colección de funciones para facilitar el trabajo con hileras de caracteres.\nforcats: colección de funciones para facilitar el trabajo con factores.\n\nHay otros paquetes para tareas más especifícas relacionadas con importación, limpieza y modelado de datos, entre otras. Los paquetes de Tidyverse son de los más descargados, entre la totalidad de paquetes del lenguaje de programación R.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#instalación-y-carga",
    "href": "07-tidyverse.html#instalación-y-carga",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.2 Instalación y carga",
    "text": "7.2 Instalación y carga\nLos paquetes de Tidyverse pueden instalarse con la función install.packages(), ya sea de manera conjunta (todos los paquetes básicos) o individualmente:\n\n# Instalación conjunta (toma más tiempo)\ninstall.packages(\"tidyverse\")\n\n# Instalación de paquetes individuales\ninstall.packages(\"ggplot2\")\ninstall.packages(\"dplyr\")\n\nUna vez instalados, los paquetes también pueden cargarse conjunta o separadamente con la función library():\n\n# Carga conjunta\nlibrary(tidyverse)\n\n# Carga de paquetes individuales\nlibrary(ggplot2)\nlibrary(dplyr)\n\nTambién es posible utilizar la notación paquete::funcion() para llamar una función sin necesidad de cargar todo el paquete (siempre y cuando este haya sido instalado):\n\n# Llamado a la función glimpse() del paquete dplyr\ndplyr::glimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "href": "07-tidyverse.html#el-conjunto-de-datos-palmerpenguins",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.3 El conjunto de datos palmerpenguins",
    "text": "7.3 El conjunto de datos palmerpenguins\npalmerpenguins es un paquete de datos de R ampliamente utilizado para ejemplificar funciones de exploración y visualización, como las de Tidyverse. Es muy popular en ciencia de datos en general y también está disponible para otros lenguajes de programación (ej. Python, Julia). Se utiliza como una alternativa a otros conjuntos de datos usualmente usados para ejemplos como, por ejemplo, iris.\nLos datos de palmerpenguins fueron recolectados entre 2007 y 2009 por la Dr. Kristen Gorman y el Programa de Investigación Ecológica de Largo Plazo (LTER) de la Estación Palmer. Consisten de 344 observaciones de pingüinos de tres especies, las cuales habitan en tres islas del archipiélago Palmer, en la Antártida. Para cada individuo se registraron variables como especie, sexo, masa (peso), longitud de la aleta (flipper), longitud del pico (bill) y profundidad del pico, entre otras.\nEn R, el paquete puede instalarse con la función install.packages():\n\n# Instalación de palmerpenguins\ninstall.packages(\"palmerpenguins\")\n\nUna vez instalado, el paquete puede cargarse con la función library():\n\n# Carga de palmerpenguins\nlibrary(palmerpenguins)\n\nEl paquete contiene dos conjuntos de datos:\n\npenguins_raw: datos sin procesar.\npenguins: subconjunto curado de los datos sin procesar.\n\npalmerpinguins se utilizará en este capítulo, y en los siguientes, para ejemplificar varias de las funcionalidades de Tidyverse.\n\n7.3.1 Ejemplos de visualizaciones\nSeguidamente se muestran varios tipos de gráficos estadísticos generados con la función ggplot() del paquete ggplot2.\n\n7.3.1.1 Gráficos de dispersión\nEste tipo de gráficos muestra relaciones entre variables numéricas.\n\n# Gráfico de dispersión de longitud del pico vs masa (peso)\npenguins |&gt;\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  ggtitle(\"Longitud del pico vs. masa\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n\n\n\n\n# Gráfico de dispersión de longitud del pico vs masa (peso) por especie\npenguins |&gt;\n  ggplot(aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species,\n                 shape = species),\n             size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE, aes(color = species)) +\n  scale_color_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Longitud del pico vs. masa por especie\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n\n\n\n\n\n\n\n\n\n\n7.3.1.2 Histogramas\nEste tipo de gráficos muestra distribuciones de variables numéricas.\n\n# Distribución de la variable de masa (peso)\npenguins |&gt;\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram() +\n  ggtitle(\"Distribución de la variable masa (peso)\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\")\n\n\n\n\n\n\n\n\n\n# Distribución de la variable de masa (peso) por especie\npenguins |&gt;\n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram(aes(fill = species), alpha = 0.5, position = \"identity\") +\n  scale_fill_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Distribución de la variable masa (peso) por especie\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\") +\n  labs(fill = \"Especie\")\n\n\n\n\n\n\n\n\n\n\n7.3.1.3 Diagramas de caja\nEste tipo de gráficos muestra datos a través de sus cuartiles.\n\n# Diagrama de caja de la variable masa (peso)\npenguins |&gt;\n  ggplot(aes(y = body_mass_g)) +\n  geom_boxplot() +\n  ylab(\"Masa (g)\")\n\n\n\n\n\n\n\n\n\n# Diagrama de caja de la variable masa (peso) por especie\npenguins |&gt;\n  ggplot(aes(x = species, y = body_mass_g)) +\n  geom_boxplot(aes(color = species), width = 0.3, show.legend = FALSE) +\n  scale_color_manual(values = c(\"darkorange\", \"purple\", \"cyan4\")) +\n  xlab(\"Especie\") +\n  ylab(\"Masa (g)\")",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#datos-tidy",
    "href": "07-tidyverse.html#datos-tidy",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.4 Datos tidy",
    "text": "7.4 Datos tidy\nLos paquetes de Tidyverse trabajan con datos tidy (i.e. ordenados, organizados), un concepto también introducido por Hadley Wickham y que está relacionado con la organización de los datos en estructuras rectangulares de filas y columnas, similares a las tablas o matrices.\nSegún Wickham, los datos tidy deben cumplir con tres características:\n\nCada variable debe tener su propia columna.\nCada observación debe tener su propia fila.\nCada valor debe tener su propia celda.\n\nEstas características se ilustran en la Figura 7.2.\n\n\n\n\n\n\nFigura 7.2: Datos tidy. Fuente: R for Data Science.\n\n\n\nEl empleo de este modelo de datos es común en todos los paquetes de Tidyverse, lo que posibilita aprender y usar sus funciones con mayor facilidad. Además, permite invertir menos esfuerzo en lidiar con diferentes modelos de datos y así dedicar más tiempo y esfuerzo en los problemas de análisis a resolver.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#pipes",
    "href": "07-tidyverse.html#pipes",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.5 Pipes",
    "text": "7.5 Pipes\nLas funciones de Tidyverse pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%&gt;%) o el del paquete base de R (|&gt;). Los procesos se enlazan con pipes para formar pipelines (tuberías). En este contexto, un pipeline consiste de una cadena de procesos conectados de forma tal que la salida de cada proceso de la cadena es la entrada del próximo. Esto permite la comunicación y sincronización entre los procesos y evita la anidación (nesting) de llamados a funciones.\nEl siguiente ejemplo implementa un pipeline de dos funciones de Tidyverse:\n\n# Cadena de \"pipes\" entre funciones de Tidyverse\npenguins |&gt;\n  dplyr::filter(species == \"Gentoo\") |&gt; # subconjunto de observaciones\n  select(species, bill_length_mm, flipper_length_mm) # subconjunto de columnas\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   &lt;fct&gt;            &lt;dbl&gt;             &lt;int&gt;\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# ℹ 114 more rows\n\n\nUna alternativa a los pipes es la anidación de llamados a funciones:\n\n# Llamados anidados a funciones\nselect(filter(penguins, species == \"Gentoo\"),\n       species,\n       bill_length_mm,\n       flipper_length_mm)\n\n# A tibble: 124 × 3\n   species bill_length_mm flipper_length_mm\n   &lt;fct&gt;            &lt;dbl&gt;             &lt;int&gt;\n 1 Gentoo            46.1               211\n 2 Gentoo            50                 230\n 3 Gentoo            48.7               210\n 4 Gentoo            50                 218\n 5 Gentoo            47.6               215\n 6 Gentoo            46.5               210\n 7 Gentoo            45.4               211\n 8 Gentoo            46.7               219\n 9 Gentoo            43.3               209\n10 Gentoo            46.8               215\n# ℹ 114 more rows\n\n\nEl uso de pipes permite un funcionamiento homogéneo de las funciones de Tidyverse:\n\nEl primer argumento es un data frame. Puede omitirse si la función recibe el data frame a través del operador pipe.\nLos argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).\n\nEl resultado es un nuevo data frame.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "07-tidyverse.html#recursos-de-interés",
    "href": "07-tidyverse.html#recursos-de-interés",
    "title": "7  Tidyverse - colección de paquetes para ciencia de datos",
    "section": "7.6 Recursos de interés",
    "text": "7.6 Recursos de interés\nCanelón, S. (s.f.). Slides | Silvia Canelón—An Antarctic Tour of the Tidyverse. Recuperado 16 de octubre de 2022, de https://slides.silviacanelon.com/tour-of-the-tidyverse-v2/#/title-slide\n\n\n\nFigura 7.1: Modelo de ciencia de datos. Fuente: R for Data Science.\nFigura 7.2: Datos tidy. Fuente: R for Data Science.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Tidyverse - colección de paquetes para ciencia de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html",
    "href": "08-dplyr.html",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#trabajo-previo",
    "href": "08-dplyr.html#trabajo-previo",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "",
    "text": "Lecturas\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (s. f.). R for Data Science (2nd ed.) Chapter 4 - Data transformation. Recuperado 5 de mayo de 2024, de https://r4ds.hadley.nz/data-transform.html",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#introducción",
    "href": "08-dplyr.html#introducción",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "Introducción",
    "text": "Introducción\nEl paquete dplyr de Tidyverse es descrito como una gramática para la manipulación de datos, la cual proporciona un conjunto consistente de “verbos” que ayuda a solucionar los retos de procesamiento de datos más comunes. Los principales verbos (i.e. funciones) de esta gramática son:\nselect(): selecciona columnas con base en sus nombres.\nfilter(): selecciona filas con base en sus valores.\narrange(): cambia el orden de las filas.\nmutate(): crea nuevas columnas, las cuales se expresan como funciones de columnas existentes.\nsummarize(): agrupa y resume valores.\nTodas estas operaciones pueden combinarse con la función group_by(), la cual ejecuta cualquiera de las operaciones anteriores “en grupo”. Además, dplyr proporciona funciones adicionales para tareas más específicas.\nLas funciones de dplyr pueden encadenarse a través del operador pipe (tubo), ya sea el del paquete magrittr (%&gt;%) o el del paquete base de R (|&gt;). En el material de este curso, se prefiere la segunda opción. Los pipes se utilizan para comunicar procesos y así formar pipelines (tuberías).\nTodas las funciones de dplyr trabajan de manera similar:\n\nEl primer argumento siempre es un data frame. Puede omitirse si la función recibe el data frame a través del operador pipe.\nLos argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).\n\nEl resultado siempre es un nuevo data frame.\n\nYa que cada función de dplyr se especializa en una sola tarea, usualmente es necesario encadenar funciones mediante pipes para lograr un objetivo de procesamiento de datos. Por ejemplo, el siguiente bloque de código usa tres verbos, o funciones, de dplyr para obtener la masa promedio de cada especie de pingüinos que habita en la isla Biscoe.\n\n# Cálculo de la masa promedio para cada especie de pingüinos\n# que habita en la isla Biscoe\npenguins |&gt;\n  filter(island == \"Biscoe\") |&gt; \n  group_by(species) |&gt; \n  summarize(\n    body_mass_g_mean = mean(body_mass_g, na.rm = TRUE)\n  )\n\nA tibble: 2 × 2\nspecies body_mass_g_mean\n&lt;fct&gt;              &lt;dbl&gt;\nAdelie          3710.659\nGentoo          5076.016",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#instalación-y-carga",
    "href": "08-dplyr.html#instalación-y-carga",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.1 Instalación y carga",
    "text": "8.1 Instalación y carga\nEl paquete dplyr puede instalarse junto con todos los demás paquete de Tidyverse o de manera individual:\n\n# Instalación conjunta de Tidyverse\ninstall.packages(\"tidyverse\")\n\n# Instalación individual\ninstall.packages(\"dplyr\")\n\nUna vez instalado, dplyr puede cargarse con la función library():\n\n# Carga conjunta de Tidyverse\nlibrary(tidyverse)\n\n# Carga individual\nlibrary(dplyr)\n\nSeguidamente, se cargan algunos paquetes adicionales que se utilizan en este capítulo.\n\n# Carga de readr, paquete para lectura de datos\nlibrary(readr)\n\n# Carga de tidyr, paquete para creación de datos \"tidy\"\nlibrary(tidyr)\n\n# Carga de knitr, paquete para integrar salidas en R en documentos dinámicos\n# (ej. Quarto). En este capítulo se usa para generar tablas.\nlibrary(knitr)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#conjuntos-de-datos-para-ejemplos",
    "href": "08-dplyr.html#conjuntos-de-datos-para-ejemplos",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.2 Conjuntos de datos para ejemplos",
    "text": "8.2 Conjuntos de datos para ejemplos\nEn los ejemplos de este capítulo, se utilizan dos conjunto de datos:\n\nPingüinos del archipiélago Palmer de palmerpenguins.\nPaíses (Admin 0 – Details) de Natural Earth.\nEsperanza de vida al nacer) de Banco Mundial - Indicadores.\n\n\n8.2.1 Pingüinos del archipiélago Palmer\nPara cargar el conjunto de datos penguins, basta con cargar el paquete palmerpenguins.\n\n# Carga del paquete de datos palmerpenguins\nlibrary(palmerpenguins)\n\nLa función glimpse() despliega la estructura de un conjunto de datos, incluyendo los nombres de las columnas, sus tipos de datos y una muestra de estos:\n\n# Estructura del conjunto de datos penguins\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nLa función también puede llamarse mediante un pipe:\n\n# Estructura del conjunto de datos penguins\npenguins |&gt;\n  glimpse()\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nUn conjunto de datos puede visualizarse al escribir su nombre en la consola de R o en un programa:\n\n# Despliegue de los datos de penguins\npenguins\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\npenguins es un tibble, un tipo especial de data frame que se utiliza en Tidyverse. La diferencia más importante entre un tibble y un data frame es la manera en la que se imprimen: los tibbles están diseñados para conjuntos de datos grandes, por lo que solo muestran los primeros registros y las columnas que caben en la pantalla. Un data frame regular muestra todas sus columnas y muchos más registros, lo que dificulta su visualización. Note la diferencia, por ejemplo, con la forma en la que se despliega el conjunto de datos iris (observe también la diferencia entre las salidas de class(iris) y class(penguins)). A pesar de estas diferencias en el despliegue, en general, un data frame regular y un tibble pueden tratarse indistintamente.\nPara generar una salida más estilizada, puede usarse la función knitr::kable(), la cual genera tablas para documentos web. En el siguiente ejemplo, se obtienen los primeros registros de penguins con la función head() y se despliegan en una tabla mediante kable().\n\n# Despliegue de los primeros registros de penguins en una tabla kable\npenguins |&gt;\n  head(n = 10) |&gt;\n  kable(format = \"html\")\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\n\n\nAdelie\nTorgersen\n38.9\n17.8\n181\n3625\nfemale\n2007\n\n\nAdelie\nTorgersen\n39.2\n19.6\n195\n4675\nmale\n2007\n\n\nAdelie\nTorgersen\n34.1\n18.1\n193\n3475\nNA\n2007\n\n\nAdelie\nTorgersen\n42.0\n20.2\n190\n4250\nNA\n2007\n\n\n\n\n\n\n\n\n\n8.2.2 Países\nSe utiliza la función readr::read_csv() para leer un archivo CSV almacenado en el repositorio GitHub de este curso, con los datos de las estadísticas policiales proporcionados por el OIJ en formato Excel. readr::read_csv() es más eficiente que read.csv() (del paquete base de R) y tiene otras ventajas como detección automática de tipos de datos y mejor integración con otros paquetes de Tidyverse (ej. dplyr, tidyr, ggplot2).\n\n# Carga de los datos de países\npaises &lt;-\n  read_csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2024-ii/refs/heads/main/datos/natural-earth/paises.csv\"\n  )\n\nEstructura del conjunto de datos:\n\n# Estructura de los datos de países\nglimpse(paises)\n\nRows: 201\nColumns: 10\n$ ADM0_ISO   &lt;chr&gt; \"IDN\", \"MYS\", \"CHL\", \"BOL\", \"PER\", \"ARG\", \"GBR\", \"CYP\", \"IN…\n$ NAME       &lt;chr&gt; \"Indonesia\", \"Malaysia\", \"Chile\", \"Bolivia\", \"Peru\", \"Argen…\n$ CONTINENT  &lt;chr&gt; \"Asia\", \"Asia\", \"South America\", \"South America\", \"South Am…\n$ REGION_UN  &lt;chr&gt; \"Asia\", \"Asia\", \"Americas\", \"Americas\", \"Americas\", \"Americ…\n$ SUBREGION  &lt;chr&gt; \"South-Eastern Asia\", \"South-Eastern Asia\", \"South America\"…\n$ REGION_WB  &lt;chr&gt; \"East Asia & Pacific\", \"East Asia & Pacific\", \"Latin Americ…\n$ ECONOMY    &lt;chr&gt; \"4. Emerging region: MIKT\", \"6. Developing region\", \"5. Eme…\n$ INCOME_GRP &lt;chr&gt; \"4. Lower middle income\", \"3. Upper middle income\", \"3. Upp…\n$ POP_EST    &lt;dbl&gt; 270625568, 31949777, 18952038, 11513100, 32510453, 44938712…\n$ GDP_MD     &lt;dbl&gt; 1119190, 364681, 282318, 40895, 226848, 445445, 2863166, 24…\n\n\nDespliegue de los datos (debido a que paises es un data frame, pero no un tibble, se limitan manualmente las filas y columnas que se muestran):\n\n# Despliegue de los primeros registros de paises en una tabla kable\npaises |&gt;\n  head(n = 10) |&gt;\n  kable(format = \"html\")\n\n\n\n\nADM0_ISO\nNAME\nCONTINENT\nREGION_UN\nSUBREGION\nREGION_WB\nECONOMY\nINCOME_GRP\nPOP_EST\nGDP_MD\n\n\n\n\nIDN\nIndonesia\nAsia\nAsia\nSouth-Eastern Asia\nEast Asia & Pacific\n4. Emerging region: MIKT\n4. Lower middle income\n270625568\n1119190\n\n\nMYS\nMalaysia\nAsia\nAsia\nSouth-Eastern Asia\nEast Asia & Pacific\n6. Developing region\n3. Upper middle income\n31949777\n364681\n\n\nCHL\nChile\nSouth America\nAmericas\nSouth America\nLatin America & Caribbean\n5. Emerging region: G20\n3. Upper middle income\n18952038\n282318\n\n\nBOL\nBolivia\nSouth America\nAmericas\nSouth America\nLatin America & Caribbean\n5. Emerging region: G20\n4. Lower middle income\n11513100\n40895\n\n\nPER\nPeru\nSouth America\nAmericas\nSouth America\nLatin America & Caribbean\n5. Emerging region: G20\n3. Upper middle income\n32510453\n226848\n\n\nARG\nArgentina\nSouth America\nAmericas\nSouth America\nLatin America & Caribbean\n5. Emerging region: G20\n3. Upper middle income\n44938712\n445445\n\n\nGBR\nUnited Kingdom\nEurope\nEurope\nNorthern Europe\nEurope & Central Asia\n1. Developed region: G7\n1. High income: OECD\n67366465\n2863166\n\n\nCYP\nCyprus\nAsia\nAsia\nWestern Asia\nEurope & Central Asia\n6. Developing region\n2. High income: nonOECD\n1198575\n24948\n\n\nIND\nIndia\nAsia\nAsia\nSouthern Asia\nSouth Asia\n3. Emerging region: BRIC\n4. Lower middle income\n1366417754\n2868929\n\n\nCHN\nChina\nAsia\nAsia\nEastern Asia\nEast Asia & Pacific\n3. Emerging region: BRIC\n3. Upper middle income\n1405862845\n14762473\n\n\n\n\n\n\n\n\n\n8.2.3 Esperanza de vida al nacer\n\n# Carga de los datos de esperanza de vida en países\nesperanza_vida &lt;-\n  read_csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2024-ii/refs/heads/main/datos/world-bank/paises-esperanza-vida.csv\"\n  )\n\nEstructura del conjunto de datos:\n\n# Estructura de los datos de esperanza de vida\nglimpse(esperanza_vida)\n\nRows: 266\nColumns: 69\n$ `Country Name`   &lt;chr&gt; \"Aruba\", \"Africa Eastern and Southern\", \"Afghanistan\"…\n$ `Country Code`   &lt;chr&gt; \"ABW\", \"AFE\", \"AFG\", \"AFW\", \"AGO\", \"ALB\", \"AND\", \"ARB…\n$ `Indicator Name` &lt;chr&gt; \"Life expectancy at birth, total (years)\", \"Life expe…\n$ `Indicator Code` &lt;chr&gt; \"SP.DYN.LE00.IN\", \"SP.DYN.LE00.IN\", \"SP.DYN.LE00.IN\",…\n$ `1960`           &lt;dbl&gt; 64.15200, 44.08555, 32.53500, 37.84515, 38.21100, 54.…\n$ `1961`           &lt;dbl&gt; 64.53700, 44.38670, 33.06800, 38.16495, 37.26700, 55.…\n$ `1962`           &lt;dbl&gt; 64.75200, 44.75218, 33.54700, 38.73510, 37.53900, 56.…\n$ `1963`           &lt;dbl&gt; 65.13200, 44.91316, 34.01600, 39.06372, 37.82400, 57.…\n$ `1964`           &lt;dbl&gt; 65.29400, 45.47904, 34.49400, 39.33536, 38.13100, 58.…\n$ `1965`           &lt;dbl&gt; 65.50200, 45.49834, 34.95300, 39.61804, 38.49500, 60.…\n$ `1966`           &lt;dbl&gt; 66.06300, 45.24910, 35.45300, 39.83783, 38.75700, 60.…\n$ `1967`           &lt;dbl&gt; 66.43900, 45.92491, 35.92400, 39.47150, 39.09200, 61.…\n$ `1968`           &lt;dbl&gt; 66.75700, 46.22310, 36.41800, 40.08568, 39.48400, 62.…\n$ `1969`           &lt;dbl&gt; 67.16800, 46.43230, 36.91000, 40.35042, 39.82900, 63.…\n$ `1970`           &lt;dbl&gt; 67.58300, 46.71848, 37.41800, 41.03476, 40.19000, 64.…\n$ `1971`           &lt;dbl&gt; 67.97500, 47.19294, 37.92300, 41.55672, 40.55400, 65.…\n$ `1972`           &lt;dbl&gt; 68.57700, 46.89739, 38.44400, 42.24979, 40.90500, 66.…\n$ `1973`           &lt;dbl&gt; 69.09200, 47.69232, 39.00300, 42.85505, 41.27000, 67.…\n$ `1974`           &lt;dbl&gt; 69.50300, 47.59806, 39.55000, 43.49768, 41.65200, 67.…\n$ `1975`           &lt;dbl&gt; 69.76200, 47.75989, 40.10000, 44.20125, 41.19100, 68.…\n$ `1976`           &lt;dbl&gt; 70.03500, 48.34959, 40.64500, 45.00316, 41.16300, 68.…\n$ `1977`           &lt;dbl&gt; 70.26400, 48.63591, 41.22800, 45.71989, 41.43700, 69.…\n$ `1978`           &lt;dbl&gt; 70.49400, 48.76360, 40.27100, 46.26954, 41.83000, 69.…\n$ `1979`           &lt;dbl&gt; 70.77800, 49.26134, 39.08600, 46.67374, 42.17500, 69.…\n$ `1980`           &lt;dbl&gt; 71.06600, 49.63654, 39.61800, 47.01524, 42.44900, 70.…\n$ `1981`           &lt;dbl&gt; 71.72200, 50.05707, 40.16400, 47.29719, 42.77200, 70.…\n$ `1982`           &lt;dbl&gt; 71.95900, 50.29685, 37.76600, 47.52938, 43.05100, 71.…\n$ `1983`           &lt;dbl&gt; 72.10500, 48.70333, 38.18700, 47.78526, 42.09200, 71.…\n$ `1984`           &lt;dbl&gt; 72.25100, 48.65266, 33.32900, 47.93192, 42.35300, 71.…\n$ `1985`           &lt;dbl&gt; 72.38800, 49.01163, 33.55000, 48.02168, 42.64800, 71.…\n$ `1986`           &lt;dbl&gt; 72.46200, 49.63972, 39.39600, 48.06676, 42.84300, 71.…\n$ `1987`           &lt;dbl&gt; 72.78900, 50.07589, 39.84400, 48.23785, 40.91700, 72.…\n$ `1988`           &lt;dbl&gt; 73.04700, 49.35973, 43.95800, 48.51291, 41.54500, 72.…\n$ `1989`           &lt;dbl&gt; 73.02300, 50.68410, 45.15800, 48.68985, 41.76500, 72.…\n$ `1990`           &lt;dbl&gt; 73.07600, 50.60773, 45.96700, 48.65000, 41.89300, 73.…\n$ `1991`           &lt;dbl&gt; 73.10000, 50.39046, 46.66300, 48.66246, 43.81300, 73.…\n$ `1992`           &lt;dbl&gt; 73.17900, 49.96211, 47.59600, 48.73727, 42.20900, 73.…\n$ `1993`           &lt;dbl&gt; 73.22500, 50.27363, 51.46600, 48.83204, 42.10100, 73.…\n$ `1994`           &lt;dbl&gt; 73.27200, 50.88258, 51.49500, 48.68189, 43.42200, 74.…\n$ `1995`           &lt;dbl&gt; 73.34900, 51.00193, 52.54400, 48.78377, 45.84900, 74.…\n$ `1996`           &lt;dbl&gt; 73.44800, 50.81069, 53.24300, 48.90628, 46.03300, 74.…\n$ `1997`           &lt;dbl&gt; 73.45200, 50.97423, 53.63400, 49.07918, 46.30600, 73.…\n$ `1998`           &lt;dbl&gt; 73.49100, 50.32591, 52.94300, 49.33295, 45.05700, 74.…\n$ `1999`           &lt;dbl&gt; 73.56100, 51.23785, 54.84600, 49.75012, 45.38600, 75.…\n$ `2000`           &lt;dbl&gt; 73.56900, 51.96448, 55.29800, 50.22195, 46.02400, 75.…\n$ `2001`           &lt;dbl&gt; 73.64700, 52.18965, 55.79800, 50.56514, 46.59000, 75.…\n$ `2002`           &lt;dbl&gt; 73.72600, 52.54079, 56.45400, 50.92785, 47.38600, 75.…\n$ `2003`           &lt;dbl&gt; 73.75200, 53.02203, 57.34400, 51.40336, 49.61700, 76.…\n$ `2004`           &lt;dbl&gt; 73.57600, 53.54546, 57.94400, 51.81913, 50.59200, 76.…\n$ `2005`           &lt;dbl&gt; 73.81100, 54.21965, 58.36100, 52.34455, 51.57000, 76.…\n$ `2006`           &lt;dbl&gt; 74.02600, 55.15055, 58.68400, 52.83213, 52.36900, 76.…\n$ `2007`           &lt;dbl&gt; 74.21000, 55.93380, 59.11100, 53.25171, 53.64200, 77.…\n$ `2008`           &lt;dbl&gt; 74.14700, 56.68042, 59.85200, 53.64116, 54.63300, 77.…\n$ `2009`           &lt;dbl&gt; 74.56000, 57.62085, 60.36400, 54.15942, 55.75200, 77.…\n$ `2010`           &lt;dbl&gt; 75.40400, 58.41115, 60.85100, 54.55017, 56.72600, 77.…\n$ `2011`           &lt;dbl&gt; 75.46500, 59.29327, 61.41900, 55.01314, 57.59600, 78.…\n$ `2012`           &lt;dbl&gt; 75.53100, 60.05078, 61.92300, 55.34056, 58.62300, 78.…\n$ `2013`           &lt;dbl&gt; 75.63600, 60.70987, 62.41700, 55.67341, 59.30700, 78.…\n$ `2014`           &lt;dbl&gt; 75.60100, 61.33792, 62.54500, 55.92223, 60.04000, 78.…\n$ `2015`           &lt;dbl&gt; 75.68300, 61.85646, 62.65900, 56.19587, 60.65500, 78.…\n$ `2016`           &lt;dbl&gt; 75.61700, 62.44405, 63.13600, 56.58168, 61.09200, 78.…\n$ `2017`           &lt;dbl&gt; 75.90300, 62.92239, 63.01600, 56.88845, 61.68000, 79.…\n$ `2018`           &lt;dbl&gt; 76.07200, 63.36586, 63.08100, 57.18914, 62.14400, 79.…\n$ `2019`           &lt;dbl&gt; 76.24800, 63.75568, 63.56500, 57.55580, 62.44800, 79.…\n$ `2020`           &lt;dbl&gt; 75.72300, 63.31386, 62.57500, 57.22637, 62.26100, 76.…\n$ `2021`           &lt;dbl&gt; 74.62600, 62.45459, 61.98200, 56.98866, 61.64300, 76.…\n$ `2022`           &lt;dbl&gt; 74.99200, 62.89903, 62.87900, 57.62618, 61.92900, 76.…\n$ `2023`           &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ ...69            &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n\n\nDespliegue de los datos:\n\n# Despliegue de los primeros registros de esperanza de vida en una tabla kable\nesperanza_vida |&gt;\n  head(n = 10) |&gt;\n  kable(format = \"html\")\n\n\n\n\nCountry Name\nCountry Code\nIndicator Name\nIndicator Code\n1960\n1961\n1962\n1963\n1964\n1965\n1966\n1967\n1968\n1969\n1970\n1971\n1972\n1973\n1974\n1975\n1976\n1977\n1978\n1979\n1980\n1981\n1982\n1983\n1984\n1985\n1986\n1987\n1988\n1989\n1990\n1991\n1992\n1993\n1994\n1995\n1996\n1997\n1998\n1999\n2000\n2001\n2002\n2003\n2004\n2005\n2006\n2007\n2008\n2009\n2010\n2011\n2012\n2013\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n...69\n\n\n\n\nAruba\nABW\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\n64.15200\n64.53700\n64.75200\n65.13200\n65.29400\n65.50200\n66.06300\n66.43900\n66.75700\n67.16800\n67.58300\n67.97500\n68.57700\n69.09200\n69.50300\n69.76200\n70.03500\n70.26400\n70.49400\n70.77800\n71.06600\n71.72200\n71.95900\n72.10500\n72.25100\n72.38800\n72.46200\n72.78900\n73.04700\n73.02300\n73.07600\n73.10000\n73.17900\n73.22500\n73.27200\n73.34900\n73.44800\n73.45200\n73.49100\n73.56100\n73.56900\n73.64700\n73.72600\n73.75200\n73.57600\n73.81100\n74.02600\n74.21000\n74.14700\n74.56000\n75.40400\n75.46500\n75.53100\n75.63600\n75.60100\n75.68300\n75.61700\n75.90300\n76.07200\n76.24800\n75.72300\n74.62600\n74.99200\nNA\nNA\n\n\nAfrica Eastern and Southern\nAFE\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\n44.08555\n44.38670\n44.75218\n44.91316\n45.47904\n45.49834\n45.24910\n45.92491\n46.22310\n46.43230\n46.71848\n47.19294\n46.89739\n47.69232\n47.59806\n47.75989\n48.34959\n48.63591\n48.76360\n49.26134\n49.63654\n50.05707\n50.29685\n48.70333\n48.65266\n49.01163\n49.63972\n50.07589\n49.35973\n50.68410\n50.60773\n50.39046\n49.96211\n50.27363\n50.88258\n51.00193\n50.81069\n50.97423\n50.32591\n51.23785\n51.96448\n52.18965\n52.54079\n53.02203\n53.54546\n54.21965\n55.15055\n55.93380\n56.68042\n57.62085\n58.41115\n59.29327\n60.05078\n60.70987\n61.33792\n61.85646\n62.44405\n62.92239\n63.36586\n63.75568\n63.31386\n62.45459\n62.89903\nNA\nNA\n\n\nAfghanistan\nAFG\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\n32.53500\n33.06800\n33.54700\n34.01600\n34.49400\n34.95300\n35.45300\n35.92400\n36.41800\n36.91000\n37.41800\n37.92300\n38.44400\n39.00300\n39.55000\n40.10000\n40.64500\n41.22800\n40.27100\n39.08600\n39.61800\n40.16400\n37.76600\n38.18700\n33.32900\n33.55000\n39.39600\n39.84400\n43.95800\n45.15800\n45.96700\n46.66300\n47.59600\n51.46600\n51.49500\n52.54400\n53.24300\n53.63400\n52.94300\n54.84600\n55.29800\n55.79800\n56.45400\n57.34400\n57.94400\n58.36100\n58.68400\n59.11100\n59.85200\n60.36400\n60.85100\n61.41900\n61.92300\n62.41700\n62.54500\n62.65900\n63.13600\n63.01600\n63.08100\n63.56500\n62.57500\n61.98200\n62.87900\nNA\nNA\n\n\nAfrica Western and Central\nAFW\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\n37.84515\n38.16495\n38.73510\n39.06372\n39.33536\n39.61804\n39.83783\n39.47150\n40.08568\n40.35042\n41.03476\n41.55672\n42.24979\n42.85505\n43.49768\n44.20125\n45.00316\n45.71989\n46.26954\n46.67374\n47.01524\n47.29719\n47.52938\n47.78526\n47.93192\n48.02168\n48.06676\n48.23785\n48.51291\n48.68985\n48.65000\n48.66246\n48.73727\n48.83204\n48.68189\n48.78377\n48.90628\n49.07918\n49.33295\n49.75012\n50.22195\n50.56514\n50.92785\n51.40336\n51.81913\n52.34455\n52.83213\n53.25171\n53.64116\n54.15942\n54.55017\n55.01314\n55.34056\n55.67341\n55.92223\n56.19587\n56.58168\n56.88845\n57.18914\n57.55580\n57.22637\n56.98866\n57.62618\nNA\nNA\n\n\nAngola\nAGO\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\n38.21100\n37.26700\n37.53900\n37.82400\n38.13100\n38.49500\n38.75700\n39.09200\n39.48400\n39.82900\n40.19000\n40.55400\n40.90500\n41.27000\n41.65200\n41.19100\n41.16300\n41.43700\n41.83000\n42.17500\n42.44900\n42.77200\n43.05100\n42.09200\n42.35300\n42.64800\n42.84300\n40.91700\n41.54500\n41.76500\n41.89300\n43.81300\n42.20900\n42.10100\n43.42200\n45.84900\n46.03300\n46.30600\n45.05700\n45.38600\n46.02400\n46.59000\n47.38600\n49.61700\n50.59200\n51.57000\n52.36900\n53.64200\n54.63300\n55.75200\n56.72600\n57.59600\n58.62300\n59.30700\n60.04000\n60.65500\n61.09200\n61.68000\n62.14400\n62.44800\n62.26100\n61.64300\n61.92900\nNA\nNA\n\n\nAlbania\nALB\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\n54.43900\n55.63400\n56.67100\n57.84400\n58.98300\n60.01900\n60.99800\n61.97200\n62.94600\n63.92300\n64.82400\n65.61800\n66.42200\n67.14000\n67.76900\n68.32800\n68.70400\n69.12100\n69.30900\n69.58400\n70.47800\n70.73000\n71.02300\n71.29600\n71.50200\n71.65600\n71.95000\n72.35200\n72.64100\n72.88000\n73.14400\n73.37800\n73.71500\n73.93900\n74.13100\n74.36200\n74.59200\n73.90400\n74.99000\n75.18300\n75.40400\n75.63900\n75.89000\n76.14200\n76.37600\n76.62100\n76.81600\n77.54900\n77.65300\n77.78100\n77.93600\n78.09200\n78.06400\n78.12300\n78.40700\n78.64400\n78.86000\n79.04700\n79.18400\n79.28200\n76.98900\n76.46300\n76.83300\nNA\nNA\n\n\nAndorra\nAND\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nArab World\nARB\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\n44.97290\n45.67640\n46.12258\n46.97247\n47.89576\n48.23211\n48.45707\n48.91291\n49.44512\n49.82224\n50.35134\n51.29642\n51.86446\n52.53968\n53.19444\n53.70986\n54.04753\n55.36147\n56.11217\n56.82629\n57.30237\n57.69293\n58.05480\n58.78737\n59.47898\n60.21574\n61.22126\n61.16971\n60.60903\n62.48114\n62.92797\n63.17961\n63.47441\n64.45832\n65.49673\n65.34978\n65.71840\n65.99442\n65.80771\n66.87673\n67.29733\n67.63168\n67.93557\n67.85900\n67.89591\n68.16268\n68.56725\n68.92868\n69.28643\n69.81264\n70.04125\n70.26152\n70.18046\n70.19651\n70.49263\n70.75822\n70.94306\n71.42960\n71.63302\n71.84463\n70.92336\n70.81448\n71.22727\nNA\nNA\n\n\nUnited Arab Emirates\nARE\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\n48.81100\n49.69500\n50.68600\n51.58400\n52.84800\n53.98500\n55.18500\n56.33900\n57.54000\n58.76000\n60.02100\n61.21100\n62.30400\n63.35100\n64.33800\n65.08000\n65.82000\n66.51400\n67.20900\n67.84600\n68.53000\n69.08500\n69.66000\n69.94900\n70.48500\n70.74700\n70.96400\n71.49100\n71.60600\n71.75700\n71.90000\n72.24100\n72.30600\n72.52100\n72.59800\n72.69500\n72.76700\n72.93700\n73.06600\n73.67000\n74.38000\n74.63600\n74.90100\n76.22200\n76.45300\n76.68300\n76.90900\n77.12900\n77.48800\n78.00300\n78.33400\n78.51700\n78.71600\n78.85300\n79.04400\n79.22300\n79.33500\n79.50400\n79.62700\n79.72600\n78.94600\n78.71000\n79.19600\nNA\nNA\n\n\nArgentina\nARG\nLife expectancy at birth, total (years)\nSP.DYN.LE00.IN\n63.97800\n64.36000\n64.24400\n64.44900\n64.36300\n64.59300\n64.89100\n64.99200\n64.89000\n64.85900\n65.58900\n65.54100\n65.92300\n66.32300\n66.56300\n67.08100\n67.22800\n67.86100\n68.19700\n68.49100\n68.56400\n68.97600\n68.93700\n69.26700\n69.19500\n69.65100\n70.11900\n70.56400\n71.05200\n71.42500\n71.78400\n72.31900\n72.43000\n72.56500\n73.17200\n73.13300\n73.30700\n73.09000\n73.47400\n73.72200\n73.92600\n74.18600\n74.40800\n74.08000\n74.85500\n75.13900\n75.43300\n75.00600\n75.64100\n75.93600\n75.72100\n76.12400\n76.46700\n76.49100\n76.75500\n76.76000\n76.30800\n76.83300\n76.99900\n77.28400\n75.89200\n75.39000\n76.06400\nNA\nNA",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#funciones",
    "href": "08-dplyr.html#funciones",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.3 Funciones",
    "text": "8.3 Funciones\nEn esta sección, se describen y ejemplifican las principales funciones de dplyr.\n\n8.3.1 select()\nLa función select() selecciona (y opcionalmente renombra) columnas de un data frame con base en sus nombres.\n\n# Selección de las columnas ADM0_ISO, NAME, POP_EST, GDP_MD\npaises |&gt;\n  select(ADM0_ISO, NAME, POP_EST, GDP_MD)\n\n# A tibble: 201 × 4\n   ADM0_ISO NAME              POP_EST   GDP_MD\n   &lt;chr&gt;    &lt;chr&gt;               &lt;dbl&gt;    &lt;dbl&gt;\n 1 IDN      Indonesia       270625568  1119190\n 2 MYS      Malaysia         31949777   364681\n 3 CHL      Chile            18952038   282318\n 4 BOL      Bolivia          11513100    40895\n 5 PER      Peru             32510453   226848\n 6 ARG      Argentina        44938712   445445\n 7 GBR      United Kingdom   67366465  2863166\n 8 CYP      Cyprus            1198575    24948\n 9 IND      India          1366417754  2868929\n10 CHN      China          1405862845 14762473\n# ℹ 191 more rows\n\n\nCambio de nombres de columnas:\n\n# Selección y cambio de nombre de las columnas \n# ADM0_ISO, NAME, POP_EST, GDP_MD\npaises |&gt;\n  select(CODIGO_ISO_3 = ADM0_ISO,\n         NOMBRE = NAME,\n         POBLACION_ESTIMADA = POP_EST,\n         PIB_MD = GDP_MD)\n\n# A tibble: 201 × 4\n   CODIGO_ISO_3 NOMBRE         POBLACION_ESTIMADA   PIB_MD\n   &lt;chr&gt;        &lt;chr&gt;                       &lt;dbl&gt;    &lt;dbl&gt;\n 1 IDN          Indonesia               270625568  1119190\n 2 MYS          Malaysia                 31949777   364681\n 3 CHL          Chile                    18952038   282318\n 4 BOL          Bolivia                  11513100    40895\n 5 PER          Peru                     32510453   226848\n 6 ARG          Argentina                44938712   445445\n 7 GBR          United Kingdom           67366465  2863166\n 8 CYP          Cyprus                    1198575    24948\n 9 IND          India                  1366417754  2868929\n10 CHN          China                  1405862845 14762473\n# ℹ 191 more rows\n\n\nEl operador : permite seleccionar un rango de columnas continuas:\n\n# Selección de las columnas desde CONTINENT hasta INCOME_GRP\npaises |&gt;\n  select(CONTINENT:INCOME_GRP)\n\n# A tibble: 201 × 6\n   CONTINENT     REGION_UN SUBREGION          REGION_WB       ECONOMY INCOME_GRP\n   &lt;chr&gt;         &lt;chr&gt;     &lt;chr&gt;              &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;     \n 1 Asia          Asia      South-Eastern Asia East Asia & Pa… 4. Eme… 4. Lower …\n 2 Asia          Asia      South-Eastern Asia East Asia & Pa… 6. Dev… 3. Upper …\n 3 South America Americas  South America      Latin America … 5. Eme… 3. Upper …\n 4 South America Americas  South America      Latin America … 5. Eme… 4. Lower …\n 5 South America Americas  South America      Latin America … 5. Eme… 3. Upper …\n 6 South America Americas  South America      Latin America … 5. Eme… 3. Upper …\n 7 Europe        Europe    Northern Europe    Europe & Centr… 1. Dev… 1. High i…\n 8 Asia          Asia      Western Asia       Europe & Centr… 6. Dev… 2. High i…\n 9 Asia          Asia      Southern Asia      South Asia      3. Eme… 4. Lower …\n10 Asia          Asia      Eastern Asia       East Asia & Pa… 3. Eme… 3. Upper …\n# ℹ 191 more rows\n\n\nSelección de todas las columnas que cumplen una condición:\n\n# Selección de las columnas numéricas\npaises |&gt;\n  select(where(is.numeric))\n\n# A tibble: 201 × 2\n      POP_EST   GDP_MD\n        &lt;dbl&gt;    &lt;dbl&gt;\n 1  270625568  1119190\n 2   31949777   364681\n 3   18952038   282318\n 4   11513100    40895\n 5   32510453   226848\n 6   44938712   445445\n 7   67366465  2863166\n 8    1198575    24948\n 9 1366417754  2868929\n10 1405862845 14762473\n# ℹ 191 more rows\n\n\n\n\n8.3.2 filter()\nLa función filter() retorna un subconjunto de un data frame con todas las filas que satisfacen una condición (i.e. expresión lógica).\nPuede utilizar los operadores relacionales:\n\n== (igual que) Note la diferencia con el operador de asignación (=)\n!= (diferente de)\n&gt; (estrictamente mayor que), &gt;= (mayor o igual que)\n&lt; (estrictamente menor que), &lt;= (menor o igual que)\n\nY los operadores lógicos:\n\n& (AND o Y lógico)\n| (OR u O lógico)\n! (NOT o NO lógico)\n\nEjemplos de uso de expresiones y operadores lógicos:\n\n# Países de Asia con ingresos alto y en la OCDE\n# \npaises |&gt;\n  filter(CONTINENT == 'Asia' & INCOME_GRP == '1. High income: OECD')\n\n# A tibble: 3 × 10\n  ADM0_ISO NAME       CONTINENT REGION_UN SUBREGION REGION_WB ECONOMY INCOME_GRP\n  &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;     \n1 ISR      Israel     Asia      Asia      Western … Middle E… 2. Dev… 1. High i…\n2 KOR      South Kor… Asia      Asia      Eastern … East Asi… 4. Eme… 1. High i…\n3 JPN      Japan      Asia      Asia      Eastern … East Asi… 1. Dev… 1. High i…\n# ℹ 2 more variables: POP_EST &lt;dbl&gt;, GDP_MD &lt;dbl&gt;\n\n\n\n# Países de América del Norte o de América del Sur\npaises |&gt;\n  filter(CONTINENT == 'North America' | CONTINENT == 'South America')\n\n# A tibble: 35 × 10\n   ADM0_ISO NAME      CONTINENT REGION_UN SUBREGION REGION_WB ECONOMY INCOME_GRP\n   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;     \n 1 CHL      Chile     South Am… Americas  South Am… Latin Am… 5. Eme… 3. Upper …\n 2 BOL      Bolivia   South Am… Americas  South Am… Latin Am… 5. Eme… 4. Lower …\n 3 PER      Peru      South Am… Americas  South Am… Latin Am… 5. Eme… 3. Upper …\n 4 ARG      Argentina South Am… Americas  South Am… Latin Am… 5. Eme… 3. Upper …\n 5 SUR      Suriname  South Am… Americas  South Am… Latin Am… 6. Dev… 3. Upper …\n 6 GUY      Guyana    South Am… Americas  South Am… Latin Am… 6. Dev… 4. Lower …\n 7 CRI      Costa Ri… North Am… Americas  Central … Latin Am… 5. Eme… 3. Upper …\n 8 NIC      Nicaragua North Am… Americas  Central … Latin Am… 6. Dev… 4. Lower …\n 9 BRA      Brazil    South Am… Americas  South Am… Latin Am… 3. Eme… 3. Upper …\n10 URY      Uruguay   South Am… Americas  South Am… Latin Am… 5. Eme… 3. Upper …\n# ℹ 25 more rows\n# ℹ 2 more variables: POP_EST &lt;dbl&gt;, GDP_MD &lt;dbl&gt;\n\n\n\n# Países no europeos\npaises |&gt;\n  filter(!(CONTINENT == 'Europe'))\n\n# A tibble: 156 × 10\n   ADM0_ISO NAME      CONTINENT REGION_UN SUBREGION REGION_WB ECONOMY INCOME_GRP\n   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;     \n 1 IDN      Indonesia Asia      Asia      South-Ea… East Asi… 4. Eme… 4. Lower …\n 2 MYS      Malaysia  Asia      Asia      South-Ea… East Asi… 6. Dev… 3. Upper …\n 3 CHL      Chile     South Am… Americas  South Am… Latin Am… 5. Eme… 3. Upper …\n 4 BOL      Bolivia   South Am… Americas  South Am… Latin Am… 5. Eme… 4. Lower …\n 5 PER      Peru      South Am… Americas  South Am… Latin Am… 5. Eme… 3. Upper …\n 6 ARG      Argentina South Am… Americas  South Am… Latin Am… 5. Eme… 3. Upper …\n 7 CYP      Cyprus    Asia      Asia      Western … Europe &… 6. Dev… 2. High i…\n 8 IND      India     Asia      Asia      Southern… South As… 3. Eme… 4. Lower …\n 9 CHN      China     Asia      Asia      Eastern … East Asi… 3. Eme… 3. Upper …\n10 ISR      Israel    Asia      Asia      Western … Middle E… 2. Dev… 1. High i…\n# ℹ 146 more rows\n# ℹ 2 more variables: POP_EST &lt;dbl&gt;, GDP_MD &lt;dbl&gt;\n\n\n\n# Países de Europa en el G7\n# solo con las columnas ADM0_ISO, NAME, POP_EST\npaises |&gt;\n  filter(CONTINENT == \"Europe\" & ECONOMY == \"1. Developed region: G7\") |&gt;\n  select(ADM0_ISO, NAME, POP_EST) |&gt;\n  kable()\n\n\n\n\nADM0_ISO\nNAME\nPOP_EST\n\n\n\n\nGBR\nUnited Kingdom\n67366465\n\n\nFRA\nFrance\n67692632\n\n\nDEU\nGermany\n83132799\n\n\nITA\nItaly\n60297396\n\n\n\n\n\n\n# Países con población mayor o igual al promedio\n#   El argumento lógico na.rm de mean() \n#   indica si los valores NA (\"not available\") \n#   deben ser removidos antes del cálculo\npaises |&gt;\n  filter(POP_EST &gt;= mean(POP_EST, na.rm = TRUE)) |&gt;\n  select(ADM0_ISO, NAME, POP_EST)\n\n# A tibble: 36 × 3\n   ADM0_ISO NAME              POP_EST\n   &lt;chr&gt;    &lt;chr&gt;               &lt;dbl&gt;\n 1 IDN      Indonesia       270625568\n 2 ARG      Argentina        44938712\n 3 GBR      United Kingdom   67366465\n 4 IND      India          1366417754\n 5 CHN      China          1405862845\n 6 ETH      Ethiopia        112078730\n 7 KEN      Kenya            52573973\n 8 TZA      Tanzania         58005463\n 9 FRA      France           67692632\n10 KOR      South Korea      51709098\n# ℹ 26 more rows\n\n\nCondiciones relacionadas con valores NA (nulos):\n\n# Filas con valor NA en la columna 2022 (año 2022)\n# del conjunto de datos de esperanza de vida\nesperanza_vida |&gt;\n  select(`Country Name`, `2022`) |&gt;\n  filter(is.na(`2022`))\n\n# A tibble: 9 × 2\n  `Country Name`           `2022`\n  &lt;chr&gt;                     &lt;dbl&gt;\n1 Andorra                      NA\n2 American Samoa               NA\n3 Curacao                      NA\n4 Cayman Islands               NA\n5 Not classified               NA\n6 Monaco                       NA\n7 Northern Mariana Islands     NA\n8 Palau                        NA\n9 San Marino                   NA\n\n\nNote como en el bloque anterior las columnas Country Name y 2022 deben escribirse entre comillas inversas debido a que una contiene espacios y la otra comienza con un número.\nLa función tidyr::drop_na() remueve las filas con valores NA en una o varias columnas.\n\n# Filas con valor diferente a NA en la columna 2022\nesperanza_vida |&gt;\n  select(`Country Name`,\n         `2022`) |&gt;\n  drop_na(`2022`)\n\n# A tibble: 257 × 2\n   `Country Name`              `2022`\n   &lt;chr&gt;                        &lt;dbl&gt;\n 1 Aruba                         75.0\n 2 Africa Eastern and Southern   62.9\n 3 Afghanistan                   62.9\n 4 Africa Western and Central    57.6\n 5 Angola                        61.9\n 6 Albania                       76.8\n 7 Arab World                    71.2\n 8 United Arab Emirates          79.2\n 9 Argentina                     76.1\n10 Armenia                       73.4\n# ℹ 247 more rows\n\n\n\n# Filas con valor diferente a NA en cualquier columna\npenguins |&gt;\n  select(species,\n         bill_length_mm,\n         bill_depth_mm,\n         flipper_length_mm,\n         body_mass_g,\n         sex) |&gt;\n  drop_na()\n\n# A tibble: 333 × 6\n   species bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex   \n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt; &lt;fct&gt; \n 1 Adelie            39.1          18.7               181        3750 male  \n 2 Adelie            39.5          17.4               186        3800 female\n 3 Adelie            40.3          18                 195        3250 female\n 4 Adelie            36.7          19.3               193        3450 female\n 5 Adelie            39.3          20.6               190        3650 male  \n 6 Adelie            38.9          17.8               181        3625 female\n 7 Adelie            39.2          19.6               195        4675 male  \n 8 Adelie            41.1          17.6               182        3200 female\n 9 Adelie            38.6          21.2               191        3800 male  \n10 Adelie            34.6          21.1               198        4400 male  \n# ℹ 323 more rows\n\n\n\n\n8.3.3 arrange()\nLa función arrange() cambia el orden de las filas de un data frame de acuerdo con los valores de las columnas seleccionadas.\n\n# Ordenamiento ascendente por las columnas POP_EST y GDP_MD\npaises |&gt;\n  arrange(POP_EST, GDP_MD) |&gt;\n  select(NAME, POP_EST, GDP_MD)\n\n# A tibble: 201 × 3\n   NAME                    POP_EST GDP_MD\n   &lt;chr&gt;                     &lt;dbl&gt;  &lt;dbl&gt;\n 1 Vatican                     825    -99\n 2 Antarctica                 4490    898\n 3 Cyprus U.N. Buffer Zone   10000    280\n 4 Tuvalu                    11646     47\n 5 Nauru                     12581    118\n 6 Palau                     18008    268\n 7 San Marino                33860   1655\n 8 Liechtenstein             38019   6876\n 9 Monaco                    38964   7188\n10 St. Kitts and Nevis       52834   1053\n# ℹ 191 more rows\n\n\nPor defecto, las columnas se ordenan de manera acendente. Si se desea un orden descendente, puede utilizarse la función desc().\n\n# Ordenamiento descendente por las columnas POP_EST y GDP_MD\npaises |&gt;\n  arrange(desc(POP_EST), desc(GDP_MD)) |&gt;\n  select(NAME, POP_EST, GDP_MD)\n\n# A tibble: 201 × 3\n   NAME                        POP_EST   GDP_MD\n   &lt;chr&gt;                         &lt;dbl&gt;    &lt;dbl&gt;\n 1 China                    1405862845 14762473\n 2 India                    1366417754  2868929\n 3 United States of America  331595460 21542705\n 4 Indonesia                 270625568  1119190\n 5 Pakistan                  216565318   278221\n 6 Brazil                    211049527  1839758\n 7 Nigeria                   200963599   448120\n 8 Bangladesh                163046161   302571\n 9 Russia                    144373535  1699876\n10 Mexico                    127575529  1268870\n# ℹ 191 more rows\n\n\nLos valores NA (si hay alguno) se ubican al final de cualquier ordenamiento.\n\n\n8.3.4 mutate()\nLa función mutate() crea o modifica columnas en un data frame.\n\n# Creación de la columna GDP_PC,\n# correspondiente al producto interno bruto per cápita en dólares\npaises &lt;-\n  paises |&gt;\n  mutate(GDP_PC = (GDP_MD * 1000000) / POP_EST)\n\n# Despliegue\npaises |&gt;\n  select(NAME, GDP_MD, POP_EST, GDP_PC)\n\n# A tibble: 201 × 4\n   NAME             GDP_MD    POP_EST GDP_PC\n   &lt;chr&gt;             &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n 1 Indonesia       1119190  270625568  4136.\n 2 Malaysia         364681   31949777 11414.\n 3 Chile            282318   18952038 14896.\n 4 Bolivia           40895   11513100  3552.\n 5 Peru             226848   32510453  6978.\n 6 Argentina        445445   44938712  9912.\n 7 United Kingdom  2863166   67366465 42501.\n 8 Cyprus            24948    1198575 20815.\n 9 India           2868929 1366417754  2100.\n10 China          14762473 1405862845 10501.\n# ℹ 191 more rows\n\n\n\n\n8.3.5 group_by() y summarize()\nLa función summarize() se utiliza generalmente junto con la función group_by() para realizar cálculos en grupos de filas de un data frame. group_by() agrupa las filas y summarize() realiza los cálculos (ej. sumas, promedios) en las columnas, para cada grupo. El resultado es un nuevo data frame con una fila por grupo. Si no hay agrupación, se retorna una sola fila correspondiente a los cálculos para todo el data frame.\nEjemplos de cálculos en grupos:\n\n# Mínimo, máximo, promedio de población y cantidad de países\n# para cada región de la ONU\npaises |&gt;\n  group_by(REGION_UN) |&gt;\n  summarize(\n    POP_EST_MIN = min(POP_EST, na.rm = TRUE),\n    POP_EST_MAX = max(POP_EST, na.rm = TRUE),\n    POP_EST_MEAN = mean(POP_EST, na.rm = TRUE),\n    n = n()\n  )\n\n# A tibble: 6 × 5\n  REGION_UN  POP_EST_MIN POP_EST_MAX POP_EST_MEAN     n\n  &lt;chr&gt;            &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt; &lt;int&gt;\n1 Africa           97625   200963599    23381240.    56\n2 Americas         52834   331595460    28909700.    35\n3 Antarctica        4490        4490        4490      1\n4 Asia             10000  1405862845    91256711.    50\n5 Europe             825   144373535    16615735.    45\n6 Oceania          11646    25368867     2970679.    14\n\n\nLa función n() cuenta la cantidad de filas en un grupo.\n\n# Cantidad de países por región y subregión de la ONU\npaises |&gt;\n  group_by(REGION_UN, SUBREGION) |&gt;\n  summarize(\n    N = n()\n  ) |&gt;\n  arrange(desc(N)) |&gt;\n  kable()\n\n\n\n\nREGION_UN\nSUBREGION\nN\n\n\n\n\nAfrica\nEastern Africa\n19\n\n\nAsia\nWestern Asia\n19\n\n\nAfrica\nWestern Africa\n16\n\n\nEurope\nSouthern Europe\n16\n\n\nAmericas\nCaribbean\n13\n\n\nAmericas\nSouth America\n12\n\n\nAsia\nSouth-Eastern Asia\n11\n\n\nEurope\nEastern Europe\n10\n\n\nEurope\nNorthern Europe\n10\n\n\nAfrica\nMiddle Africa\n9\n\n\nAsia\nSouthern Asia\n9\n\n\nEurope\nWestern Europe\n9\n\n\nAmericas\nCentral America\n8\n\n\nAfrica\nNorthern Africa\n7\n\n\nAsia\nEastern Asia\n6\n\n\nAfrica\nSouthern Africa\n5\n\n\nAsia\nCentral Asia\n5\n\n\nOceania\nMicronesia\n5\n\n\nOceania\nMelanesia\n4\n\n\nOceania\nPolynesia\n3\n\n\nAmericas\nNorthern America\n2\n\n\nOceania\nAustralia and New Zealand\n2\n\n\nAntarctica\nAntarctica\n1\n\n\n\n\n\nEjemplo de cálculos sin agrupamiento:\n\n# Promedio de GDP_PC y cantidad de países del mundo\npaises |&gt;\n  summarise(GDP_PC_MEAN = mean(GDP_PC, na.rm = TRUE),\n            n = n())\n\n# A tibble: 1 × 2\n  GDP_PC_MEAN     n\n        &lt;dbl&gt; &lt;int&gt;\n1      15836.   201\n\n\n\n\n8.3.6 Otras\n\n8.3.6.1 distinct()\nLa función distinct() retorna las combinaciones únicas de filas en un data frame.\n\n# Valores distintos de la columna CONTINENT\n\npaises |&gt;\n  distinct(CONTINENT) |&gt;\n  kable()\n\n\n\n\nCONTINENT\n\n\n\n\nAsia\n\n\nSouth America\n\n\nEurope\n\n\nAfrica\n\n\nNorth America\n\n\nOceania\n\n\nAntarctica\n\n\nSeven seas (open ocean)\n\n\n\n\n\n\n\n8.3.6.2 count()\nUna forma alternativa a summarize() para realizar un conteo es con la función count():\n\n# Conteo de países por continente\npaises |&gt;\n  count(CONTINENT)\n\n# A tibble: 8 × 2\n  CONTINENT                   n\n  &lt;chr&gt;                   &lt;int&gt;\n1 Africa                     54\n2 Antarctica                  1\n3 Asia                       49\n4 Europe                     45\n5 North America              23\n6 Oceania                    14\n7 Seven seas (open ocean)     3\n8 South America              12\n\n# Expresión equivalente con summarize\npaises |&gt;\n  group_by(CONTINENT) |&gt;\n  summarize(n = n()) |&gt;\n  kable()\n\n\n\n\nCONTINENT\nn\n\n\n\n\nAfrica\n54\n\n\nAntarctica\n1\n\n\nAsia\n49\n\n\nEurope\n45\n\n\nNorth America\n23\n\n\nOceania\n14\n\n\nSeven seas (open ocean)\n3\n\n\nSouth America\n12",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#ejercicios",
    "href": "08-dplyr.html#ejercicios",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.4 Ejercicios",
    "text": "8.4 Ejercicios\nUtilice las funciones de dplyr para responder a las siguientes preguntas sobre el conjunto de datos paises:\n\n¿Cuántos países hay en cada región del Banco Mundial?\n¿Cuál es el mínimo, máximo y promedio de producto interno bruto per cápita en el continente africano?\n¿Cuál es el promedio de producto interno bruto per cápita por región del Banco Mundial?",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "08-dplyr.html#recursos-de-interés",
    "href": "08-dplyr.html#recursos-de-interés",
    "title": "8  dplyr - gramática para manipulación de datos",
    "section": "8.5 Recursos de interés",
    "text": "8.5 Recursos de interés\nRStudio. (2017). Data transformation with dplyr::Cheat Sheet. https://github.com/rstudio/cheatsheets/blob/45c1e642468695830fd8b724587ccfe8901e2185/data-transformation.pdf",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>dplyr - gramática para manipulación de datos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html",
    "href": "09-ggplot2-plotly.html",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "",
    "text": "Trabajo previo",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#trabajo-previo",
    "href": "09-ggplot2-plotly.html#trabajo-previo",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "",
    "text": "Lecturas\nChang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. O’Reilly. https://r-graphics.org/\nWickham, H., & Grolemund, G. (2017). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (capítulo 3). O’Reilly Media. https://r4ds.had.co.nz/\nWickham, H., & Grolemund, G. (s. f.). R para Ciencia de Datos (1era ed.) (capítulo 3). https://es.r4ds.hadley.nz/\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (s. f.). R for Data Science (2nd ed.) (capítulo 2). https://r4ds.hadley.nz/\nWickham, H., Navarro, D., & Pedersen, T. L. (s.f.). ggplot2: Elegant graphics for data analysis. https://ggplot2-book.org/",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#instalación-y-carga",
    "href": "09-ggplot2-plotly.html#instalación-y-carga",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.1 Instalación y carga",
    "text": "9.1 Instalación y carga\nLos paquetes necesarios pueden instalarse con la función install.packages(). Ya que se usaron en capítulos anteriores, en este punto se asumen instalados los paquetes de Tidyverse.\n\n# Instalación de plotly\ninstall.packages(\"plotly\")\n\n# Instalación de DT\ninstall.packages(\"DT\")\n\nUna vez instalados, los paquetes pueden cargarse con la función library():\n\n# Carga conjunta de Tidyverse \n# (incluye ggplot2, dplyr, readr y otros)\nlibrary(tidyverse)\n\n# Carga de plotly\nlibrary(plotly)\n\n# Carga de DT\nlibrary(DT)\n\n# Carga de scales (para formatear ejes y leyendas en los gráficos)\nlibrary(scales)",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#conjuntos-de-datos-de-ejemplo",
    "href": "09-ggplot2-plotly.html#conjuntos-de-datos-de-ejemplo",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.2 Conjuntos de datos de ejemplo",
    "text": "9.2 Conjuntos de datos de ejemplo\n\n9.2.1 Países\nSe carga un archivo CSV con los datos de países de Natural Earth unidos con los del indicador de esperanza de vida al nacer en 2022 del Banco Mundial (columna LIFE_EXPECTANCY). También incluye la columna correspondiente al producto interno bruto per cápita (columna GDP_PC).\n\n# Carga de los datos de países\npaises &lt;-\n  read_csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2024-ii/refs/heads/main/datos/natural-earth/paises-join-esperanzavida.csv\"\n  )\n\nEn el siguiente bloque de código, se utiliza la función datatable() del paquete DT, para desplegar las observaciones de países en una tabla.\n\n# Tabla de datos de paises\npaises |&gt;\n  datatable(\n    options = list(\n      pageLength = 5,\n      language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n    )\n  )\n\n\n\n\n\nDT es un “envoltorio” (wrapper) de la biblioteca DataTables de JavaScript, un lenguaje ampliamente utilizado en el desarrollo de páginas web interactivas.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#introducción",
    "href": "09-ggplot2-plotly.html#introducción",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "Introducción",
    "text": "Introducción\nR proporciona una gran cantidad de funciones para la elaboración de gráficos estadísticos y otros tipos de visualizaciones. El paquete base de R, por ejemplo, contiene un conjunto básico de funciones muy versátiles, especialmente para gráficos simples de conjuntos de datos relativamente pequeños. Sin embargo, para visualizaciones más avanzadas, puede ser conveniente explorar otras bibliotecas.\nggplot2 es una de las bibliotecas más populares de graficación de R. Implementa el concepto de “gramática de gráficos”, que permite crear visualizaciones complejas a partir de capas y componentes simples. Forma parte de Tidyverse, por lo que se comunica muy bien con los demás paquetes de esta familia, enfocada en conjuntos de datos grandes y en ciencia de datos.\nplotly es una biblioteca para crear gráficos interactivos y dinámicos. Contiene capacidades para agregar controles y mecanismos que le permiten al usuario interactuar con los gráficos y realizar operaciones como filtrados, acercamientos y alejamientos, entre otras.\nEl paquete DT, por su parte, permite presentar conjuntos de datos en tablas interactivas en las que se pueden realizar operaciones como ordenamientos, consultas y filtrados.",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#paquetes-de-graficación",
    "href": "09-ggplot2-plotly.html#paquetes-de-graficación",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.3 Paquetes de graficación",
    "text": "9.3 Paquetes de graficación\nSe introducen los paquetes de graficación estadística ggplot2 y plotly. Se utiliza ggplot2 para elaborar los gráficos y plotly para hacerlos interactivos.\n\n9.3.1 ggplot2\nggplot2 es un sistema para la creación declarativa de gráficos, creado por Hadley Wickham en 2005. Está basado en el libro The Grammar of Graphics, de Leland Wilkinson, un esquema general para visualización de datos que descompone un gráfico en sus principales componentes semánticos, tales como capas y geometrías.\n\n9.3.1.1 Principales componentes de un gráfico\nDe acuerdo con The Grammar of Graphics, los tres principales componentes de un gráfico son:\n\nDatos (observaciones y variables).\nConjunto de mapeos de las variables del conjunto de datos a propiedades visuales (aesthetics) del gráfico, tales como posición en el eje x, posición en el eje y, color, tamaño y forma, entre otras.\nAl menos una capa, la cual describe como graficar cada observación. Por lo general, las capas se crean con funciones de geometrías (ej. puntos, líneas, barras).\n\n\n\n9.3.1.2 Opciones básicas\nggplot2 implementa un gráfico estadístico por medio de la función ggplot(), cuya sintaxis básica puede resumirse de la siguiente forma:\nggplot(data = &lt;DATOS&gt;) + \n    &lt;FUNCION_GEOMETRIA&gt;(mapping = aes(&lt;MAPEOS&gt;))\nEl llamado a ggplot() crea un sistema de coordenadas (i.e. un “canvas”), al cual se le agregan capas. Su primer argumento es &lt;DATOS&gt;, el cual es usualmente un dataframe o un tibble.\nLa función aes() realiza los mapeos (&lt;MAPEOS&gt;) de las variables del conjunto de datos a las propiedades visuales del gráfico. Las capas se crean con funciones de geometrías (&lt;FUNCION_GEOMETRIA&gt;) como geom_point(), geom_bar() o geom_histogram(), entre muchas otras. Note el uso del operador + para agregar las capas al gráfico.\nComo ejemplo, seguidamente se crea un gráfico de dispersión que muestra la variable producto interno bruto (PIB) per cápita (GDP_PC) en el eje X, y la variable esperanza de vida al nacer (LIFE_EXPECTANCY) en el eje Y.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\nggplot(data = paises) + \n  geom_point(mapping = aes(x = GDP_PC, y = LIFE_EXPECTANCY))\n\n\n\n\n\n\n\n\nEl bloque de código anterior puede reescribirse mediante un pipe, para pasar el conjunto de datos a ggplot(). También puede llamarse a aes() como un argumento de ggplot() y no de la función de geometría. Esto último acostumbra hacerse cuando los mapeos de las variables a las propiedades estéticas son los mismos en todas las capas del gráfico.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY)) +\n  geom_point() +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLa función scale_x_continuous() permite usar comas como separadores de miles y establecer los límites del eje X. También evita la notación científica.\nEl gráfico muestra una relación positiva entre el PIB per cápita y la esperanza de vida al nacer. En otras palabras, mientras mayor es el PIB per cápita de un país, mayor es la esperanza de vida al nacer de sus habitantes.\n\n\n9.3.1.3 Variables adicionales\nSe pueden incluir variables adicionales en el gráfico mediante su mapeo a otras propiedades visuales. En el siguiente bloque de código, la variable correspondiente al continente (CONTINENT), se mapea a la propiedad color.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# coloreado por continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLa misma variable puede mapearse a la propiedad visual shape (forma).\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# con formas de puntos correspondientes al continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, shape = CONTINENT)) +\n  geom_point() +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLos últimos continentes de la leyenda no se incluyen en el gráfico debido a que ggplot() solo muestra, por defecto, seis formas diferentes cuando se asignan de manera automática. Esto puede solucionarse si se asigna explícitamente una forma a cada categoría. En el siguiente bloque de código, se asignan manualmente tanto formas como colores a cada continente, mediante las funciones scale_shape_manual() y scale_color_manual().\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# con formas y colores correspondientes al continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, shape = CONTINENT, color = CONTINENT)) +\n  geom_point() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_shape_manual(values = c(0, 1, 2, 3, 4, 5, 6, 7)) +\n  scale_color_manual(values = c(\"red\", \"blue\", \"green\", \"purple\", \"orange\", \"brown\", \"pink\", \"yellow\"))\n\n\n\n\n\n\n\n\nEl siguiente bloque de código mapea la variable de la cilindrada con la propiedad visual tamaño (size) y compara el rendimiento en autopista de los automóviles con el rendimiento en ciudad.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# con tamaño de puntos correspondiente a la población\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, size = POP_EST, color = CONTINENT)) +\n  geom_point() +\n  scale_size_continuous(labels = comma) +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLa función scale_size_continuous() permite usar comas como separadores de miles y evitar la notación científica en la leyenda del gráfico.\n\n\n9.3.1.4 Capas adicionales\nUn mismo gráfico puede contener múltiples capas, cada una con su propia función de geometría. El siguiente bloque de código agrega una capa con la función geom_smooth(), la cual muestra una curva de tendencia.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# + curva de tendencia\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY)) +\n  geom_point() +\n  geom_smooth(method = 'lm') +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nEjercicios\n1. Revise la documentación de geom_smooth() para agregar otros tipos de curvas de tendencia al gráfico.\nEn el siguiente ejemplo, se mapea la variable continente (CONTINENT) a la propiedad visual del color, tanto para la capa de puntos como para la de la curva de tendencia.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90))\n\n\n\n\n\n\n\n\n\n\n9.3.1.5 Paneles\nComo se mostró anteriormente, una forma de mostrar variables adicionales en un gráfico es mediante propiedades visuales (color, forma, tamaño, etc.). Otra forma es mediante el uso de paneles (facets), los cuales dividen un gráfico en subgráficos, de acuerdo con los valores de una variable. Este método es particularmente apropiado cuando la variable adicional es categórica.\nLa función facet_wrap() divide un gráfico en paneles de acuerdo con una sola variable. El primer argumento es una fórmula, la cual se crea con el caracter ~ (tilde) seguido por el nombre de la variable.\nEn el siguiente bloque de código, se generan paneles para cada continente con el gráfico de dispersión de PIB per cápita vs esperanza vida. Es decir, un panel (subgráfico) por cada continente.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# + paneles por continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY)) +\n  geom_point() +\n  facet_wrap(~ CONTINENT, nrow = 2) +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\nLa función facet_grid() genera paneles con la combinación de dos variables. El primer argumento es también una fórmula, la cual contiene dos variables separadas por ~.\nEn el siguiente bloque de código, se generan paneles para el gráfico anterior, organizados por región de la ONU y grupo de ingresos.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# + paneles por región y subregión de la ONU\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY)) +\n  geom_point() +\n  facet_grid(REGION_UN ~ INCOME_GRP) +\n  scale_x_continuous(labels = comma, limits = c(0, NA))\n\n\n\n\n\n\n\n\n\n\n9.3.1.6 Títulos, etiquetas, estilos y colores\n\n9.3.1.6.1 Titulos, subtítulos y etiquetas\nggplot2 incluye las funciones ggtitle(), xlab(), ylab() y labs(), las cuales permiten agregar títulos, subtítulos, etiquetas en los ejes y de otros tipos a un gráfico.\nAlgunas de las opciones que ofrecen estas funciones se ilustran en el siguiente gráfico.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(subtitle = \"Datos de África y Europa\", \n       caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\")\n\n\n\n\n\n\n\n\nEl títulos y las etiquetas de los ejes se pueden agregar también mediante argumentos de labs().\n\n\n9.3.1.6.2 Estilos\nggplot2 incluye un conjunto de estilos (themes) que pueden ayudar a mejorar el aspecto visual de los gráficos.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(subtitle = \"Datos de África y Europa\", \n       caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  theme_bw() # tema de ggplot2\n\n\n\n\n\n\n\n\nEjercicios\n1. Revise la documentación de estilos de ggplot2 y pruebe diferentes opciones en el gráfico anterior.\nExisten paquetes que ofrecen estilos adicionales como, por ejemplo, ggthemes.\n\n# Instalación de ggthemes\ninstall.packages(\"ggthemes\")\n\n\n# Carga de ggthemes\nlibrary(ggthemes)\n\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(subtitle = \"Datos de África y Europa\", \n       caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  theme_economist() # estilo de ggthemes\n\n\n\n\n\n\n\n\nOtro paquete de estilos y recursos relacionados (escalas de colores, fuentes, etc.) es hrbrthemes.\n\n# Instalación de hbrthemes\ninstall.packages(\"hrbrthemes\")\n\n\n# Carga de hbrthemes\nlibrary(hrbrthemes)\n\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n# en África y Europa coloreado por continente\n# + curva de tendencia\npaises |&gt;\n  filter(CONTINENT == 'Africa' | CONTINENT == 'Europe') |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(subtitle = \"Datos de África y Europa\", \n       caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  theme_ipsum() # tema de hrbrthemes\n\n\n\n\n\n\n\n\n\n\n9.3.1.6.3 Colores\nggplot2 incluye múltiples funciones para escalas de colores, entre las que pueden mencionarse:\n\nscale_color_brewer(): para escalas de colores secuenciales, divergentes y cualitativas de ColorBrewer.\nscale_color_viridis_d(): para escalas viridis, diseñadas para mejorar la legibilidad de gráficos para lectores con formas comunes de daltonismo y discapacidades relacionadas con la percepción de colores.\nscale_color_manual(): para especificar directamente los colores a utilizar.\n\nEl siguiente bloque de código genera un gráfico de dispersión para los datos de diamonds. Muestra el peso en quilates (carat) de los diamantes en el eje X y su precio (price) en el eje Y. La variable correspondiente a su claridad (clarity) se muestra mediante el color de los puntos, de acuerdo con una escala de ColorBrewer.\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\n#  coloreado por continente\npaises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  labs(color = \"Población estimada\") +\n  scale_colour_brewer(palette = \"YlOrBr\", direction = -1) +\n  theme_ipsum() # estilo de hrbrthemes\n\n\n\n\n\n\n\n\nPara más información sobre etiquetas, estilos, colores y otros temas relacionados en ggplot2, se recomienda leer ggplot2: Elegant Graphics for Data Analysis - Themes.\n\n\n\n9.3.1.7 Opciones avanzadas\nEn las secciones y ejemplos anteriores, se han estudiado las opciones básicas para crear un gráfico en ggplot2: datos, mapeos de variables a propiedades visuales y capas. También se mostró la forma de implementar paneles, como un mecanismo para visualizar variables adicionales y algunos recursos para mejorar la apariencia de los gráficos.\nggplot2 incluye otras opciones para la creación de gráficos, como transformaciones estadísticas, transformaciones de sistemas de coordenadas y posicionamiento de las geometrías, las cuales pueden esquematizarse de la siguiente forma:\nggplot(data = &lt;DATOS&gt;) + \n  &lt;FUNCION_GEOMETRIA&gt;(\n    mapping = aes(&lt;MAPEOS&gt;),\n    stat = &lt;ESTADISTICA&gt;,\n    position = &lt;POSICION&gt;\n  ) +\n  &lt;FUNCION_COORDENADAS&gt; +\n  &lt;FUNCION_FACET&gt;\nEn las secciones siguientes, se explicarán y ejemplificarán alguna de estas opciones.\n\n\n\n9.3.2 plotly\nplotly R es una biblioteca para gráficos interactivos que forma parte del grupo de bibliotecas de graficación de Plotly, el cual también incluye bibliotecas para otros lenguajes como Python, Julia, F# y MATLAB. Plotly fue originalmente escrita en JavaScript, por lo que es particularmente adecuada para gráficos interactivos en la Web.\nplotly implementa la función ggplotly(), la cual convierte graficos de ggplot2 a plotly, haciéndolos interactivos.\nEl siguiente bloque de código muestra un gráfico generado con ggplot2 y convertido a plotly con la función ggplotly().\n\n# Gráfico de dispersión de PIB per cápita vs esperanza de vida al nacer\ngrafico_ggplot2 &lt;-\n  paises |&gt;\n  ggplot(aes(x = GDP_PC, y = LIFE_EXPECTANCY, color = CONTINENT)) +\n  geom_point(aes(\n    # datos que se muestran al colocar el ratón sobre un punto\n    text = paste0(\n      \"PIB per cápita: \", GDP_PC, \"\\n\",\n      \"Esperanza de vida: \", LIFE_EXPECTANCY\n    )\n  )) +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  scale_y_continuous(labels = comma, limits = c(50, 90)) +\n  ggtitle(\"PIB per cápita vs esperanza de vida al nacer por continente\") +\n  xlab(\"PIB per cápita  (USD)\") +\n  ylab(\"Esperanza de vida (años)\") +\n  labs(caption = \"Fuentes: Natural Earth y Banco Mundial\",\n       color = \"Continente\") +\n  labs(color = \"Población estimada\") +\n  theme_ipsum() # estilo de hrbrthemes\n\n# Gráfico plotly\nggplotly(grafico_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es') # para mostrar los controles en español",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#recursos-de-interés",
    "href": "09-ggplot2-plotly.html#recursos-de-interés",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.5 Recursos de interés",
    "text": "9.5 Recursos de interés\nDT: An R interface to the DataTables library. (s. f.). Recuperado 21 de mayo de 2022, de https://rstudio.github.io/DT/\nHealy, Y. H. and C. (s. f.). From data to Viz | Find the graphic you need. Recuperado 20 de marzo de 2022, de https://www.data-to-viz.com/\nRStudio. (2017). Data visualization with ggplot2::Cheat Sheet. https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf\nWickham, H. (2010). A Layered Grammar of Graphics. Journal of Computational and Graphical Statistics, 19(1), 3-28. https://doi.org/10.1198/jcgs.2009.07098",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  },
  {
    "objectID": "09-ggplot2-plotly.html#tipos-de-gráficos",
    "href": "09-ggplot2-plotly.html#tipos-de-gráficos",
    "title": "9  ggplot2 y plotly - creación declarativa de gráficos interactivos",
    "section": "9.4 Tipos de gráficos",
    "text": "9.4 Tipos de gráficos\nEn esta sección, se ejemplifican varios tipos de gráficos, los cuales se construyen con ggplot2 y luego se convierten a plotly.\n\n9.4.1 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (en este caso, llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable. La graficación de la distribución de las variables es, frecuentemente, una de las primeras tareas que se realiza cuando se explora un conjunto de datos.\nEn ggplot2, los histogramas se implementan con la función geom_histogram().\nEl siguiente bloque de código muestra, mediante un histograma, la distribución del producto interno bruto (PIB) per cápita para el año 2007, entre los países incluídos en gapminder.\n\n# Histograma ggplot2 de distribución del PIB per cápita\nhistograma_ggplot2 &lt;- \n  paises |&gt;\n  ggplot(aes(x = GDP_PC)) +\n  geom_histogram(\n    aes(\n      text = paste0(\n        \"PIB per cápita (valor medio del rango): $\", round(after_stat(x), 2), \"\\n\",\n        \"Frecuencia: \", after_stat(count)\n      )\n    ), \n    bins = 10\n  )  +\n  scale_x_continuous(labels = comma, limits = c(0, NA)) +\n  coord_cartesian(ylim = c(0, 50)) +\n  ggtitle(\"Distribución del PIB per cápita\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Frecuencia\") +\n  labs(subtitle = \"Datos de 201 países\", caption = \"Fuentes: Natural Earth y Banco Mundial\") +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2, tooltip = \"text\") |&gt; \n  config(locale = 'es')\n\n\n\n\n\nLa función geom_density() permite crear una estimación de densidad del kernel (Kernel Density Estimation o KDE), una curva que muestra la densidad de los datos.\n\n# Histograma ggplot2 de distribución del PIB per cápita\nhistograma_ggplot2 &lt;-\n  paises |&gt;\n  ggplot(aes(x = GDP_PC)) +\n  geom_histogram(\n    aes(\n      text = paste0(\n        \"PIB per cápita (valor medio del rango): $\", round(after_stat(x), 2), \"\\n\",\n        \"Frecuencia: \", after_stat(count)\n      ),\n      y = after_stat(density) # argumento necesario para crear la curva KDE\n    ),\n    bins = 10\n  ) +\n  geom_density() +\n  scale_y_continuous(labels = scales::label_comma()) + # para formatear el eje y en notación decimal\n  ggtitle(\"Distribución del PIB per cápita\") +\n  xlab(\"PIB per cápita ($ EE.UU.)\") +\n  ylab(\"Densidad\") +\n  labs(subtitle = \"Datos de 201 países\", caption = \"Fuentes: Natural Earth y Banco Mundial\") +\n  theme_economist()\n\n# Histograma plotly\nggplotly(histograma_ggplot2, tooltip = \"text\") |&gt;\n  config(locale = 'es')",
    "crumbs": [
      "IV - Graficación estadística en R",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>ggplot2 y plotly - creación declarativa de gráficos interactivos</span>"
    ]
  }
]